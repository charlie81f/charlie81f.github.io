<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>毗卢寺/鸡鸣寺游记</title>
    <link href="/2025/09/12/piluJimingTravel/"/>
    <url>/2025/09/12/piluJimingTravel/</url>
    
    <content type="html"><![CDATA[<h1 id="毗卢寺">毗卢寺</h1><figure><img src="house.png" alt="河边豪斯" /><figcaption aria-hidden="true">河边豪斯</figcaption></figure><p>路过的河边看到的小豪斯，有小河有花园，住起来应该很舒服。</p><figure><img src="door01.png" alt="毗卢寺侧门" /><figcaption aria-hidden="true">毗卢寺侧门</figcaption></figure><p>旁边是小学，对门是医院，这附近环境非常安静，很适合休闲散心。</p><figure><img src="mainHall01.png" alt="大殿总览" /><figcaption aria-hidden="true">大殿总览</figcaption></figure><p>布局简单，大概是正殿和两个偏殿，左侧还有一个鼓楼，正殿对着的是烧香的地方。</p><figure><img src="mainHall02.png" alt="大殿" /><figcaption aria-hidden="true">大殿</figcaption></figure><figure><img src="statue01.png" alt="弥勒佛" /><figcaption aria-hidden="true">弥勒佛</figcaption></figure><p>供奉的是弥勒佛和释加牟尼。</p><figure><img src="statue02.png" alt="金刚" /><figcaption aria-hidden="true">金刚</figcaption></figure><figure><img src="statue03.png" alt="释迦牟尼佛" /><figcaption aria-hidden="true">释迦牟尼佛</figcaption></figure><p>门票￥10，上香是免费的。</p><p> </p><h1 id="鸡鸣寺">鸡鸣寺</h1>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>南京</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>南京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2025/09/10/os/"/>
    <url>/2025/09/10/os/</url>
    
    <content type="html"><![CDATA[<h1 id="线程多开的弊端">线程多开的弊端</h1><p>1、系统资源消耗过大</p><ul><li>内存开销：每个线程需要独立的线程栈（几百 KB 到数 MB），线程数多了会占用大量内存。</li><li>句柄/内核对象消耗：OS维护线程管理信息（TCB，线程控制块），也是负担。</li></ul><p>2、频繁上下文切换</p><ul><li>CPU可能一直在进行多线程切换而非执行实际任务，性能反而降低。</li></ul><p>3、线程调度开销增加</p><ul><li>线程调度器要在大量线程中决定调度，调度队列变长，增加调度延迟。</li></ul><p>4、竞争和同步问题</p><ul><li>多线程共享内存时，访问同一资源产生竞争，增加死锁，活锁等风险。</li></ul><p>5、缓存一致性和CPU亲和性问题</p><ul><li>如果线程频繁切换核，可能导致缓存失效，增加内存访问延迟。</li></ul><p>6、程序稳定性风险</p><ul><li>线程数超过系统支持的最大值可能导致线程创建失败或者系统卡顿甚至崩溃。</li></ul><p>改善：</p><ul><li>采用线程池：用固定数量线程复用，避免无限创建。</li><li>异步/事件驱动模型：在 I/O 密集型任务中，比开很多线程更高效。</li><li>限制线程数：一般根据 CPU核心数 和 任务性质（CPU 密集 or I/O 密集）来决定线程数量。</li></ul><p> </p><h1 id="simd">SIMD</h1><p>单指令多数据</p><p>一种并行计算方式，允许处理器用一条指令同时对多个数据元素进行操作。</p><p>最常见的CPU向量化技术，MIMD则是多核CPU的通用并行方式。</p><p>实现方式：</p><ul><li>寄存器向量化：CPU有专门的向量寄存器（如Intel AVX，SSE）：<ul><li>SSE：128b向量寄存器</li><li>AVX：256b向量寄存器</li></ul></li><li>GPU并行：GPU本身就非常擅长SIMD计算，每个线程执行相同指令，处理不同数据。</li></ul><p>优点：</p><ul><li>提升速度</li><li>降低功耗</li><li>适合向量化任务：图像滤波，矩阵运算，信号处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2025/09/08/java/"/>
    <url>/2025/09/08/java/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构">JVM内存结构</h1><p>JVM 执行 Java 程序时会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途、创建和销毁时间。</p><p>1、程序计数器（Program Counter Register）</p><p>当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>特点：</p><ul><li><p>线程私有：每条线程有个独立的PCR，互不影响，独立存储。</p></li><li><p>如果正在执行Java方法，PCR的值为正在执行的JVM的字节码指令地址；如果是Native方法，值为空。</p></li><li><p>唯一一个没有<code>OutOfMemoryError</code>情况的区域</p></li></ul><p>2、Java虚拟机栈（Java Virtual Machine Stacks）</p><p>Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧 (Stack Frame)， 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到完成的过程，对应着一个栈帧在JVM栈中从入栈到出栈的过程。</p><p>特点：</p><ul><li>线程私有</li><li>存储内容：局部变量表，编译期可知的基本数据类型，对象引用类型和返回地址类型。</li><li>异常：<code>StackOverflowError</code>，<code>OutOfMemoryError</code></li></ul><p>3、本地方法栈（Native Method Stack）</p><p>与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>特点和虚拟机栈类似。</p><p>4、Java堆（Java Heap）</p><p>此内存区唯一的目的就是存放对象实例，基本在这里分配内存，通常所说的堆内存就是Java堆。</p><p>特点：</p><ul><li>线程共享：Java 堆是虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。</li><li>GC 堆：Java 堆是垃圾收集器管理的主要区域，也被称为”GC堆“。</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>5、方法区（Method Area）</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>特点：</p><ul><li>线程共享</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>6、运行时常量池（Runtime Constant Pool）</p><p>方法区的一部分，常量池表 (Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的RCP中。</p><p>特点：</p><ul><li>动态性，并非预置入 Class 文件常量池的内容才能进入RCP，运行期间也可能将新的常量放入池中。</li></ul><p>7、直接内存（Direct Memory）</p><p>并不是虚拟机运行时数据区的一部分，但也有可能导致<code>OutOfMemoryError</code>。</p><p> </p><p> </p><h1 id="java内存模型jmm">Java内存模型（JMM）</h1><p>抽象的概念，并不真实存在，核心目标是解决多线程环境下的三个问题：</p><ul><li>原子性：一个操作或多个操作要么全部执行成功，要么全部不执行。</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>规定了：</p><ul><li>所有的变量都在主存（MM）中</li><li>每条线程还有自己的工作内存（WM），WM中保存了被该线程使用到的变量的MM副本拷贝。</li><li>线程对变量的所有操作（读取、赋值等）都必须在WM中进行，而不能直接读写MM中的变量。</li><li>不同的线程之间也无法直接访问对方WM中的变量，线程间变量值的传递均需要通过MM来完成。</li></ul><p> </p><p> </p><h1 id="java对象引用模式">JAVA对象引用模式</h1><p>Java 的引用模式是其内存管理和对象访问的核心，Java通过引用来间接操作所有对象。</p><p>对象：堆内存中实际存在的数据实体，包含了其所属类的所有成员的变量的值。</p><p>引用：一个变量，其值是对象在堆内存中的地址，引用本身存储在栈内存或另一个对象中。</p><p>关键点：</p><ul><li><code>new</code>在堆上创建对象，并返回该对象的地址。</li><li><code>=</code>是复制地址值并非复制对象，多个引用指向同一个对象。</li><li><code>null</code>不指向任何对象。</li></ul><p>参数传递：</p><p>Java中只有按值传递，传递的是地址的副本，并非引用更不是对象。</p><p> </p><h1 id="equals和的区别"><code>equals()</code>和<code>==</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>equlas</code></th><th><code>==</code></th></tr></thead><tbody><tr class="odd"><td>本质</td><td>操作符</td><td>方法（定义在<code>Object</code>类中）</td></tr><tr class="even"><td>比较对象</td><td>内存地址</td><td>内容（需要重写，比如<code>String</code>,<code>Integer</code>）</td></tr><tr class="odd"><td>比较基本类型</td><td>实际值</td><td>不能用于基本类型</td></tr><tr class="even"><td>是否可自定义</td><td>否</td><td>是</td></tr></tbody></table><p> </p><h1 id="arraylist和linkedlist的区别"><code>ArrayList</code>和<code>LinkedList</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr class="odd"><td>底层数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr class="even"><td>获取元素</td><td>O(1)<br>支持随机访问</td><td>O(n)<br>从表头或者表尾开始遍历</td></tr><tr class="odd"><td>插入/删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr class="even"><td>遍历效率</td><td>高</td><td>低</td></tr><tr class="odd"><td>内存占用</td><td>小</td><td>大</td></tr><tr class="even"><td>应用场景</td><td>读多写少，绝大多数情况</td><td>写多读少，栈，队列等</td></tr></tbody></table><p> </p><h1 id="接口">接口</h1><p>一种抽象类型，定义类必须实现的方法的集合，但接口本身不能有方法的具体实现（Java8之后<code>default</code>和<code>static</code>可以实现），主要提供一种规范，使得不同类可以通过统一接口进行交互，而不关心具体实现。</p><p>实现接口：<code>implements</code></p><p>特点：</p><ul><li>多实现</li><li>解耦：减少类之间的耦合</li><li>多态：实现运行时多态</li></ul><p> </p><h1 id="函数覆写">函数覆写</h1><p>子类重新定义从父类继承而来的同名函数，以实现不同的功能。</p><p>要求：</p><ul><li>方法签名相同：函数名，参数个数、类型都必须相同。</li></ul><p><em># 参数列表必须完全相同，不一致则变成函数重载（overload）</em></p><ul><li>访问权限：子类方法的访问权限不能比父类更严格。</li><li>多态体现：当父类指针/引用调用函数时，会根据实际对象类型执行子类方法（支持虚函数/动态绑定）。</li></ul><p>关键字：<code>virtual</code>，<code>override</code></p><p> </p><h1 id="java泛型">Java泛型</h1><p>写一个类或者方法时，不指定具体的数据类型，而是用一个类型参数来代替，使用时再指定具体类型，减少强制类型转换的需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.<span class="built_in">setContent</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str = stringBox.<span class="built_in">getContent</span>(); <span class="comment">// 不需要强转</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.<span class="built_in">setContent</span>(<span class="number">123</span>);</span><br><span class="line">Integer num = intBox.<span class="built_in">getContent</span>();</span><br></pre></td></tr></table></figure><p>不止是类，还可以用于泛型接口，方法等。</p><p>优点：</p><ul><li>类型安全</li><li>减少强制转换</li><li>可读性强</li></ul><p><em># 不能用于基本类型</em></p><p>常用场景：集成框架，工具类方法，通用对象封装。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2025/09/03/springboot/"/>
    <url>/2025/09/03/springboot/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot">SpringBoot</h1><figure><img src="intro.png" alt="介绍" /><figcaption aria-hidden="true">介绍</figcaption></figure><p>SpringBoot是一个Spring模块，提供了RAD(快速应用程序开发)功能。它用于创建独立的基于Spring的应用程序，需要最少的Spring配置就可以运行。</p><p>即Spring框架和嵌入式服务器的组合。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ssh连接github失败</title>
    <link href="/2025/08/27/sshBug/"/>
    <url>/2025/08/27/sshBug/</url>
    
    <content type="html"><![CDATA[<p>先尝试<code>ssh -T git@github.com</code>。</p><p> </p><p>有可能是22端口被阻隔了，尝试443端口，在config中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com </span><br><span class="line">        Hostname ssh.github.com </span><br><span class="line">        Port 443</span><br><span class="line">        User git</span><br><span class="line">        ProxyCommand connect -S 系统代理地址 %h %p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2025/08/26/machineLearning/"/>
    <url>/2025/08/26/machineLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><figure><img src="machineLearningProcess.png" alt="流程示例" /><figcaption aria-hidden="true">流程示例</figcaption></figure><figure><img src="mlClassfication.png" alt="类型" /><figcaption aria-hidden="true">类型</figcaption></figure><figure><img src="mlWork.png" alt="工作流" /><figcaption aria-hidden="true">工作流</figcaption></figure><p> </p><h1 id="神经网络">神经网络</h1><figure><img src="cnnBasic.png" alt="基础" /><figcaption aria-hidden="true">基础</figcaption></figure><p>神经元接收输入信号，通过加权求和后与偏置相加，然后通过激活函数处理以产生输出。神经元的权重和偏置是网络学习过程中需要调整的参数。</p><p> </p><h2 id="前馈神经网络">前馈神经网络</h2><figure><img src="fnn.png" alt="Feedforward Neural Network，FNN" /><figcaption aria-hidden="true">Feedforward Neural Network，FNN</figcaption></figure><p>基本单元，前馈神经网络特点是数据从输入层开始，经过一个或多个隐藏层，最后到达输出层，全过程没有循环或反馈。</p><p> </p><h2 id="循环神经网络">循环神经网络</h2><figure><img src="rnn.png" alt="Recurrent Neural Network, RNN" /><figcaption aria-hidden="true">Recurrent Neural Network, RNN</figcaption></figure><p>专门处理序列数据的神经网络，能够捕获输入数据中时间或顺序信息的依赖关系,在自然语言处理（NLP）、语音识别、时间序列预测等任务中有着广泛的应用。</p><p>关键特性：其能够保持隐状态（hidden state），使得网络能够记住先前时间步的信息。</p><p>隐状态：通过上一时间步的隐状态和当前输入共同计算得到的。</p><p> 公式：<span class="math inline"><em>h</em><sub><em>t</em></sub> = <em>f</em>(<em>W</em><sub><em>h</em><em>h</em></sub><em>h</em><sub><em>t</em> − 1</sub> + <em>W</em><sub><em>x</em><em>h</em></sub><em>x</em><sub><em>t</em></sub> + <em>b</em><sub><em>h</em></sub>)</span></p><p><em># <span class="math inline"><em>h</em><sub><em>t</em></sub></span>：当前时刻隐状态；<span class="math inline"><em>h</em><sub><em>t</em> − 1</sub></span>：前一时刻隐状态；<span class="math inline"><em>W</em><sub><em>x</em><em>h</em></sub>, <em>W</em><sub><em>h</em><em>h</em></sub></span>：权重矩阵；<span class="math inline"><em>x</em><sub><em>t</em></sub></span>：当前时刻的输入；<span class="math inline"><em>b</em><sub><em>h</em></sub></span>：偏置；<span class="math inline"><em>f</em>()</span>：激活函数。</em></p><p>输出：不仅依赖当前输入，还依赖于隐状态的历史信息。</p><p> 公式：<span class="math inline"><em>y</em><sub><em>t</em></sub> = <em>W</em><sub><em>h</em><em>y</em></sub><em>h</em><sub><em>t</em></sub> + <em>b</em><sub><em>y</em></sub></span></p><p><em># <span class="math inline"><em>y</em><sub><em>t</em></sub></span>：t时刻的输出向量；<span class="math inline"><em>W</em><sub><em>h</em><em>y</em></sub></span>：隐状态到输出状态的矩阵。</em></p><figure><img src="unfoldRnn.png" alt="展开视图" /><figcaption aria-hidden="true">展开视图</figcaption></figure><p> </p><h2 id="卷积神经网络">卷积神经网络</h2><figure><img src="cnn.png" alt="Convolutional Neural Networks, CNN" /><figcaption aria-hidden="true">Convolutional Neural Networks, CNN</figcaption></figure><p>专门用于处理具有网格状拓扑结构数据（如图像）的深度学习模型，是计算机视觉任务（如图像分类、目标检测和分割）的核心技术。</p><p> </p><h2 id="transformer模型">Transformer模型</h2><p>一种基于注意力机制的深度学习模型，仅依赖注意力机制来处理序列数据，从而实现更高的并行性和更快的训练速度。</p><figure><img src="transformer.png" alt="transformer结构" /><figcaption aria-hidden="true">transformer结构</figcaption></figure><p>结构：</p><ul><li>编码器（Encoder）：由NN层相同的模块堆叠而成，每层包含两个子层，每个子层后面都接有 残差连接（Residual Connection） 和 层归一化（Layer Normalization）。</li></ul><p> 多头自注意力机制（Multi-Head Self-Attention）：计算输入序列中每个词与其他词的相关性。</p><p> 前馈神经网络（FNN）：对每个词进行独立的非线性变化。</p><ul><li>解码器（Decoder）：由NN层相同的模块堆叠而成，每层包含三个子层，每个子层后面都接有残差连接和层归一化。</li></ul><p> 掩码多头自注意力机制（Masked Multi-Head Self-Attention）：计算输出序列中每个词和其他词的相关性。</p><p><em># 使用掩码防止未来信息泄露</em></p><p> 交叉注意力机制（Encoder-Decoder Attention）：计算输出序列与输入序列的相关性。</p><p> 前馈神经网络（FNN）</p><p>核心思想：</p><ul><li>自注意力机制（Self-Attention）：允许模型在处理序列时，动态地为每个位置分配不同的权重，从而捕捉序列中任意两个位置之间的依赖关系。</li><li>多头注意力（Multi-Head Attention）：将输入分成多个子空间，每个子空间独立计算注意力，最后将结果拼接起来。</li><li>位置编码（Positional Encoding）：位置编码被用来为输入序列中的每个词添加位置信息，代替序列信息（如RNN中的时间步）。</li></ul><p>优势：并行计算，长距离依赖（解决RNN的梯度消失），可扩展性。</p><p>应用：NLP（机器翻译，GPT），CV（图像分类，目标检测），多模态任务。</p><p> </p><p> </p><h1 id="conda指令">Conda指令</h1><p> 查看环境：<code>conda env list</code></p><p> 进入环境：<code>conda activate 环境名称</code></p><p> 退出环境：<code>conda deactivate</code></p><p> 删除环境：<code>conda remove --name 环境名称 --all</code></p><p> 更换为阿里云镜像源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p><p> 查看当前源：<code>pip config list</code></p><p> 查看当前包：<code>pip list</code></p><p> 下载依赖包requirements.txt：<code>pip install -r requirements.txt</code></p><p> </p><p> </p><h1 id="训练模型">训练模型</h1><p>模型文件=模型结构+预训练权重</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/2025/08/22/web/"/>
    <url>/2025/08/22/web/</url>
    
    <content type="html"><![CDATA[<p>Json对象和数组：</p><p>​ 对象是键值对集合，数组是值的有序列表；</p><p>​ Json对象的值可以包含数组，数组的元素也可以是一个对象，能够支持多层嵌套。</p><p> </p><p>前端渲染和后端渲染：</p><figure><img src="render.png" alt="render.png" /><figcaption aria-hidden="true">render.png</figcaption></figure><p>​ 前端渲染：React,Vue等；后端渲染：传统PHP,Java,Python等。</p><p>​ 现代开发常采用混合方案：同构渲染，首次访问使用SSR快速呈现内容，后续交互转为CSR提供流畅体验，如 Next.js (React), Nuxt.js (Vue)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript</title>
    <link href="/2025/08/22/javascript/"/>
    <url>/2025/08/22/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="文件与拖拽api的底层原理">文件与拖拽API的底层原理</h1><p>文件API：</p><p> 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；</p><p> 无路径访问：JavaScript无法知晓真正的文件路径；</p><p> 同源限制：读取的文件内容只能在当前页面上下文使用。</p><p>拖拽API：</p><p>拖拽本质是操作系统提供的跨应用（跨源）通信机制。</p><p>过程：</p><p> 拖拽开始时，OS创建“拖拽会话”；</p><p> 拖拽过程中，系统跟踪光标位置并查询下方的放置目标；</p><p> 放置时，系统协调数据传递。</p><figure><img src="dragAndDrop.png" alt="拖拽实现的层次" /><figcaption aria-hidden="true">拖拽实现的层次</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascipt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/2025/08/22/dsa/"/>
    <url>/2025/08/22/dsa/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="枚举算法">枚举算法</h2><p>描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。</p><p>核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解，关注枚举的上下界。</p><p>优点：简单基本，便于实现，容易调试，正确性容易证明。</p><p>思路：</p><ul><li><p>确定枚举对象、枚举的上下界、判断条件。</p></li><li><p>枚举可能的情况并验证是否是问题的解。</p></li><li><p>考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。</p><p>题库：百钱买百鸡，LeetCode78，1504，1733，2749。</p></li></ul><p> </p><h2 id="贪心算法greedy-algorithm">贪心算法Greedy Algorithm</h2><p>基本思想：每一步都做出在当前看来是最好的选择，期望通过局部最优选择来达到全局最优解。</p><p>核心思想：局部最优，不可回溯，期望全局最优。</p><p><em># 贪心只做局部最优选择，不保证全局最优。</em></p><p>思路：</p><ul><li>建立数学模型</li><li>分解问题</li><li>制定贪心策略</li><li>求解子问题</li><li>合并成原问题解</li></ul><p>优点：高效，时间复杂度低，简单直观。</p><p>题库：LeetCode134，1792。</p><p> </p><h2 id="动态规划dynamic-programming">动态规划Dynamic programming</h2><p>描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。</p><p>一般的递归时间复杂度太高，<code>递归时间复杂度 = 解决一个子问题时间*子问题个数</code>，需要把子问题的结果进行存储，利用空间来降低时间复杂度，把二叉树变成了树干，子问题个数从O(2<sup>n</sup>)变成了O(n)。同理，转换递归时存储结果时是自顶向下的解法，而动态规划就是自底向上的解法。</p><p>典型特征：最优子结构、状态转移方程、边界、重叠子问题。</p><p>核心思想：拆分子问题、记住过往、减少重复计算。</p><p>思路：</p><ul><li><p>穷举分析</p></li><li><p>确认边界</p><ul><li>找出规律，确定最优子结构<ul><li>动态规划问题即是递推问题，当前的决策结果是<code>f(n)</code>，则最有子结构就是要让<code>f(n-k)</code>最优，并且与后面的决策没有关系，能让后面的决策安心使用局部最优解。</li></ul></li><li>写出状态转移方程</li></ul></li></ul><p>题库：LeetCode1277，1504，2327。</p><p> </p><h2 id="滑动窗口算法">滑动窗口算法</h2><p>基本思想：滑动窗口算法（Sliding Window Algorithm）是一种用于处理数组或列表子区间问题的高效技巧。维护一个大小可变或固定的“窗口”在数据结构上滑动，将许多嵌套循环的问题（O(n²)或O(n³)）转化为单循环问题（O(n)），显著降低时间复杂度。</p><p>关键点：窗口表示：左，右指针表示窗口的边界；窗口扩张：右指针移动，扩大窗口，寻找可行解；窗口收缩：左指针移动，缩小窗口，优化可行解；结果更新：在窗口滑动的过程中不断更新最优解。</p><p>题库：LeetCode2348</p><p> </p><h2 id="位运算算法">位运算算法</h2><p>大大提高程序的性能，0/1问题时好用。</p><p>题库：LeetCode78，2749。</p><p> </p><h2 id="模拟">模拟</h2><p>基本思想：完全按照题目的描述或者问题的真实发生过程，一步步地用代码复现出来从而得到答案。</p><p>核心思想：重视还原，过程再现。</p><p>思路：</p><ul><li>提炼规则</li><li>设计数据结构</li><li>分解步骤，模块化</li><li>注意边界</li><li>调试</li></ul><p>特点：思路直观，实现繁琐，考验基本功。</p><p>题库：LeetCode54，3446。</p><p> </p><h2 id="堆算法">堆算法</h2><p>特殊的完全二叉树，可以用一维数组存储。</p><p>堆的更新和维护：</p><p> 入堆push()，时间复杂度<code>O(log n)</code></p><p> 出堆pop()，时间复杂度<code>O(log n)</code></p><p> 访问栈顶top()，时间复杂度<code>O(1)</code></p><p> 建堆，时间复杂度<code>O(nlog n)</code></p><p><em># 即堆中插入n个元素</em></p><p>应用：优先队列。</p><p>题库：LeetCode 1792。</p><p> </p><h2 id="分支限界法">分支限界法</h2><ul><li>分支：将大问题划分为若干子问题，形成解空间树，每个结点代表一个子问题，每条分支表示对子问题的一种约束或决策。</li><li>限界：对每个子问题，计算一个上下界，即它可能取得的最优解的范围，如果某个子问题的最优解范围不可能优于当前已知的最优解，就剪枝（丢弃该子问题）。</li></ul><p>思路：</p><ul><li>定义问题的解空间</li><li>从根结点开始分支，产生子问题</li><li>对每个子问题计算限界</li><li>子问题放入候选结点表（队列/堆等）</li><li>从候选结点表中选择结点展开（搜索策略）</li><li>结点满足约束并且更优就继续分支，不满足就剪枝</li><li>重复直到候选结点表为空或者找到全局最优</li></ul><p>题库：0-1背包问题。</p><p> </p><p> </p><h1 id="结构">结构</h1><h2 id="折半查找树">折半查找树</h2><p>即二叉搜索树，Binary Search Tree，BST</p><p>每个结点最多有两个孩子，对于任一结点<code>node</code>：</p><p>左子树上的所有键小于<code>node-&gt;key</code>，右子树上的所有键大于<code>node-&gt;key</code>。</p><p>若树的高度为<code>h</code>，查找/插入/删除复杂度为O(h)，遍历O(n)。</p><p> </p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><p>包括深度优先遍历（DFS）和广度优先遍历（BFS）</p><p>1、深度优先遍历</p><p>按访问顺序不同，可分为前序遍历，中序遍历，后序遍历。</p><p>（1）前序遍历</p><p>顺序：根 -&gt; 左子树 -&gt; 右子树</p><p>可以用于复制树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><p>顺序：左子树 -&gt; 根 -&gt;右子树</p><p>对于二叉搜索树来说，中序遍历的结果就是升序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><p>顺序：左子树 -&gt; 右子树 -&gt; 根</p><p>删除树节点或者释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、广度优先遍历</p><p>又叫层序遍历，从根节点开始逐层从左到右访问。</p><p>输出层次结构，求出树的高度、最短路径等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//队列，FIFO</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="有向图邻接表">有向图邻接表</h2><p>常用的图存储结构，适合存储稀疏图（顶点多，边少）</p><ul><li>有向图：每条边都有方向，比如<code>u-&gt;v</code>表示从顶点<code>u</code>指向顶点<code>v</code>。</li><li>邻接表：为图中的每个顶点建立一个链表/动态数组，存储从该顶点出发的所有边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>; <span class="comment">// 顶点个数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，1-based</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">adj[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">adj[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> </p><p> </p><h1 id="stl">STL</h1><h2 id="ascii">ASCII</h2><p>小写字母的ASCII码=大写字母的ASCII码+32。</p><p> </p><h2 id="优先队列">优先队列</h2><p>特殊的队列，每个元素都有优先级，最先取出优先级最高的元素，在<code>struct&#123;&#125;;</code>中提前声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，char可以换成自定义的struct</span></span><br><span class="line">priority_queue&lt;<span class="type">char</span>,vector&lt;<span class="type">char</span>&gt;,CompareASCII&gt;pq;</span><br></pre></td></tr></table></figure><p>核心实现：二叉堆（最大堆<code>priority_queue</code>/最小堆），堆顶是最大/最小元素。</p><p> 最大堆：应该重载<code>&lt;</code>运算符，定义了谁的优先级更低，<code>a&lt;b=true</code>，即a的优先级更低。</p><p> 重载运算符：</p><p><em># 一般<code>const</code>修饰，重载运算符不必修改对象，引用传递避免不必要的拷贝，提高效率，返回值必须为bool。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆，栈顶是优先级最小的，最大堆反之用&lt;。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareASCII</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; a,<span class="type">const</span> <span class="type">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 插入：<code>push()</code></p><p> 时间复杂度：插入和删除都是<code>O(log n)</code>。</p><p> </p><h2 id="vector">Vector</h2><p> 在末尾添加一个元素：<code>push_back(数组的一个数据)</code></p><p> 直接在末尾构造对象：<code>emplace_back(构造需要的数据)</code>，和<code>push_back()</code>区别不大，省去一次拷贝。</p><p><em># 二维数组添加一维数组同理</em></p><p> 清空所有元素：<code>clear()</code></p><p> 是否为空矩阵：<code>empty()</code></p><p> </p><h2 id="string">String</h2><p> 获取子字符串：<code>substr(size_t pos,size_t len)</code></p><p><em># <code>pos</code>：子字符串的起始位置，默认0；<code>len</code>：提取的字符数量，默认一直提取到末尾</em></p><p> 将字符串转换为整数：<code>stoi(const string&amp; s,size_t* idx,int base)</code></p><p><em># <code>s</code>：需转换的字符串；<code>idx</code>：可选指针；<code>base</code>：可选的转换的进制</em></p><h2 id="位运算">位运算</h2><p> 计算整数中二进制为1的个数：<code>popcount(T x)</code></p><p><em># <code>T</code>：无符号的整数类型，例如<code>unsigned int</code>，<code>unsigned long</code>，<code>uint64_t</code>等；<code>x</code>：整数</em></p><p> </p><h2 id="模板类pair">模板类<code>&lt;pair&gt;</code></h2><p>定义好的迷你结构体，将两个数据打包成一个整体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    T1 first;   <span class="comment">// 第一个元素</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>T1</code>和<code>T2</code>可以为其他不同类型，例如<code>pair&lt;int,string&gt;</code>，经常用于键值对，函数返回值，构造容器等。</p><p> </p><h2 id="哈希集合">哈希集合</h2><p><code>unordered_set&lt;&gt;</code>，哈希集合。</p><p>特点：不重复，无序，查找快（插入/删除/查找都是O(1)），哈希表底层实现。</p><p> 插入：<code>insert()</code></p><p> 查找：<code>find()</code>，返回的是迭代器，一般配合<code>end()</code>使用进行判断</p><p> 删除：<code>erase()</code></p><p> </p><h2 id="listsetmap">List，Set，Map</h2><table><thead><tr class="header"><th>特性</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr class="odd"><td>顺序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr class="even"><td>可重复</td><td>可以</td><td>不可以</td><td>键不重复</td></tr><tr class="odd"><td>访问方式</td><td>下标索引</td><td>无索引</td><td>key查找</td></tr><tr class="even"><td>用途</td><td>保存序列</td><td>保存唯一元素</td><td>键值对应关系</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2025/08/22/hexo/"/>
    <url>/2025/08/22/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo指令">Hexo指令：</h1><p> 新建博客：<code>hexo new'xxx'</code></p><p> 清除之前所有的公共文件：<code>hexo clean</code></p><p> 重新生成html文件：<code>hexo g</code></p><p> 上传到GitHub：<code>hexo d</code></p><p>==&gt;清除/生成/部署：<code>hexo clean &amp;&amp; hexo g -d</code></p><p> 查看hexo版本：<code>hexo version</code></p><p> </p><h1 id="git指令">Git指令：</h1><p> 测试Github到SSH的连接：<code>ssh -T git@github.com</code></p><p> 测试到Github的网络连接是否通畅：<code>ping github</code></p><p><em># ping命令使用 ICMP 协议，git 命令使用 HTTP/HTTPS 协议。</em></p>]]></content>
    
    
    <categories>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ping</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2025/08/22/markdown/"/>
    <url>/2025/08/22/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法">Markdown语法</h1><h2 id="链接">链接</h2><p>效果：<a href="url">链接文本</a></p><p>格式：<code>[链接文本](url)</code></p><p> </p><h2 id="指数">指数</h2><p>效果：2<sup>n</sup></p><p>格式：<code>2&lt;sup&gt;n&lt;/sup&gt;</code></p><p> </p><h2 id="列表">列表</h2><p>效果：</p><ul><li><p>列表一</p></li><li><p>列表二</p><p>格式：<code>- 列表一</code></p></li></ul><p> </p><h2 id="斜体">斜体</h2><p>效果：<em>斜体</em></p><p>格式：<code>*斜体*</code></p><p> </p><h2 id="公式">公式</h2><p>效果：<span class="math inline"><em>h</em><sub><em>t</em></sub></span></p><p>格式：<code>$h_t$</code></p><p> </p><h2 id="表格">表格</h2><p>效果：</p><table><thead><tr class="header"><th>列A</th><th>列B</th></tr></thead><tbody><tr class="odd"><td></td><td></td></tr></tbody></table><p>格式：<code>|列A|列B|</code></p><p> </p><p> </p><h1 id="latex语法">LaTex语法</h1><h2 id="下标">下标</h2><p>效果：<span class="math inline"><em>h</em><sub><em>t</em></sub></span>，<span class="math inline"><em>h</em><sub><em>t</em><em>t</em></sub></span></p><p>格式：<code>h_t,h_&#123;tt&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2025/08/22/vue/"/>
    <url>/2025/08/22/vue/</url>
    
    <content type="html"><![CDATA[<p>Vue3</p><p>​ 描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。</p><p>​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。</p><p>​ 命令：</p><p><em># 创建Vue项目</em> <code>npm init vue@latest</code></p><p><em># 启动开发服务器</em></p><p><code>npm install</code></p><p><code>npm run dev</code></p><p><em># 打开图形化界面</em></p><p><code>npm install @vue/cli</code></p><p><code>vue ui</code></p><p>Vite</p><p>​ 描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。</p><p>​ 组成：</p><ul><li><p>开发服务器：基于原生ES模块，提供超快的热更新。</p></li><li><p>构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。</p><p>优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2025/08/22/docker/"/>
    <url>/2025/08/22/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><p>描述：开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>优点：跨平台一致性，资源高效，快速部署，隔离性。</p><p>基本命令：</p><p> 查看运行中的容器：<code>docker  ps</code></p><p> 进入容器内部：<code>docker exec -it &lt;容器ID&gt; /bin/bash</code></p><p> 杀死进程：<code>kill -9 项目ID</code></p><p>命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2025/08/22/computerNetworks/"/>
    <url>/2025/08/22/computerNetworks/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip">TCP/IP</h1><h2 id="五层模型">五层模型</h2><p> 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。</p><p> 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。</p><p> 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。</p><p> 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。</p><p> 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。</p><h2 id="http请求过程">HTTP请求过程</h2><p>从浏览器，操作系统，网络设备到服务器共同参与的协作过程。</p><p> 过程：</p><figure><img src="http.png" alt="八个阶段" /><figcaption aria-hidden="true">八个阶段</figcaption></figure><p>1、URL解析</p><p>用户输入，浏览器解析（协议、域名、路径），浏览器检查</p><p>2、DNS域名解析</p><p>浏览器查找顺序（浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; 网络服务供应商的DNS服务器 -&gt; 递归查询），返回IP</p><p>3、建立TCP连接（三次握手）</p><p>浏览器先和服务器建立一条可靠的传输通道，即TCP连接。</p><p>4、发送HTTP请求</p><p>浏览器发送请求报文</p><ul><li>请求行：请求方法，请求的URL路径，HTTP协议版本。<ul><li><code>GET /index.html HTTP/1.1</code></li></ul></li><li>请求头：包含关于客户端和环境的信息的键值对。<ul><li><code>Host: www.example.com</code>（必需，指定域名）</li><li><code>User-Agent</code>（浏览器身份标识），<code>Accept</code>（客户端接收的内容类型）等</li></ul></li><li>请求体：通常只在POST/PUT方法中存在，包含提交给服务器的数据。</li></ul><p>5、服务器处理请求并返回HTTP响应</p><p>服务器收到请求报文后，会进行处理（例如，由Web服务器软件（如Nginx/Apache）处理静态请求，或由应用服务器（如Tomcat/Node.js）处理动态请求），然后返回一个HTTP响应报文。</p><p>服务器发送响应报文</p><ul><li>状态行：HTTP协议版本、状态码和状态消息。<ul><li><code>HTTP/1.1 200 OK</code>，<code>HTTP/1.1 404 Not Found</code>，<code>HTTP/1.1 500 Internal Server Error</code></li></ul></li><li>响应头：包含关于服务器和响应主体的信息，键值对。<ul><li><code>Content-Type</code>，<code>Content-Length</code>，<code>Set-Cookie</code></li></ul></li><li>响应体：请求的真正资源内容，HTML文档、图片数据等。</li></ul><p>6、浏览器解析渲染页面</p><p>浏览器收到响应后，会根据响应头中的 <code>Content-Type</code>来决定如何处理响应体。</p><p>生成DOM树，CSSOM树，合并构建渲染树，布局，绘制。</p><p>7、连接结束（四次握手）</p><p>HTTP是一种无状态协议，默认完成请求就会关闭连接。</p><p>8、后续交互</p><p>一个完整的页面通常需要加载很多资源（CSS, JS, 图片等）。对于HTTP/1.1，浏览器会对同一个域名建立多个TCP连接（通常是6-8个）来并行下载这些资源，以加快速度。HTTP/2则允许在一个TCP连接上进行多路复用，效率更高。</p><p> </p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><table><thead><tr class="header"><th>特性</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr class="odd"><td>连接性</td><td>面向连接<br>建立连接三次握手，释放连接四次握手。</td><td>无连接的<br>直接发送数据。</td></tr><tr class="even"><td>可靠性</td><td>高<br>通过确认，重传，校验，流量控制，拥塞控制等手段确保数据无差错，不丢失等。</td><td>低<br>不提供任何可靠机制，不确认是否收到，可能丢失，乱序或重复。</td></tr><tr class="odd"><td>数据形式</td><td>面向字节流<br>无结构，无边界，应用程序自己处理粘包/拆包问题。</td><td>面向数据包<br>独立，有边界，一次发送就是一个完整报文。</td></tr><tr class="even"><td>速度和开销</td><td>速度慢，开销大<br>各种机制增加开销，减慢速度。</td><td>速度快，开销小<br>延迟极低，传输效率高。</td></tr><tr class="odd"><td>传输模式</td><td>全双工<br>连接双方可以同时发送和接收数据。</td><td>支持单播，多播，广播。</td></tr><tr class="even"><td>应用场景</td><td>网页浏览（HTTP/HTPPS）<br>文件传输（FTP）<br>电子邮件（SMTP，IMAP）<br>远程登陆（SSH）</td><td>视频流媒体，语音通话<br>在线游戏<br>DNS查询<br>TFTP（简单文件传输）<br>广播/多播</td></tr></tbody></table><p> </p><p> </p><p>LocalStorage和SessionStorage的区别</p><figure><img src="LocalStorage.png" alt="LocalStorage.png" /><figcaption aria-hidden="true">LocalStorage.png</figcaption></figure><p>LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。</p><p> </p><p> </p><p>WebSocket</p><p>在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。</p><p>HTTP：无状态，单向请求-响应模式===&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。</p><p>WebRTC</p><p>虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN/TURN服务器。</p><p>信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
