<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>下载电影相关资源教程</title>
    <link href="/video/"/>
    <url>/video/</url>
    
    <content type="html"><![CDATA[<h2 id="下载qbittorrent">1、下载qBittorrent</h2><p>先去下载qBittorrent，在选项中设定tracker服务器列表。</p><blockquote><p>必须要在同一个tracker服务器才能互相传输文件，一般种子文件会自带几个tracker服务器，添加了可以下载种子。</p></blockquote><figure><img src="1.png" alt="设定选项" /><figcaption aria-hidden="true">设定选项</figcaption></figure><p>tracker列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line">http://1337.abcvg.info:80/announce</span><br><span class="line"></span><br><span class="line">http://207.241.226.111:6969/announce</span><br><span class="line"></span><br><span class="line">http://207.241.231.226:6969/announce</span><br><span class="line"></span><br><span class="line">http://[2a04:ac00:1:3dd8::1:2710]:2710/announce</span><br><span class="line"></span><br><span class="line">http://aboutbeautifulgallopinghorsesinthegreenpasture.online:80/announce</span><br><span class="line"></span><br><span class="line">http://bittorrent-tracker.e-n-c-r-y-p-t.net:1337/announce</span><br><span class="line"></span><br><span class="line">http://bt.okmp3.ru:2710/announce</span><br><span class="line"></span><br><span class="line">http://bt.rer.lol:2710/announce</span><br><span class="line"></span><br><span class="line">http://bvarf.tracker.sh:2086/announce</span><br><span class="line"></span><br><span class="line">http://echostar.ddnsfree.com:8080/announce</span><br><span class="line"></span><br><span class="line">http://extracker.dahrkael.net:6969/announce</span><br><span class="line"></span><br><span class="line">http://ipv4.rer.lol:2710/announce</span><br><span class="line"></span><br><span class="line">http://ipv4announce.sktorrent.eu:6969/announce</span><br><span class="line"></span><br><span class="line">http://ipv6.rer.lol:6969/announce</span><br><span class="line"></span><br><span class="line">http://lucke.fenesisu.moe:6969/announce</span><br><span class="line"></span><br><span class="line">http://nyaa.tracker.wf:7777/announce</span><br><span class="line"></span><br><span class="line">http://open.tracker.cl:1337/announce</span><br><span class="line"></span><br><span class="line">http://p4p.arenabg.com:1337/announce</span><br><span class="line"></span><br><span class="line">http://retracker.hotplug.ru:2710/announce</span><br><span class="line"></span><br><span class="line">http://t.overflow.biz:6969/announce</span><br><span class="line"></span><br><span class="line">http://tk.greedland.net:80/announce</span><br><span class="line"></span><br><span class="line">http://torrentsmd.com:8080/announce</span><br><span class="line"></span><br><span class="line">http://tr.highstar.shop:80/announce</span><br><span class="line"></span><br><span class="line">http://tr.nyacat.pw:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker-zhuqiy.dgj055.icu:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker.23794.top:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.beeimg.com:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.bt4g.com:2095/announce</span><br><span class="line"></span><br><span class="line">http://tracker.cutie.dating:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker.dhitechnical.com:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.dler.com:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.dler.org:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.ghostchu-services.top:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker.internetwarriors.net:1337/announce</span><br><span class="line"></span><br><span class="line">http://tracker.ipv6tracker.ru:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker.mywaifu.best:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.qu.ax:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.renfei.net:8080/announce</span><br><span class="line"></span><br><span class="line">http://tracker.tricitytorrents.com:2710/announce</span><br><span class="line"></span><br><span class="line">http://tracker.tritan.gg:8080/announce</span><br><span class="line"></span><br><span class="line">http://tracker.waaa.moe:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.wepzone.net:6969/announce</span><br><span class="line"></span><br><span class="line">http://tracker.zhuqiy.com:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker2.dler.org:80/announce</span><br><span class="line"></span><br><span class="line">http://tracker2.itzmx.com:6961/announce</span><br><span class="line"></span><br><span class="line">http://wepzone.net:6969/announce</span><br><span class="line"></span><br><span class="line">http://www.all4nothin.net:80/announce.php</span><br><span class="line"></span><br><span class="line">http://www.wareztorrent.com:80/announce</span><br><span class="line"></span><br><span class="line">https://1337.abcvg.info:443/announce</span><br><span class="line"></span><br><span class="line">https://cny.fan:443/announce</span><br><span class="line"></span><br><span class="line">https://shahidrazi.online:443/announce</span><br><span class="line"></span><br><span class="line">https://t.213891.xyz:443/announce</span><br><span class="line"></span><br><span class="line">https://torrent.tracker.durukanbal.com:443/announce</span><br><span class="line"></span><br><span class="line">https://tr.abiir.top:443/announce</span><br><span class="line"></span><br><span class="line">https://tr.abir.ga:443/announce</span><br><span class="line"></span><br><span class="line">https://tr.nyacat.pw:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.alaskantf.com:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.bt4g.com:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.foreverpirates.co:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.gcrenwp.top:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.ghostchu-services.top:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.iochimari.moe:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.kuroy.me:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.leechshield.link:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.moeblog.cn:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.moeking.me:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.pmman.tech:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.qingwa.pro:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.uraniumhexafluori.de:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker.zhuqiy.com:443/announce</span><br><span class="line"></span><br><span class="line">https://tracker1.520.jp:443/announce</span><br><span class="line"></span><br><span class="line">udp://207.241.226.111:6969/announce</span><br><span class="line"></span><br><span class="line">udp://207.241.231.226:6969/announce</span><br><span class="line"></span><br><span class="line">udp://52.58.128.163:6969/announce</span><br><span class="line"></span><br><span class="line">udp://6ahddutb1ucc3cp.ru:6969/announce</span><br><span class="line"></span><br><span class="line">udp://89.110.76.229:6969/announce</span><br><span class="line"></span><br><span class="line">udp://[2a03:7220:8083:cd00::1]:451/announce</span><br><span class="line"></span><br><span class="line">udp://[2a04:ac00:1:3dd8::1:2710]:2710/announce</span><br><span class="line"></span><br><span class="line">udp://[2a0f:e586:f:f::81]:6969/announce</span><br><span class="line"></span><br><span class="line">udp://admin.52ywp.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://anna.bt.bontal.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://bittorrent-tracker.e-n-c-r-y-p-t.net:1337/announce</span><br><span class="line"></span><br><span class="line">udp://bt.rer.lol:6969/announce</span><br><span class="line"></span><br><span class="line">udp://burmese.app:6969/announce</span><br><span class="line"></span><br><span class="line">udp://concen.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://d40969.acod.regrucolo.ru:6969/announce</span><br><span class="line"></span><br><span class="line">udp://exodus.desync.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://extracker.dahrkael.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://ipv4announce.sktorrent.eu:6969/announce</span><br><span class="line"></span><br><span class="line">udp://leet-tracker.moe:1337/announce</span><br><span class="line"></span><br><span class="line">udp://martin-gebhardt.eu:25/announce</span><br><span class="line"></span><br><span class="line">udp://node01.trackerstatus.live:42069/announce</span><br><span class="line"></span><br><span class="line">udp://node02.torrentonline.cc:42069/announce</span><br><span class="line"></span><br><span class="line">udp://ns575949.ip-51-222-82.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://open-tracker.demonoid.ch:6969/announce</span><br><span class="line"></span><br><span class="line">udp://open.demonii.com:1337/announce</span><br><span class="line"></span><br><span class="line">udp://open.demonoid.ch:6969/announce</span><br><span class="line"></span><br><span class="line">udp://open.stealth.si:80/announce</span><br><span class="line"></span><br><span class="line">udp://open.tracker.cl:1337/announce</span><br><span class="line"></span><br><span class="line">udp://opentor.org:2710/announce</span><br><span class="line"></span><br><span class="line">udp://opentracker.io:6969/announce</span><br><span class="line"></span><br><span class="line">udp://p4p.arenabg.com:1337/announce</span><br><span class="line"></span><br><span class="line">udp://public.demonoid.ch:6969/announce</span><br><span class="line"></span><br><span class="line">udp://retracker.hotplug.ru:2710/announce</span><br><span class="line"></span><br><span class="line">udp://retracker.lanta.me:2710/announce</span><br><span class="line"></span><br><span class="line">udp://retracker01-msk-virt.corbina.net:80/announce</span><br><span class="line"></span><br><span class="line">udp://run.publictracker.xyz:6969/announce</span><br><span class="line"></span><br><span class="line">udp://t.overflow.biz:6969/announce</span><br><span class="line"></span><br><span class="line">udp://torrentclub.online:54123/announce</span><br><span class="line"></span><br><span class="line">udp://tr4ck3r.duckdns.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker-de-2.cutie.dating:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.0x7c0.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.1h.is:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.bittor.pw:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.breizh.pm:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.cloudbase.store:1333/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.cyberia.is:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.dler.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.dler.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.ducks.party:1984/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.filemail.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.flatuslifir.is:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.fnix.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.gmi.gd:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.hifimarket.in:2710/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.iperson.xyz:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.opentorrent.top:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.opentrackr.org:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.playground.ru:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.plx.im:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.qu.ax:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.rescuecrew7.com:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.skillindia.site:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.skynetcloud.site:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.skyts.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.srv00.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.startwork.cv:1337/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.t-1.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.therarbg.to:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.torrent.eu.org:451/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.torrust-demo.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.tryhackx.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.tvunderground.org.ru:3218/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.waaa.moe:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker.zupix.online:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker1.t-1.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker2.dler.org:80/announce</span><br><span class="line"></span><br><span class="line">udp://tracker2.itzmx.com:6961/announce</span><br><span class="line"></span><br><span class="line">udp://tracker3.itzmx.com:6961/announce</span><br><span class="line"></span><br><span class="line">udp://tracker3.t-1.org:6969/announce</span><br><span class="line"></span><br><span class="line">udp://tracker4.itzmx.com:2710/announce</span><br><span class="line"></span><br><span class="line">udp://udp.tracker.projectk.org:23333/announce</span><br><span class="line"></span><br><span class="line">udp://v74853.hosted-by-vdsina.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://wepzone.net:6969/announce</span><br><span class="line"></span><br><span class="line">udp://www.2600.com:6969/announce</span><br><span class="line"></span><br><span class="line">udp://www.torrent.eu.org:451/announce</span><br><span class="line"></span><br><span class="line">udp://yuki.bt.bontal.net:6969/announce</span><br><span class="line"></span><br><span class="line">wss://tracker.openwebtorrent.com:443/announce</span><br></pre></td></tr></table></figure><p> </p><h2id="利用网站查找种子资源和字幕资源">2、利用网站查找种子资源和字幕资源</h2><p>种子资源网站</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://thepiratebay.org/index.html</span><br></pre></td></tr></table></figure><p>字幕资源网站</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zimuku.org/?ref=yinghe.one</span><br></pre></td></tr></table></figure><p>下载资源到本地后在qBittorrent中即可删除这个种子。</p><p> </p><h2 id="整合">3、整合</h2><p>将字幕和流媒体源命同一个名字，放在一个文件夹下，用网盘或者VLC打开观看即可。</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
      <category>资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computerNetworks</tag>
      
      <tag>torrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/linux/"/>
    <url>/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="linux">Linux</h1><p>常用命令：</p><p>列出当前目录下文件：<code>ls</code></p><blockquote><p>后面也可接目录</p></blockquote><p><code>tar</code>解压：<code>tar -xzvf *.tar.gz -C /xxx</code></p><blockquote><p><code>x</code>：解压；<code>z</code>：处理<code>.gz</code>格式；<code>v</code>：显示解压过程；<code>f</code>：指定解压的文件名；<code>C</code>：解压的目录。</p></blockquote><p>以管理员的权限执行后面的命令：<code>sudo xxx</code></p><ul><li><p>重启：<code>sudo reboot</code></p></li><li><p>运行当前目录下脚本：<code>sudo ./xxx.pl</code></p></li><li><p>更新软件源列表：<code>sudo apt update</code></p><blockquote><p>只是更新，并不安装</p></blockquote></li><li><p>安装软件源：<code>sudo apt install</code></p></li></ul><blockquote><p>包括其他更新/安装…都可以采用<code>sudo</code></p></blockquote><p>检查网络接口，网卡是否工作：<code>ip a</code></p><p>检查网络连通：<code>ping xxx</code></p><blockquote><p><code>c</code>：发送ping包的次数</p><p>可用于测试域名/IP/局域网设备</p></blockquote><p>查看当前操作系统的内核版本：<code>uname -r</code></p><p>用<code>vim</code>编辑器打开文件：<code>vim</code></p><ul><li>打开内核源码的<code>syscalss.h</code>：<code>vim include/linux/syscalls.h</code></li><li>进入插入模式：按<code>i</code>键</li><li>退出模式：按<code>ESC</code>键</li><li>进入命令模式：按<code>:</code>键，保存并退出：<code>:wq</code></li><li>撤销：按<code>u</code>键</li><li>搜索匹配：<code>/xxx</code>，向后查找：<code>n</code>，向前查找：<code>N</code></li></ul><p>彻底清除内核源码：<code>make mrproper</code></p><blockquote><p>回到刚刚下载的源码</p></blockquote><p>配置内核选项：<code>make menuconfig</code></p><p>并行编译内核（N个线程）：<code>make -jN</code></p><p>安装模块：<code>make modules_install</code></p><p>安装内核：<code>make install</code></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Koishi和Onebot在本机Docker上部署自己的群聊机器人</title>
    <link href="/koishiBot/"/>
    <url>/koishiBot/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><p>下载并成功运行Docker。</p><p> </p><h1 id="开始">开始</h1><h2id="拉取镜像koishijskoishi和initialencounterllonebot到本地">1、拉取镜像<code>koishijs/koishi</code>和<code>initialencounter/llonebot</code>到本地</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull koishijs/koishi</span><br><span class="line">docker pull initialencounter/llonebot</span><br></pre></td></tr></table></figure><h2 id="创建docker网络">2、创建Docker网络</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create netName</span><br></pre></td></tr></table></figure><h2 id="创建容器并连接网络">3、创建容器并连接网络</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> koishiContainer <span class="literal">--network</span> netName <span class="literal">-p</span> <span class="number">5140</span>:<span class="number">5140</span> koishijs/koishi</span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> llonebotContainer <span class="literal">--network</span> netName <span class="literal">-p</span> <span class="number">3080</span>:<span class="number">3080</span> initialencounter/llonebot</span><br></pre></td></tr></table></figure><h2 id="测试是否联通">4、测试是否联通</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> koishiContainer ping llonebotContainer</span><br></pre></td></tr></table></figure><h2 id="登录koishi和onebot">5、登录Koishi和onebot</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5140</span>/</span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3080</span>/</span><br></pre></td></tr></table></figure><h2 id="在onebot中配置适配器">6、在onebot中配置适配器</h2><figure><img src="1.png" alt="启用ws正向适配器" /><figcaption aria-hidden="true">启用ws正向适配器</figcaption></figure><p>Token随便设置，和koishi中保持一致。</p><figure><img src="2.png" alt="启用ws反向适配器" /><figcaption aria-hidden="true">启用ws反向适配器</figcaption></figure><p>我两个都打开了，虽然后面连接只用了正向。</p><figure><img src="3.png" alt="效果" /><figcaption aria-hidden="true">效果</figcaption></figure><h2 id="在koishi中配置插件">7、在koishi中配置插件</h2><figure><img src="4.png" alt="在插件市场中搜索adapter-onebot" /><figcaptionaria-hidden="true">在插件市场中搜索adapter-onebot</figcaption></figure><p>添加后再返回“插件市场”中点“修改”-“配置”，跳转到“插件配置”中启用此插件。</p><figure><img src="5.png" alt="adapter-onebot中配置" /><figcaption aria-hidden="true">adapter-onebot中配置</figcaption></figure><p>selfId填写自己的机器人账号，token和上面保持一致，protocol使用ws，endpoint为<code>ws://llonebotContainer(你的onebot容器名):3001/</code>。</p><figure><img src="6.png" alt="最后运行日志为连接代表连接成功" /><figcaptionaria-hidden="true">最后运行日志为连接代表连接成功</figcaption></figure><p> </p><h1 id="测试">测试</h1><p>给机器人发送<code>help</code>，测试。</p><blockquote><p>如果有问题可以更新一下koishi其他插件，在“依赖管理”中，点右上角小火箭一键更新。</p></blockquote><p>额外的：</p><p>推荐插件<code>chatluna</code>，机器人其他功能（聊天、语言、图片…），以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Koishi</tag>
      
      <tag>Onebot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/springBoot/"/>
    <url>/springBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot">SpringBoot</h1><figure><img src="intro.png" alt="介绍" /><figcaption aria-hidden="true">介绍</figcaption></figure><p>SpringBoot是一个Spring模块，提供了RAD(快速应用程序开发)功能。它用于创建独立的基于Spring的应用程序，需要最少的Spring配置就可以运行。</p><p>即Spring框架和嵌入式服务器的组合。</p><blockquote><p>自动配置了 Web 服务、JSON 转换、Tomcat 服务器等，不用手动配置XML。</p><p>即自带内嵌Tomcat的Java程序，运行后监听<code>localhost:8080</code></p></blockquote><p> </p><h1 id="结构">结构</h1><table><thead><tr><th style="text-align: center;">层</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr><td style="text-align: center;"><code>@SpringBootApplication</code></td><td style="text-align: center;">主类，入口</td></tr><tr><td style="text-align: center;">config</td><tdstyle="text-align: center;">配置类，用于全局配置，在启动时加载，注册拦截器等。</td></tr><tr><tdstyle="text-align: center;">controller<br>filter<br>interceptor<br>exception</td><tdstyle="text-align: center;">控制层，接受前端请求，并调用服务层。<br>过滤器，来自Servlet，作用整个Servlet层。<br>拦截器，来自SpringMVC，控制层的横切，请求到达之前/之后的公共逻辑。<br>异常层，控制层的横切，控制异常。</td></tr><tr><td style="text-align: center;">service</td><tdstyle="text-align: center;">服务层，处理业务逻辑，并调用持久层。</td></tr><tr><td style="text-align: center;">repository</td><td style="text-align: center;">持久层，操作数据库。</td></tr><tr><td style="text-align: center;">model</td><td style="text-align: center;">实体层，映射数据库表。</td></tr><tr><td style="text-align: center;">common</td><tdstyle="text-align: center;">通用层，可以封装前后端接口等，被所有曾通用</td></tr></tbody></table><p> </p><p> </p><h1 id="注解">注解</h1><h2 id="component"><code>@Component</code></h2><p>作用：在组件扫描时，带有<code>@Component</code>及其衍生注解的类会被注册为Bean，通用组件，任何需要托管的类都可以用这个组件。</p><p>衍生注解：</p><ul><li><code>@Service</code>：服务层，处理业务逻辑。</li><li><code>@Repository</code>：持久层，处理数据库操作。</li><li><code>@Controller</code>：控制层，处理Web请求。</li><li><code>@Configuration</code>：配置类，注册Bean，有动态代理增强。</li></ul><p>用法：注解在类上。</p><h3 id="configuration"><code>@Configuration</code></h3><p>作用：配置类功能，可以用来定义<code>Bean</code>，相当于XML文件，允许在其下使用<code>@Bean</code>的注解来注册Bean到Spring容器。</p><blockquote><p>本质也是个特殊的<code>@Component</code>，会被组件扫描，会启用动态代理增强机制，保证多个<code>@Bean</code>之间安全相互调用，返回的是同一个Bean实例。</p></blockquote><p>用法：注解在类上。</p><p> </p><h2 id="componentscan"><code>@ComponentScan</code></h2><p>作用：组件扫描功能，注册标注了<code>@Component</code>等注解的类为Bean。</p><blockquote><p>扫描范围默认为当前包及其子包的所有组件。</p></blockquote><p>用法：注解在类上。</p><p> </p><h2 id="autowired"><code>@Autowired</code></h2><p>作用：用于将Spring容器内的某个Bean自动注入到另一个类的字段/构造器/方法。</p><blockquote><p>自动注入是IOC（控制反转）的一部分，减少耦合，由Spring容器管理依赖关系。</p><p>如果是构造函数注入的话不需要<code>@Autowired</code>，Spring容器会自动注入。</p></blockquote><p>用法：</p><ul><li>注解在字段上；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;  <span class="comment">// 自动注入Spring容器内的UserRepository类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注解在Setter方法上</li></ul><h3 id="qualifier"><code>@Qualifier</code></h3><p>作用：自动注入有多个类型匹配的Bean时，明确指定注入哪个Bean。</p><p>用法：和<code>@Autowired</code>一起注解。</p><p> </p><h2 id="控制类">控制类</h2><h3 id="requestmapping"><code>@RequestMapping</code></h3><p>作用：请求映射功能，可以映射URL路径。</p><p>用法：注解在类上或者方法上。</p><p>属性：</p><ul><li><code>value</code>：指定URL路径（可省略）</li><li><code>method</code>：指定HTTP方法（GET，POST等）</li><li><code>params</code>：限制请求必须包含/不包含哪些参数</li></ul><p>衍生注解：</p><ul><li><code>@GetMapping("/path")</code>等价于<code>@RequestMapping(value="/path", method=RequestMethod.GET)</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code>：通常包含请求体，请求更新的资源。</li><li><code>@DeleteMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span>  <span class="comment">// 公共前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-list&quot;</span>; <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-created&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="pathvariable"><code>@PathVariable</code></h3><p>作用：从请求的URL路径中提取参数值，传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><blockquote><p>如果有多个时，如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;userId&#125;/posts/&#123;postId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPostByUser</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, <span class="meta">@PathVariable(&quot;postId&quot;)</span> Long postId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User ID: &quot;</span> + userId + <span class="string">&quot;, Post ID: &quot;</span> + postId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> </p><h3 id="requestparam"><code>@RequestParam</code></h3><p>作用：从请求的URL查询字符串中提取参数（<code>?key=value</code>），传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> String name,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> <span class="type">int</span> age</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// name = &quot;Tom&quot;, age = 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Searched for &quot;</span> + name + <span class="string">&quot;, age &quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li><p><code>value/name</code>：指定查询字符串的参数名。</p></li><li><p><code>required</code>：是否必须提供。</p></li></ul><blockquote><p>true（默认）</p></blockquote><ul><li><code>defaultValue</code>：参数缺失时的默认值。</li></ul><p> </p><h3 id="requestbody"><code>@RequestBody</code></h3><p>作用：接收客户端发送的JSON数据并转化为对象。</p><p>用法：注解在形参上。</p><p> </p><h3 id="responsebody"><code>@ResponseBody</code></h3><p>作用：方法的返回值会直接写入HTTP响应体，返回JSON或XML数据。</p><p>用法：注解在方法上。</p><blockquote><p>在带有<code>@Controller</code>或组合注解标记的类下，对带有<code>@RequestMapping</code>及其衍生注解（如<code>@GetMapping</code>、<code>@PostMapping</code>等）的请求处理方法起作用。</p><p>不过一半可以直接<code>@RestController</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 直接返回字符串内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="异常类">异常类</h2><h3 id="controlleradvice"><code>@ControllerAdvice</code></h3><p>作用：让该类能拦截并处理全局 Controller层的异常，当项目中任意一个控制类抛出异常时，Spring会自动把异常传递到这里匹配对应的 <code>@ExceptionHandler</code>。</p><p>用法：注解在类上。</p><p><code>@ExceptionHandler</code></p><p>作用：当抛出特定类型的异常时，匹配这个方法。</p><p>用法：注解在方法上。</p><p> </p><h2 id="实体类">实体类</h2><h3 id="entity"><code>@Entity</code></h3><p>作用：JPA库中，标记当前类是一个实体类，对应数据库中的一张表，类下的字段对应表中的列。</p><p>用法：注解在类上。</p><p><strong><code>@ID</code></strong></p><p>作用：标识实体类的主键字段。</p><p>用法：注解在字段上。</p><p><strong><code>@GeneratedValue</code></strong></p><p>作用：搭配<code>@ID</code>，指定主键的生成策略。</p><p>属性：</p><ul><li><code>strategy</code></li></ul><blockquote><p>GenerationType.IDENTITY：使用数据库的自增长策略来生成主键值。</p></blockquote><p>用法：注解在字段上。</p><p> </p><h3 id="jsonidentityinfo"><code>@JsonIdentityInfo</code></h3><p>作用：避免双向关系导致的无限递归，在序列化时，如果一个对象已经被序列化过了，就只输出它的标识属性。</p><p>用法：注解在类上。</p><p>属性：</p><ul><li><p><code>generator</code>：指定如何生成对象的唯一标识。</p><blockquote><p><code>ObjectIdGenerators.PropertyGenerator.class</code></p></blockquote></li><li><p><code>property</code>：指定哪个字段作为唯一标识，一般是<code>id</code>。</p></li></ul><p> </p><h3 id="onetomany"><code>@OneToMany</code></h3><p>作用：表示一对多的关系，多的将会在数据库中添加一个外键用来指向一的键。</p><p>用法：注解在字段上。</p><p>属性：</p><ul><li><p><code>mappedBy</code>：表示这一方不是维护关系的一方，没有外键。</p><blockquote><p>通常就是这个类。</p></blockquote></li><li><p><code>cascade</code>：级联操作，对一做数据库操作时会传递到多的数据库中。</p><blockquote><p><code>CascadeType.ALL</code></p></blockquote></li><li><p><code>orphanRemoval</code>：是否移除多的一方的孤儿对象。</p><blockquote><p><code>true</code>时表示移除孤儿对象。</p></blockquote><p>例如：<code>owner类中的pets字段</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany(mappedBy = &quot;owner&quot;, cascade = CascadeType.ALL)</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;Pet&gt; pets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>@ManyToOne</code></strong></p><p>作用：表示多对一的关系。</p><p>用法：注解在字段上。</p><p><strong><code>@JoinColumn</code></strong></p><p>作用：指定外键列。</p><p>用法：注解在字段上。</p><p>属性：</p><ul><li><code>name</code>：生成外键列的名字。</li></ul><p> </p><h2 id="通用类">通用类</h2><h3 id="data"><code>@Data</code></h3><p>作用：Lombok库，包括<code>@Getter</code>，<code>@Setter</code>，<code>@ToString</code>，<code>@EqualsAndHashCode</code>，<code>@RequiredArgsConstructor</code>方法。</p><p>用法：注解在类上。</p><p><code>@NoArgsConstructor</code>和<code>@AllArgsConstructor</code>也是Lombok库中，可以自动生成无参构造和全参构造。</p><p> </p><h3id="enableautoconfiguration"><code>@EnableAutoConfiguration</code></h3><p>作用：自动配置功能，会根据所添加的依赖如<code>spring-boot-starter-web</code>，<code>spring-boot-starter-data-jpa</code>等），自动配置好相应的组件，无需手写配置。</p><p>用法：注解在类上。</p><p> </p><h2 id="组合注解">组合注解</h2><h3 id="springbootapplication"><code>@SpringBootApplication</code></h3><p>描述：组合注解，主类入口，包含了<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p><p>用法：注解在类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(StudentApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>SpringApplication.run</code>会启动内置的Tomcat服务器；扫描整个项目；自动注册<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>等组件，运行时在本地监听<code>8080</code>端口。</p></blockquote><p> </p><h3 id="restcontroller"><code>@RestController</code></h3><p>描述：包含了<code>@Controller</code>和<code>@ResponseBody</code>。</p><p>用法：注解在类上。</p><p> </p><h3 id="restcontrolleradvice"><code>@RestControllerAdvice</code></h3><p>描述：包含了<code>@ControllerAdvice</code>和<code>@ResponseBody</code>。</p><p>用法：注解在类上。</p><p> </p><h1 id="配置文件">配置文件</h1><p>作用：设置应用的全局属性和行为</p><h2 id="server"><code>server</code></h2><p><code>port</code>：设置服务器端口。</p><blockquote><p><code>8080</code></p></blockquote><p> </p><h2 id="spring"><code>spring</code></h2><h3 id="application"><code>application</code></h3><p><code>name</code>：设置应用名称。</p><h3 id="datasource"><code>datasource</code></h3><ul><li><code>url</code>：指定连接到Mysql数据库的地址和端口。</li></ul><blockquote><p><code>jdbc:mysql://localhost:3306/数据库名</code>：默认。</p></blockquote><ul><li><code>driver-class-name</code>：JDBC驱动程序的类名。</li></ul><blockquote><p><code>com.mysql.cj.jdbc.Driver</code></p></blockquote><ul><li><code>name</code></li><li><code>password</code></li></ul><h3 id="jpa"><code>jpa</code></h3><p><code>hibernate.ddl-auto</code>：控制 Hibernate在启动时对数据库表结构的自动更新行为。</p><blockquote><p><code>update</code>：如果有新的实体类或字段，Hibernate会自动尝试更新数据库表结构，使其与实体类匹配。</p><p><code>create</code>：每次启动应用时都会删除现有的数据库表，并根据实体类重新创建表格。</p></blockquote><p><code>show-sql</code>：用于开启在控制台显示执行的 SQL 语句。</p><blockquote><p><code>true</code>：开启。</p></blockquote><p> </p><p> </p><h1 id="依赖">依赖</h1><h2id="spring-boot-starter-web"><code>spring-boot-starter-web</code></h2><p>作用：集成了Web相关的所有常用依赖的启动器。</p><p>内容：</p><ul><li>Spring Web；</li><li>Jackson：用于处理JSON的转换；</li><li>Tomcat：默认嵌入式容器。</li></ul><p> </p><h2id="spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></h2><p>作用：集成了 Spring Data JPA 提供的 Repository模式，能够通过接口操作数据库，无需手动编写实现类。</p><p>内容：</p><ul><li>Spring Data JPA：提供接口减少数据库操作；</li><li>Hibernate：映射数据库中的表和Java对象的关系；</li></ul><p> </p><h1 id="bean方法"><code>Bean</code>方法</h1><blockquote><p>非核心配置Bean要用<code>Autowired</code>注入前，需要在配置类中提前配置。</p></blockquote><h2 id="核心配置">核心配置</h2><h3 id="addinterceptors"><code>addInterceptors()</code></h3><p><code>void addInterceptors(InterceptorRegistry registry)</code></p><p>作用：用于注册拦截器。</p><p>方法：</p><ul><li><code>registry.addInterceptor(自定义的拦截器)</code>：添加哪些拦截器。</li><li><code>registry.addPathPatterns("/path")</code>：拦截哪些路径。</li></ul><p> </p><h3 id="securityfilterchain"><code>SecurityFilterChain</code></h3><p>作用：定义 HTTP安全策略，即哪些URL需要认证；添加自定义过滤器，检查Token，返回过滤器链。</p><blockquote><p>在这里实现登录Token认证之后，最好再加保存到浏览器中，例如<code>HttpOnly Cookie</code>。</p></blockquote><p> </p><h3 id="authenticationmanager"><code>authenticationManager</code></h3><p>作用：提供 SpringSecurity的核心认证管理器，处理身份验证。</p><p> </p><h2 id="过滤器">过滤器</h2><h3 id="onceperrequestfilter"><code>OncePerRequestFilter</code></h3><p>作用：Spring 提供的基类，保证每个请求只执行一次过滤。</p><p> </p><h2 id="拦截器">拦截器</h2><h3 id="prehandle"><code>preHandle()</code></h3><p><code>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code></p><p>作用：在请求到达Controller前执行，如果返回<code>false</code>，请求会被终止，不会进入后续的 Controller 或<code>postHandle()</code>、<code>afterCompletion()</code> 方法。</p><p>方法：</p><ul><li><code>request.getMethod()</code>：返回请求方法（Get/Post）。</li><li><code>getRequestURI()</code>：返回请求路径。</li></ul><p> </p><p> </p><h2 id="服务层">服务层</h2><h3 id="passencoder"><code>PassEncoder</code></h3><p>作用：SpringSecurity提供的密码加密器，用于对用户密码进行安全加密和验证。</p><p>方法：</p><ul><li><code>String encode(rawPassword)</code>：把用户输入的明文密码加密成一段不可逆的哈希字符串。</li><li><code>boolean matches(rawPassword, encodedPassword)</code>：验证明文密码是否与数据库中的加密密码匹配。</li></ul><p> </p><h2 id="util层"><code>Util</code>层</h2><h3 id="jwtutil"><code>JwtUtil</code></h3><p>作用：可以生成、解析和验证token，封装用户信息，过期时间等，作为无状态的登录凭证。</p><blockquote><p>注意生成/解析Token时使用<code>Key</code>对象，老版本的字符串密钥不兼容。</p></blockquote><p>使用</p><p> </p><h2 id="持久层">持久层</h2><h3 id="crudrepository"><code>CrudRepository</code></h3><p>方法：</p><ul><li><p><code>Iterable&lt;T&gt; findAll()</code>：表示查询结果的集合。</p><blockquote><p>可以直接转化为<code>List&lt;S&gt;</code>返回。</p></blockquote></li><li><p><code>Page&lt;T&gt; findAll(Pageable pageable)</code>：分页查询。</p><blockquote><p><code>Page</code>有以下属性：<code>getSize()</code>：每页大小；<code>getNumber()</code>：当前页索引。<code>Pageable</code>可以由<code>PageRequest.of(page, size)</code>来构造。</p></blockquote></li><li><p><code>T save(T entity)</code>：根据实体是否有ID来执行插入或者更新操作，返回保存后的实体对象。</p></li><li><p><code>Optional&lt;T&gt; findById(id)</code>：从数据库中查询<code>id</code>的实体，并返回<code>Optional</code>类，可以存储一个实体，也可以表示没有值。</p><blockquote><p>配合<code>orElseThrow()</code>，<code>Optional</code>的方法，如果有值则会返回值，无值则为抛出异常，例如可以配合Lambda表达式<code>() -&gt; new RuntimeException("xxx not found")</code>。</p><p><code>findByNameContaining()</code>，<code>Containing</code>关键字可以实现按照模糊名查找。</p></blockquote></li><li><p><code>void delete(T entity)</code>：根据实体删除。</p><blockquote><p><code>void deleteById(ID id)</code>可以根据<code>id</code>删除。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot问题</title>
    <link href="/springBootBug/"/>
    <url>/springBootBug/</url>
    
    <content type="html"><![CDATA[<h1 id="运行问题">运行问题</h1><p>启动新的SpringBoot项目时要把<code>pom.xml</code>添加为Maven项目，直至其图标变为蓝色。</p><p>运行项目时要<code>net start mysql</code>，再连接数据库。</p><p> </p><h2 id="循环依赖">循环依赖</h2><p>有的时候注入了在配置类下的字段的时候容易发生循环依赖，互相依赖对方，Spring无法决定谁先创建。</p><p>解决：最好修改配置类，将注入的实例独立，在方法参数层面注入，而非类字段上注入。</p><p> </p><h2 id="清理并重建项目">清理并重建项目</h2><p>1、清理缓存</p><p>打开IDEA，设置-是缓存失效-失效并重启。</p><p>2、清理Maven缓存</p><p><code>mvn clean install</code></p><p> </p><h1 id="数据库连接问题">数据库连接问题</h1><h2id="连接服务器时mysql忘记密码且文件不可读">连接服务器时，Mysql忘记密码且文件不可读</h2><p>在<code>Mysql/bin</code>文件夹下运行<code>mysqld --console</code>时报错<code>[ERROR] [MY-012271] [InnoDB] The innodb_system data file 'ibdata1' must be writable</code>。</p><p>1、停止Mysql<code>net stop mysql</code>；</p><p>2、检查<code>ibdata1</code>权限；</p><p>跳转到<code>Mysql/data</code>文件夹下，把<code>ibdata1</code>改为完全控制，再<code>mysqld --console</code>依然报错则第二步。</p><p>3、初始化<code>ibdata1</code>；</p><p>提前备份<code>Mysql/data</code>下数据，删除<code>Mysql/data</code>文件夹，先<code>mkdir data</code>，再跳转到<code>Mysql/bin</code>执行<code>mysqld --initialize-insecure --datadir="data目录" --console</code>。</p><p>重新<code>mysqld --console</code>成功后打开新窗口<code>mysql -u root</code>，重设密码<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';</code>。</p><p> </p><h2id="删除数据库时pathvariable没有被正确解析导致500">删除数据库时，<code>@PathVariable</code>没有被正确解析导致500</h2><p>1、修改<code>pom.xml</code>下<code>&lt;build&gt;</code>下的<code>&lt;configuration&gt;</code>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">    &lt;compilerArgs&gt;</span><br><span class="line">        &lt;arg&gt;-parameters&lt;/arg&gt; &lt;!-- 确保参数名信息被保留 --&gt;</span><br><span class="line">    &lt;/compilerArgs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>确保编译时保留了方法参数名称信息。</p><p>2、重新构建项目<code>mvn clean install</code>，再重新启动项目即可。</p><p> </p><h2id="连接数据库时报错public-key-retrieval-is-not-allowed">连接数据库时，报错<code>Public Key Retrieval is not allowed</code></h2><p>JDBC自动拒绝使用公钥加密登录，在连接的URL一栏中添加<code>?allowPublicKeyRetrieval=true&amp;useSSL=false</code>。</p><p> </p><h1 id="解决一对多时的无限序列化">解决一对多时的无限序列化</h1><p>用<code>@JsonIdentityInfo</code>注解，当这个对象已经被序列化时就只输出标识属性。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/os/"/>
    <url>/os/</url>
    
    <content type="html"><![CDATA[<h1 id="线程多开的弊端">线程多开的弊端</h1><p>1、系统资源消耗过大</p><ul><li>内存开销：每个线程需要独立的线程栈（几百 KB 到数MB），线程数多了会占用大量内存。</li><li>句柄/内核对象消耗：OS维护线程管理信息（TCB，线程控制块），也是负担。</li></ul><p>2、频繁上下文切换</p><ul><li>CPU可能一直在进行多线程切换而非执行实际任务，性能反而降低。</li></ul><p>3、线程调度开销增加</p><ul><li>线程调度器要在大量线程中决定调度，调度队列变长，增加调度延迟。</li></ul><p>4、竞争和同步问题</p><ul><li>多线程共享内存时，访问同一资源产生竞争，增加死锁，活锁等风险。</li></ul><p>5、缓存一致性和CPU亲和性问题</p><ul><li>如果线程频繁切换核，可能导致缓存失效，增加内存访问延迟。</li></ul><p>6、程序稳定性风险</p><ul><li>线程数超过系统支持的最大值可能导致线程创建失败或者系统卡顿甚至崩溃。</li></ul><p>改善：</p><ul><li>采用线程池：用固定数量线程复用，避免无限创建。</li><li>异步/事件驱动模型：在 I/O 密集型任务中，比开很多线程更高效。</li><li>限制线程数：一般根据 CPU核心数 和 任务性质（CPU 密集 or I/O密集）来决定线程数量。</li></ul><p> </p><h1 id="simd">SIMD</h1><p>单指令多数据</p><p>一种并行计算方式，允许处理器用一条指令同时对多个数据元素进行操作。</p><p>最常见的CPU向量化技术，MIMD则是多核CPU的通用并行方式。</p><p>实现方式：</p><ul><li>寄存器向量化：CPU有专门的向量寄存器（如Intel AVX，SSE）：<ul><li>SSE：128b向量寄存器</li><li>AVX：256b向量寄存器</li></ul></li><li>GPU并行：GPU本身就非常擅长SIMD计算，每个线程执行相同指令，处理不同数据。</li></ul><p>优点：</p><ul><li>提升速度</li><li>降低功耗</li><li>适合向量化任务：图像滤波，矩阵运算，信号处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/java/"/>
    <url>/java/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构">JVM内存结构</h1><p>JVM 执行 Java程序时会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途、创建和销毁时间。</p><p>1、程序计数器（Program Counter Register）</p><p>当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>特点：</p><ul><li><p>线程私有：每条线程有个独立的PCR，互不影响，独立存储。</p></li><li><p>如果正在执行Java方法，PCR的值为正在执行的JVM的字节码指令地址；如果是Native方法，值为空。</p></li><li><p>唯一一个没有<code>OutOfMemoryError</code>情况的区域</p></li></ul><p>2、Java虚拟机栈（Java Virtual Machine Stacks）</p><p>Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧 (StackFrame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到完成的过程，对应着一个栈帧在JVM栈中从入栈到出栈的过程。</p><p>特点：</p><ul><li>线程私有</li><li>存储内容：局部变量表，编译期可知的基本数据类型，对象引用类型和返回地址类型。</li><li>异常：<code>StackOverflowError</code>，<code>OutOfMemoryError</code></li></ul><p>3、本地方法栈（Native Method Stack）</p><p>与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行 Java方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>特点和虚拟机栈类似。</p><p>4、Java堆（Java Heap）</p><p>此内存区唯一的目的就是存放对象实例，基本在这里分配内存，通常所说的堆内存就是Java堆。</p><p>特点：</p><ul><li>线程共享：Java堆是虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。</li><li>GC 堆：Java 堆是垃圾收集器管理的主要区域，也被称为”GC堆“。</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>5、方法区（Method Area）</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>特点：</p><ul><li>线程共享</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>6、运行时常量池（Runtime Constant Pool）</p><p>方法区的一部分，常量池表 (Constant PoolTable)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的RCP中。</p><p>特点：</p><ul><li>动态性，并非预置入 Class文件常量池的内容才能进入RCP，运行期间也可能将新的常量放入池中。</li></ul><p>7、直接内存（Direct Memory）</p><p>并不是虚拟机运行时数据区的一部分，但也有可能导致<code>OutOfMemoryError</code>。</p><p> </p><p> </p><h1 id="java内存模型jmm">Java内存模型（JMM）</h1><p>抽象的概念，并不真实存在，核心目标是解决多线程环境下的三个问题：</p><ul><li>原子性：一个操作或多个操作要么全部执行成功，要么全部不执行。</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>规定了：</p><ul><li>所有的变量都在主存（MM）中</li><li>每条线程还有自己的工作内存（WM），WM中保存了被该线程使用到的变量的MM副本拷贝。</li><li>线程对变量的所有操作（读取、赋值等）都必须在WM中进行，而不能直接读写MM中的变量。</li><li>不同的线程之间也无法直接访问对方WM中的变量，线程间变量值的传递均需要通过MM来完成。</li></ul><p>当一个线程操作变量时，流程通常是：</p><ul><li>从MM中拷贝变量副本到WM</li><li>在WM中修改副本的值</li><li>在某个时间点，将WM的值刷新回MM</li></ul><p> </p><h2 id="volatile"><code>volatile</code></h2><p>轻量级同步机制，主要解决了可见性和有序性，不保证原子性，开销低，仅能修饰变量。</p><p>保证可见性：当一个变量<code>A</code>被声明为<code>volatile</code>后。</p><ul><li>写：对<code>A</code>的写操作会立刻强制刷新到MM。</li><li>读：对<code>A</code>的读操作会强制从MM中重新读取最新的值。</li></ul><p>保证有序性：通过插入内存屏障来禁止指令重排序。</p><ul><li>写：写之前的所有普通变量的写操作都完成并且已经刷新到MM。</li><li>读：读之后的所有后续普通变量的读/写操作都不会被重排序到该读操作之前。</li></ul><p>局限：不保证原子性，可以用<code>synchronized</code>保证原子性。</p><p> </p><h1 id="并发编程">并发编程</h1><h2id="如何创建线程池线程池常见参数有哪些">如何创建线程池，线程池常见参数有哪些？</h2><p>通过<code>Executors</code>工厂类快速创建和通过<code>ThreadPoolExecutor</code>手动配置。后者能够实现精细化控制。</p><p>1、通过<code>Executors</code>工厂类快速创建：</p><ul><li>固定大小线程池（负载稳定，例如API）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 核心线程数=最大线程数=5</span></span><br></pre></td></tr></table></figure><ul><li>可缓存线程池（短周期，例如批量数据）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">// 线程数动态调整</span></span><br></pre></td></tr></table></figure><ul><li>单线程线程池（事务处理）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><ul><li>定时/周期性线程池（周期性，例如心跳检测）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>2、通过<code>ThreadPoolExecutor</code>手动配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">60L</span>;</span><br><span class="line"><span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line"><span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    corePoolSize, maxPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">    threadFactory, handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3、常见参数</p><table><thead><tr><th style="text-align: center;">参数</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr><td style="text-align: center;"><code>corePoolSize</code></td><tdstyle="text-align: center;">核心线程数，线程池长期保持的最小线程数</td></tr><tr><td style="text-align: center;"><code>maxPoolSize</code></td><tdstyle="text-align: center;">最大线程数，线程池允许的最大并发线程数</td></tr><tr><td style="text-align: center;"><code>keepAliveTime</code></td><td style="text-align: center;">非核心线程空闲存活时间</td></tr><tr><td style="text-align: center;"><code>unit</code></td><tdstyle="text-align: center;"><code>keepAliveTime</code>的时间单位，常用<code>TimeUnit.SECONDS</code></td></tr><tr><td style="text-align: center;"><code>workQueue</code></td><tdstyle="text-align: center;">任务队列，存放待执行的任务，优先使用有界队列</td></tr><tr><td style="text-align: center;"><code>threadFactory</code></td><tdstyle="text-align: center;">线程工厂，用于创建线程，自定义线程名称、优先级等</td></tr><tr><td style="text-align: center;"><code>handler</code></td><tdstyle="text-align: center;">拒绝策略，当队列满且线程数达上限时的处理方式（异常等）</td></tr></tbody></table><p> </p><h1 id="集合框架">集合框架</h1><h2 id="hashmap底层原理和扩容机制">HashMap底层原理和扩容机制</h2><p>1、底层原理：</p><p>底层是一个哈希表（动态扩容的数组），数组的每个元素是一个链表/红黑树（JDK8及以后），用于存储哈希冲突的键值对。</p><ul><li>桶：数组的每个槽位（<code>table[i]</code>），存放哈希值相同的键值对。</li><li>哈希冲突：不同键通过哈希函数算出相同的下标，要放在一个桶中。</li><li>红黑树：链表-&gt;红黑树，将查找时间从O(n)优化到O(logn)。</li></ul><p>2、哈希冲突解决：</p><p>使用链地址法解决冲突：将冲突的键值对以链表形式挂在同一个桶下，尾插法，避免扩容死循环。</p><p>3、扩容机制：</p><p>通过<code>resize</code>使得负载因子在合理范围内，避免哈希冲突过多导致性能下降。</p><p>当元素数量<code>size</code>超过容量<code>capacity</code>×负载因子<code>loadFactor</code>时触发扩容，先创建新数组，容量翻倍，再迁移旧的键值对到新的桶中。</p><p> </p><h1 id="java对象引用模式">JAVA对象引用模式</h1><p>Java的引用模式是其内存管理和对象访问的核心，Java通过引用来间接操作所有对象。</p><p>对象：堆内存中实际存在的数据实体，包含了其所属类的所有成员的变量的值。</p><p>引用：一个变量，其值是对象在堆内存中的地址，引用本身存储在栈内存或另一个对象中。</p><p>关键点：</p><ul><li><code>new</code>在堆上创建对象，并返回该对象的地址。</li><li><code>=</code>是复制地址值并非复制对象，多个引用指向同一个对象。</li><li><code>null</code>不指向任何对象。</li></ul><p>参数传递：</p><p>Java中只有按值传递，传递的是地址的副本，并非引用更不是对象。</p><p> </p><h1id="equals和的区别"><code>equals()</code>和<code>==</code>的区别</h1><table><thead><tr><th>特性</th><th><code>equlas</code></th><th><code>==</code></th></tr></thead><tbody><tr><td>本质</td><td>操作符</td><td>方法（定义在<code>Object</code>类中）</td></tr><tr><td>比较对象</td><td>内存地址</td><td>内容（需要重写，比如<code>String</code>,<code>Integer</code>）</td></tr><tr><td>比较基本类型</td><td>实际值</td><td>不能用于基本类型</td></tr><tr><td>是否可自定义</td><td>否</td><td>是</td></tr></tbody></table><p> </p><h1id="arraylist和linkedlist的区别"><code>ArrayList</code>和<code>LinkedList</code>的区别</h1><table><thead><tr><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr><td>底层数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr><td>获取元素</td><td>O(1)<br>支持随机访问</td><td>O(n)<br>从表头或者表尾开始遍历</td></tr><tr><td>插入/删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr><td>遍历效率</td><td>高</td><td>低</td></tr><tr><td>内存占用</td><td>小</td><td>大</td></tr><tr><td>应用场景</td><td>读多写少，绝大多数情况</td><td>写多读少，栈，队列等</td></tr></tbody></table><p> </p><h1 id="接口">接口</h1><p>一种抽象类型，定义类必须实现的方法的集合，但接口本身不能有方法的具体实现（Java8之后<code>default</code>和<code>static</code>可以实现），主要提供一种规范，使得不同类可以通过统一接口进行交互，而不关心具体实现。</p><p>实现接口：<code>implements</code></p><p>特点：</p><ul><li>多实现</li><li>解耦：减少类之间的耦合</li><li>多态：实现运行时多态</li></ul><p> </p><h1 id="函数覆写">函数覆写</h1><p>子类重新定义从父类继承而来的同名函数，以实现不同的功能。</p><p>要求：</p><ul><li>方法签名相同：函数名，参数个数、类型都必须相同。</li></ul><p><em># 参数列表必须完全相同，不一致则变成函数重载（overload）</em></p><ul><li>访问权限：子类方法的访问权限不能比父类更严格。</li><li>多态体现：当父类指针/引用调用函数时，会根据实际对象类型执行子类方法（支持虚函数/动态绑定）。</li></ul><p>关键字：<code>virtual</code>，<code>override</code></p><p> </p><h1 id="java泛型">Java泛型</h1><p>写一个类或者方法时，不指定具体的数据类型，而是用一个类型参数来代替，使用时再指定具体类型，减少强制类型转换的需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.<span class="built_in">setContent</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str = stringBox.<span class="built_in">getContent</span>(); <span class="comment">// 不需要强转</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.<span class="built_in">setContent</span>(<span class="number">123</span>);</span><br><span class="line">Integer num = intBox.<span class="built_in">getContent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意用于方法时，想返回这个Box，必须要类似public static &lt;T&gt; box&lt;T&gt; success(T data)</span></span><br><span class="line"><span class="comment">// 必须提前声明&lt;T&gt;，不然会报错。</span></span><br></pre></td></tr></table></figure><p>不止是类，还可以用于泛型接口，方法等。</p><p>优点：</p><ul><li>类型安全</li><li>减少强制转换</li><li>可读性强</li></ul><blockquote><p>不能用于基本类型</p></blockquote><p>常用场景：集成框架，工具类方法，通用对象封装。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ssh连接github失败</title>
    <link href="/sshBug/"/>
    <url>/sshBug/</url>
    
    <content type="html"><![CDATA[<p>先尝试<code>ssh -T git@github.com</code>。</p><p> </p><p>有可能是22端口被阻隔了，尝试443端口，在config中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com </span><br><span class="line">        Hostname ssh.github.com </span><br><span class="line">        Port 443</span><br><span class="line">        User git</span><br><span class="line">        ProxyCommand connect -S 系统代理地址 %h %p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/machineLearning/"/>
    <url>/machineLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><figure><img src="machineLearningProcess.png" alt="流程示例" /><figcaption aria-hidden="true">流程示例</figcaption></figure><figure><img src="mlClassfication.png" alt="类型" /><figcaption aria-hidden="true">类型</figcaption></figure><figure><img src="mlWork.png" alt="工作流" /><figcaption aria-hidden="true">工作流</figcaption></figure><p> </p><h1 id="神经网络">神经网络</h1><figure><img src="cnnBasic.png" alt="基础" /><figcaption aria-hidden="true">基础</figcaption></figure><p>神经元接收输入信号，通过加权求和后与偏置相加，然后通过激活函数处理以产生输出。神经元的权重和偏置是网络学习过程中需要调整的参数。</p><p> </p><h2 id="前馈神经网络">前馈神经网络</h2><figure><img src="fnn.png" alt="Feedforward Neural Network，FNN" /><figcaption aria-hidden="true">Feedforward NeuralNetwork，FNN</figcaption></figure><p>基本单元，前馈神经网络特点是数据从输入层开始，经过一个或多个隐藏层，最后到达输出层，全过程没有循环或反馈。</p><p> </p><h2 id="循环神经网络">循环神经网络</h2><figure><img src="rnn.png" alt="Recurrent Neural Network, RNN" /><figcaption aria-hidden="true">Recurrent Neural Network,RNN</figcaption></figure><p>专门处理序列数据的神经网络，能够捕获输入数据中时间或顺序信息的依赖关系,在自然语言处理（NLP）、语音识别、时间序列预测等任务中有着广泛的应用。</p><p>关键特性：其能够保持隐状态（hiddenstate），使得网络能够记住先前时间步的信息。</p><p>隐状态：通过上一时间步的隐状态和当前输入共同计算得到的。</p><p> 公式：<spanclass="math inline"><em>h</em><sub><em>t</em></sub> = <em>f</em>(<em>W</em><sub><em>h</em><em>h</em></sub><em>h</em><sub><em>t</em> − 1</sub> + <em>W</em><sub><em>x</em><em>h</em></sub><em>x</em><sub><em>t</em></sub> + <em>b</em><sub><em>h</em></sub>)</span></p><p><em># <spanclass="math inline"><em>h</em><sub><em>t</em></sub></span>：当前时刻隐状态；<spanclass="math inline"><em>h</em><sub><em>t</em> − 1</sub></span>：前一时刻隐状态；<spanclass="math inline"><em>W</em><sub><em>x</em><em>h</em></sub>, <em>W</em><sub><em>h</em><em>h</em></sub></span>：权重矩阵；<spanclass="math inline"><em>x</em><sub><em>t</em></sub></span>：当前时刻的输入；<spanclass="math inline"><em>b</em><sub><em>h</em></sub></span>：偏置；<spanclass="math inline"><em>f</em>()</span>：激活函数。</em></p><p>输出：不仅依赖当前输入，还依赖于隐状态的历史信息。</p><p> 公式：<spanclass="math inline"><em>y</em><sub><em>t</em></sub> = <em>W</em><sub><em>h</em><em>y</em></sub><em>h</em><sub><em>t</em></sub> + <em>b</em><sub><em>y</em></sub></span></p><p><em># <spanclass="math inline"><em>y</em><sub><em>t</em></sub></span>：t时刻的输出向量；<spanclass="math inline"><em>W</em><sub><em>h</em><em>y</em></sub></span>：隐状态到输出状态的矩阵。</em></p><figure><img src="unfoldRnn.png" alt="展开视图" /><figcaption aria-hidden="true">展开视图</figcaption></figure><p> </p><h2 id="卷积神经网络">卷积神经网络</h2><figure><img src="cnn.png" alt="Convolutional Neural Networks, CNN" /><figcaption aria-hidden="true">Convolutional Neural Networks,CNN</figcaption></figure><p>专门用于处理具有网格状拓扑结构数据（如图像）的深度学习模型，是计算机视觉任务（如图像分类、目标检测和分割）的核心技术。</p><p> </p><h2 id="transformer模型">Transformer模型</h2><p>一种基于注意力机制的深度学习模型，仅依赖注意力机制来处理序列数据，从而实现更高的并行性和更快的训练速度。</p><figure><img src="transformer.png" alt="transformer结构" /><figcaption aria-hidden="true">transformer结构</figcaption></figure><p>结构：</p><ul><li>编码器（Encoder）：由NN层相同的模块堆叠而成，每层包含两个子层，每个子层后面都接有残差连接（Residual Connection） 和 层归一化（LayerNormalization）。</li></ul><p> 多头自注意力机制（Multi-HeadSelf-Attention）：计算输入序列中每个词与其他词的相关性。</p><p> 前馈神经网络（FNN）：对每个词进行独立的非线性变化。</p><ul><li>解码器（Decoder）：由NN层相同的模块堆叠而成，每层包含三个子层，每个子层后面都接有残差连接和层归一化。</li></ul><p> 掩码多头自注意力机制（Masked Multi-HeadSelf-Attention）：计算输出序列中每个词和其他词的相关性。</p><p><em># 使用掩码防止未来信息泄露</em></p><p> 交叉注意力机制（Encoder-DecoderAttention）：计算输出序列与输入序列的相关性。</p><p> 前馈神经网络（FNN）</p><p>核心思想：</p><ul><li>自注意力机制（Self-Attention）：允许模型在处理序列时，动态地为每个位置分配不同的权重，从而捕捉序列中任意两个位置之间的依赖关系。</li><li>多头注意力（Multi-HeadAttention）：将输入分成多个子空间，每个子空间独立计算注意力，最后将结果拼接起来。</li><li>位置编码（PositionalEncoding）：位置编码被用来为输入序列中的每个词添加位置信息，代替序列信息（如RNN中的时间步）。</li></ul><p>优势：并行计算，长距离依赖（解决RNN的梯度消失），可扩展性。</p><p>应用：NLP（机器翻译，GPT），CV（图像分类，目标检测），多模态任务。</p><p> </p><p> </p><h1 id="conda指令">Conda指令</h1><p> 查看环境：<code>conda env list</code></p><p> 进入环境：<code>conda activate 环境名称</code></p><p> 退出环境：<code>conda deactivate</code></p><p> 删除环境：<code>conda remove --name 环境名称 --all</code></p><p> 更换为阿里云镜像源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p><p> 查看当前源：<code>pip config list</code></p><p> 查看当前包：<code>pip list</code></p><p> 下载依赖包requirements.txt：<code>pip install -r requirements.txt</code></p><p> </p><p> </p><h1 id="训练模型">训练模型</h1><p>模型文件=模型结构+预训练权重</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript</title>
    <link href="/javascript/"/>
    <url>/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="文件与拖拽api的底层原理">文件与拖拽API的底层原理</h1><p>文件API：</p><p> 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；</p><p> 无路径访问：JavaScript无法知晓真正的文件路径；</p><p> 同源限制：读取的文件内容只能在当前页面上下文使用。</p><p>拖拽API：</p><p>拖拽本质是操作系统提供的跨应用（跨源）通信机制。</p><p>过程：</p><p> 拖拽开始时，OS创建“拖拽会话”；</p><p> 拖拽过程中，系统跟踪光标位置并查询下方的放置目标；</p><p> 放置时，系统协调数据传递。</p><figure><img src="dragAndDrop.png" alt="拖拽实现的层次" /><figcaption aria-hidden="true">拖拽实现的层次</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascipt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/dsa/"/>
    <url>/dsa/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="枚举算法">枚举算法</h2><p>描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。</p><p>核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解，关注枚举的上下界。</p><p>优点：简单基本，便于实现，容易调试，正确性容易证明。</p><p>流程：</p><ul><li><p>确定枚举对象、枚举的上下界、判断条件。</p></li><li><p>枚举可能的情况并验证是否是问题的解。</p></li><li><p>考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。</p><p>题库：百钱买百鸡，LeetCode78，611，1504，1733，2048，2749。</p></li></ul><p> </p><h2 id="贪心算法">贪心算法</h2><p>描述：每一步都做出在当前看来是最好的选择，期望通过局部最优选择来达到全局最优解。</p><p>核心思想：局部最优，不可回溯，期望全局最优。</p><blockquote><p>贪心只做局部最优选择，不保证全局最优。</p></blockquote><p>优点：高效，简单直观。</p><p>流程：</p><ul><li>建立数学模型</li><li>分解问题</li><li>制定贪心策略</li><li>求解子问题</li><li>合并成原问题解</li></ul><p>题库：LeetCode45，134，1578，1792，2598，3350，3397。</p><p> </p><h2 id="回溯算法">回溯算法</h2><p>描述：通过深度优先(DFS)搜索策略来遍历所有可能的候选解，并在搜索过程中利用剪枝来避免无效搜索，提高效率。</p><p>关键：在做出了选择（修改了共享状态），递归返回之后，需要撤销选择（状态和进入递归前保持一致，如果没有改变容器结构例如添加新的元素，无需撤销；没有做出选择（判断，移动指针）无需撤销）。</p><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;result_type&gt; result;  <span class="comment">// 存储最终结果</span></span><br><span class="line">    vector&lt;current_path&gt; path;   <span class="comment">// 当前路径或状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(参数列表)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (满足终止条件) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (选择 in 选择列表) &#123;</span><br><span class="line">            <span class="keyword">if</span> (不满足约束条件) <span class="keyword">continue</span>;  <span class="comment">// 剪枝</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(选择);         <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(更新参数);          <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();              <span class="comment">// 撤销选择（回溯）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以配合lamdba表达式<code>auto dfs&#123;&#125;;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs,<span class="type">int</span> i,<span class="type">int</span> t)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n||t&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(candidates[i]&gt;t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 不选i+1</span></span><br><span class="line">    <span class="type">int</span> k=i;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>&amp;&amp;candidates[k<span class="number">+1</span>]==candidates[k])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(k<span class="number">+1</span>,t);</span><br><span class="line">    <span class="comment">// 选i+1</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(i<span class="number">+1</span>,t-candidates[i]);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题库：LeetCode 22，39，40，77，79，131。</p><p> </p><h2 id="动态规划">动态规划</h2><p>描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，能够避免重复计算子问题。</p><p>分成记忆化递归（自顶向下）和DP数组（自底向上）两种动态规划。</p><p>思路：</p><ul><li>找出规律，找到子问题（最优子结构）。</li></ul><blockquote><p>动态规划问题即是递推问题，当前的决策结果是<code>f(n)</code>，最优子结构就是要让<code>f(n-k)</code>最优。</p></blockquote><ul><li>状态定义，写出状态转移方程。</li></ul><blockquote><p>注意递归边界和递归入口。</p><p>可以运用<code>auto dfs</code>和<code>memo</code>记忆化递归，此时如果入口从<code>n</code>开始要注意区间，最好左闭右开。</p></blockquote><p>题库：0-1背包问题，LeetCode62，97，120，139，474，1262，1277，1504，2327，3186，3494。</p><p> </p><h2 id="位运算算法">位运算算法</h2><p>大大提高程序的性能，0/1问题时好用。</p><p>题库：LeetCode50，78，2749。</p><p> </p><h2 id="模拟">模拟</h2><p>描述：完全按照题目的描述或者问题的真实发生过程，一步步地用代码复现出来从而得到答案。</p><p>核心思想：重视还原，过程再现。</p><p>流程：</p><ul><li>提炼规则</li><li>设计数据结构</li><li>分解步骤，模块化</li><li>注意边界</li></ul><p>特点：思路直观，实现繁琐。</p><p>题库：LeetCode6，54，3446。</p><p> </p><h2 id="堆算法">堆算法</h2><p>描述：特殊的完全二叉树，可以用一维数组存储。</p><p>堆的更新和维护：</p><p> 入堆<code>push()</code>，时间复杂度<code>O(log n)</code></p><p> 出堆<code>pop()</code>，时间复杂度<code>O(log n)</code></p><p> 访问栈顶<code>top()</code>，时间复杂度<code>O(1)</code></p><p> 建堆，时间复杂度<code>O(nlog n)</code></p><blockquote><p>即堆中插入n个元素</p></blockquote><p>应用：优先队列。</p><p>题库：LeetCode 1792。</p><p> </p><h2 id="分支限界法">分支限界法</h2><p>描述：</p><ul><li>分支：将大问题划分为若干子问题，形成解空间树，每个结点代表一个子问题，每条分支表示对子问题的一种约束或决策。</li><li>限界：对每个子问题，计算一个上下界，即它可能取得的最优解的范围，如果某个子问题的最优解范围不可能优于当前已知的最优解，就剪枝（丢弃该子问题）。</li></ul><p>流程：</p><ul><li>定义问题的解空间</li><li>从根结点开始分支，产生子问题</li><li>对每个子问题计算限界</li><li>子问题放入候选结点表（队列/堆等）</li><li>从候选结点表中选择结点展开（搜索策略）</li><li>结点满足约束并且更优就继续分支，不满足就剪枝</li><li>重复直到候选结点表为空或者找到全局最优</li></ul><p>题库：0-1背包问题。</p><p> </p><h2 id="双指针">双指针</h2><p>描述：使用两个指针（索引）在数据结构中协同工作，一般分为同向指针或者相向指针。</p><blockquote><p>滑动窗口也是一种双指针，左指针收缩窗口，右指针扩展窗口。</p><p>在窗口的贡献可以被增量维护的时候，可以使用滑动窗口。</p></blockquote><p>思路：</p><ul><li>数据结构进行排序</li><li>边界</li><li>指针移动条件</li><li>重复元素处理</li></ul><p>题库：LeetCode11，15，16，75，611， 2348。</p><p> </p><h2 id="前缀和">前缀和</h2><p>描述：高效处理区间和的技巧。</p><p>构造时<code>prefix[x]=prefix[x-1]+a[x]</code>。</p><blockquote><p>如果存在贪心/动态规划，可以只用<code>prefix</code>不用数组。</p><p>如果和模结合，可以变成取模后的前缀和数组，寻找模的数学公式。</p><p>如果和哈希表结合，可以一次遍历就处理枚举前后的两个前缀哈希表。</p></blockquote><p>核心思想：预处理前缀和，换取查询效率；适合于频繁查询但不修改。</p><p>题库：LeetCode53，1590，3147，3346，3583。</p><p><strong>差分数组</strong></p><p>描述：在区间的边界上做标记，最后通过前缀和恢复原数组。</p><blockquote><p>前缀和的互补技巧。</p></blockquote><p>构造时<code>d[i]=a[i]-a[i-1]</code>，恢复时<code>a[i]=a[i-1]+d[i]</code>。</p><p>同理，例如将遍历<code>[l,r]</code>的数组区间，每个加<code>x</code>，转换为<code>d[l]+=x</code>和<code>d[r+1]-=x</code>。</p><p>二维的时候，<code>mat[i][j]=diff[i][j]+mat[i−1][j]+mat[i][j−1]−mat[i−1][j−1]</code>，如果要将区间<code>row1,row2,col1,col2</code>内的矩形元素全部<code>+x</code>，则为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff[row1][col1]+=x;</span><br><span class="line">diff[row2+1][col1]-=x;</span><br><span class="line">diff[row1][col2+1]-=x;</span><br><span class="line">diff[row2+1][col2+1]+=x;</span><br></pre></td></tr></table></figure><blockquote><p>注意边界。</p></blockquote><p>题库：LeetCode2536，3346。</p><p> </p><p> </p><h1 id="结构">结构</h1><h2 id="折半查找树">折半查找树</h2><p>即二叉搜索树，Binary Search Tree，BST</p><p>每个结点最多有两个孩子，对于任一结点<code>node</code>：</p><p>左子树上的所有键小于<code>node-&gt;key</code>，右子树上的所有键大于<code>node-&gt;key</code>。</p><p>若树的高度为<code>h</code>，查找/插入/删除复杂度为O(h)，遍历O(n)。</p><p> </p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><p>包括深度优先遍历（DFS）和广度优先遍历（BFS）</p><p>1、深度优先遍历</p><p>按访问顺序不同，可分为前序遍历，中序遍历，后序遍历。</p><p>（1）前序遍历</p><p>顺序：根 -&gt; 左子树 -&gt; 右子树</p><p>可以用于复制树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><p>顺序：左子树 -&gt; 根 -&gt;右子树</p><p>对于二叉搜索树来说，中序遍历的结果就是升序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><p>顺序：左子树 -&gt; 右子树 -&gt; 根</p><p>删除树节点或者释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、广度优先遍历</p><p>又叫层序遍历，从根节点开始逐层从左到右访问。</p><p>输出层次结构，求出树的高度、最短路径等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//队列，FIFO</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="有向图邻接表">有向图邻接表</h2><p>常用的图存储结构，适合存储稀疏图（顶点多，边少）</p><ul><li>有向图：每条边都有方向，比如<code>u-&gt;v</code>表示从顶点<code>u</code>指向顶点<code>v</code>。</li><li>邻接表：为图中的每个顶点建立一个链表/动态数组，存储从该顶点出发的所有边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>; <span class="comment">// 顶点个数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，1-based</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">adj[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">adj[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> </p><h2 id="单调栈">单调栈</h2><p>常用于求取下一个最小元素/最大元素，栈中元素是单调递减/递增。</p><p> </p><h1 id="stl">STL</h1><h2 id="运算">运算</h2><p><strong>ASCII</strong></p><p>小写字母的ASCII码=大写字母的ASCII码+32。</p><p><strong>正整数向上取整</strong></p><p><code>int div=(a+b-1)/b</code></p><p>如果<code>a</code>整除<code>b</code>，那么加上的<code>b+1</code>还不足以跨越到下一个整数；如果<code>a</code>不整除<code>b</code>，那么跨越下一个整数。</p><p><strong>快速幂算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) ans *= x;</span><br><span class="line">    x *= x;</span><br><span class="line">    N /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：将指数作为二进制，每次向右移动一位，将<code>x</code>翻倍，最低位为<code>1</code>的就累乘到<code>ans</code>中，将时间复杂度从O(n)变成O(logn)。</p><p>正常幂可以用<code>pow(base, exponent)</code>，返回<code>double</code>。</p><p><strong>鸽巢原理</strong></p><p>在repunit的问题中出现，在取模的时候余数个数（鸽子数）如果大于模（容器数），那么至少有一个余数出现两次，即必定循环，所以就没有结果。</p><p>涉及到取模的时候，通常运用<code>(a+b)mod m=((a mod m)+(b mod m))mod m</code>和<code>(a⋅b)mod m=((a mod m)⋅(b mod m))mod m</code>。</p><p><strong><code>sort()</code></strong></p><p>格式：<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p><p>变形：<code>ranges::sort(xx)</code>等价于<code>std::(sort.begin(),sort.end())</code></p><blockquote><p>迭代器范围：<code>[first, last)</code>是一个左闭右开的区间，例如使用索引和迭代器结合时要用<code>begin()+i</code>和<code>begin()+j+1</code>。</p><p>性能：时间复杂度为O(nlogn)。</p></blockquote><p>结合Lambda表达式，第三个参数可以为匿名的函数对象。<code>[](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y)-&gt;bool&#123;return x[1]&lt;y[1]&#125;</code>，即为按照第二列升序排序。</p><p> </p><h2 id="短路求值">短路求值</h2><p>C++逻辑中的<code>||</code>是短路机制，只要前者条件满足就不会计算后者，因此在遍历容器时如果遇到<code>i+1</code>这种可以<code>if(i==length-1||colors[i]!=colors[i+1])</code>，只要没到最后一个元素就不会越界访问。</p><p> </p><h2 id="最小公约数最大公倍数">最小公约数/最大公倍数</h2><p>格式：<code>gcd()</code>和<code>lcm()</code></p><p>C++中自带，<code>0</code>和其他数的<code>gcd()</code>是其他数，区间求<code>gcd()</code>可以用枚举更新。</p><p> </p><h2 id="min_element"><code>min_element()</code></h2><p>格式：<code>min_element(begin(),end())</code></p><p>作用：返回<code>[begin,end)</code>范围内最小的迭代器，可以在前面加解引用符号<code>*</code>，即为返回值。</p><p>示例：<code>return *min_element(matrix.begin(),matrix.end())</code></p><p> </p><h2 id="lower_bound"><code>lower_bound()</code></h2><p>格式：<code>auto it = lower_bound(xx.begin(),xx.end(),x)</code></p><p>作用：找到这个容器下第一个大于等于<code>x</code>的元素，并返回迭代器（要求容器有序）。</p><p>平均时间复杂度：O(log n)。</p><p> </p><h2 id="clamp"><code>clamp()</code></h2><p>格式：<code>int x=clamp(value,lo,hi)</code></p><p>作用：返回区间[lo,hi]之间最接近value的值。</p><blockquote><p>即为<code>min(max(value, lo), hi)</code></p></blockquote><p> </p><h2 id="getline"><code>getline()</code></h2><p>格式：<code>istream&amp; getline(istream&amp; is, string&amp; str, char delim);</code></p><blockquote><p><code>is</code>是输入流对象，可以是<code>cin</code>或者<code>stringstream</code>，<code>str</code>是用来存储的字符串变量，<code>delim</code>是可选的分隔符。</p></blockquote><p>作用：默认从当前位置读到换行符<code>\n</code>为止，例如<code>getline(cin, str, ',')</code>可以读取输入流直到<code>,</code>为止。</p><p>和<code>cin&gt;&gt;</code>混用时注意要清空缓冲区<code>cin.ignore()</code>。</p><p> </p><h2 id="move"><code>move()</code></h2><p>作用：避免深拷贝操作，将容器的内容全部转移，转移后的容器会变为空。</p><blockquote><p>可以和<code>emplace_back</code>配合<code>xxx.emplace_back(move(xx))</code></p></blockquote><p> </p><h2 id="static"><code>static</code></h2><p>作用于局部变量时：使得变量的生命周期延长至整个程序运行期间，而不是随着函数调用结束而销毁。</p><p>作用于成员变量时：所有该类的对象共享同一个静态成员变量。</p><p> </p><h2 id="优先队列">优先队列</h2><p>特殊的队列，每个元素都有优先级，最先取出优先级最高的元素，堆顶是最大/最小元素，可以在<code>struct&#123;&#125;;</code>中提前声明，</p><p>格式：<code>priority_queue&lt;元素类型,底层容器类型,比较函数类型&gt;</code></p><p><em>#注：声明忽略后面两个参数时自动按照最大堆排列，即按照从前往后比较的最大元素的排列。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，char可以换成自定义的struct</span></span><br><span class="line">priority_queue&lt;<span class="type">char</span>,vector&lt;<span class="type">char</span>&gt;,CompareASCII&gt;pq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认最小堆/最大堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line"><span class="comment">// 最大优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><p>重载运算符：</p><p><em>#一般<code>const</code>修饰，重载运算符不必修改对象，引用传递避免不必要的拷贝，提高效率，返回值必须为bool。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆，栈顶是优先级最小的，最大堆反之用&lt;。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareASCII</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; a,<span class="type">const</span> <span class="type">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入：<code>push()</code>（只能接受一个参数，必须是已经构造好的元素）或者<code>emplace()</code></p><p><em># 不支持随机访问修改</em></p><p>时间复杂度：插入和删除都是<code>O(log n)</code>。</p><p> </p><h2 id="容器">容器</h2><p><strong>Vector</strong></p><p>构造：<code>vector(size_type n, const T&amp; val)</code></p><p>直接在末尾构造对象：<code>emplace_back(构造需要的数据)</code></p><blockquote><p>省去一次拷贝。</p></blockquote><p>清空所有元素：<code>clear()</code></p><blockquote><p>清空可以用<code>empty()</code>判断</p></blockquote><p>是否为空矩阵：<code>empty()</code></p><blockquote><p><code>0</code>不能用此判断</p></blockquote><p> </p><p><strong>String</strong></p><p>获取子字符串：<code>substr(size_t pos,size_t len)</code></p><blockquote><p><code>pos</code>：子字符串的起始位置，默认0；<code>len</code>：提取的字符数量，默认一直提取到末尾</p></blockquote><p>找到子字符或子字符串：<code>find()</code></p><blockquote><p>返回起始位置</p></blockquote><p>将字符串转换为整数：<code>stoi(const string&amp; s,size_t* idx,int base)</code></p><blockquote><p><code>s</code>：需转换的字符串；<code>idx</code>：可选指针；<code>base</code>：可选的转换的进制</p><p>在遇到边界的时候考虑手写转换</p></blockquote><p>删除最后一个字符：<code>pop_back()</code></p><blockquote><p>字符串不能为空</p></blockquote><p>字符构建字符串：<code>push_back()</code>或者<code>str+=c</code></p><p>遇到字母的<code>string</code>，解题时可以考虑枚举26个英文字母。</p><p> </p><p><strong>无序/有序关联容器</strong></p><p><strong>无序</strong></p><p>基于哈希表实现</p><p>1、哈希集合：<code>unordered_set&lt;key&gt;</code></p><ul><li><p>构造：<code>unordered_set&lt;key&gt; st(nums.begin(),nums.end())</code></p></li><li><p>插入：<code>insert(key)</code></p></li><li><p>查找：<code>find(key)</code>，返回的是迭代器，一般配合<code>end()</code>使用进行判断</p><blockquote><p><code>count(num)</code>，返回的是0/1，表示集合中是否存在<code>num</code>。</p></blockquote></li><li><p>删除：<code>erase(key)</code></p></li></ul><p>2、哈希表：<code>unordered_map&lt;key,value&gt;</code></p><ul><li><p>key是唯一的</p></li><li><p>用法：</p><ul><li>插入：<code>insert(&#123;key,value&#125;)</code>，或者<code>map[key]=value</code></li></ul><blockquote><p>注意，<code>it</code>指向<code>pair&lt;const Key, Value&gt;</code>的对象，不能通过<code>it</code>修改键，但可以修改值，<code>it-&gt;first</code>是键，<code>it-&gt;second</code>是值。</p></blockquote><ul><li>访问：<code>map[key]</code></li></ul></li></ul><p>3、性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(1)，但最坏情况可能是O(n)。</li><li>元素顺序：无序</li></ul><p><strong>有序</strong></p><p>基于红黑树实现</p><p>红黑树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(logn)，从而确保了所有主要操作的时间复杂度都是稳定的 O(log n)。</p><p>有序集合：<code>set&lt;key&gt;</code>和有序表：<code>map&lt;key,value&gt;</code></p><blockquote><p>用法同哈希集合和哈希表。</p></blockquote><p>性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(log n)</li><li>元素顺序：默认按键排列升序</li></ul><p> </p><h2 id="输入流">输入流</h2><p><strong><code>&gt;&gt;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss(s);</span><br><span class="line">string token;</span><br><span class="line">while(ss&gt;&gt;token)&#123;&#125;</span><br></pre></td></tr></table></figure><p>跳过了各种空白符的<code>token</code>，可以用来分割字符串。</p><p> </p><h2 id="stack">Stack</h2><p>初始化：<code>stack&lt;T&gt; s</code></p><p>栈的元素个数：<code>size()</code></p><p>自底向上拼接栈中元素(<code>string</code>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string res;</span><br><span class="line">vector&lt;string&gt; parts;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    parts.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = parts.<span class="built_in">rbegin</span>(); it != parts.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    res += *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用了vector的反向迭代器从后向前。</p></blockquote><p> </p><h2 id="位运算">位运算</h2><p> 计算整数中二进制为1的个数：<code>popcount(T x)</code></p><p><em>#<code>T</code>：无符号的整数类型，例如<code>unsigned int</code>，<code>unsigned long</code>，<code>uint64_t</code>等；<code>x</code>：整数</em></p><p> </p><h2 id="模板类">模板类</h2><p><strong><code>&lt;pair&gt;</code></strong></p><p>定义好的迷你结构体，将两个数据打包成一个整体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    T1 first;   <span class="comment">// 第一个元素</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>T1</code>和<code>T2</code>可以为其他不同类型，例如<code>pair&lt;int,string&gt;</code>，经常用于键值对，函数返回值，构造容器等。</p><p> </p><p><strong><code>&lt;tuple&gt;</code></strong></p><p>固定大小，异质（可以是不同类型）的容器</p><p>构造：<code>tuple&lt;T1,T2,T3&gt; myTuple(t1,t2,t3)</code></p><p>访问：<code>T1 first=get&lt;0&gt;(myTuple)</code>，也可以修改</p><p>支持比较：比较的是字典序</p><p> </p><h2 id="listsetmap">List，Set，Map</h2><table><thead><tr><th>特性</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>顺序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr><td>可重复</td><td>可以</td><td>不可以</td><td>键不重复</td></tr><tr><td>访问方式</td><td>下标索引</td><td>无索引</td><td>key查找</td></tr><tr><td>用途</td><td>保存序列</td><td>保存唯一元素</td><td>键值对应关系</td></tr></tbody></table><p> </p><h2 id="链表">链表</h2><p>线性数据结构，链表中的元素在内存中不是连续存放的，通过指针将一系列节点连接起来，形成逻辑上的序列。</p><p>节点：</p><ul><li>数据域：用于存储实际的数据（可以是整数、字符串、对象等）。</li><li>指针域：一个指向下一个节点的指针。</li></ul><p>单向链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据域，这里以整数为例</span></span><br><span class="line">    ListNode* next;     <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，方便创建节点</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构：</p><ul><li>头节点：链表的第一个节点。通过一个指向头节点的指针（<code>head</code>）来访问整个链表。如果链表为空，<code>head</code>指针为 <code>nullptr</code>。</li><li>尾节点：链表的最后一个节点。它的 <code>next</code> 指针指向<code>nullptr</code>。</li></ul><p>方法：</p><ul><li>创建链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建几个节点</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>遍历链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头部插入节点（时间复杂度O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtHead</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点的next指向原来的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;       <span class="comment">// 新节点成为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾部插入节点（时间复杂度O(n)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtTail</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode; <span class="comment">// 如果链表为空，新节点就是头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 将尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除节点（时间复杂度O(n)，已知位置就是O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == val) &#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找要删除节点的前一个节点</span></span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span> &amp;&amp; current-&gt;next-&gt;data != val) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>内存管理：在 C++ 中使用 <code>new</code> 创建的节点，必须使用<code>delete</code> 手动释放，否则会导致内存泄漏。</li><li>指针安全：操作指针时要格外小心，避免访问 <code>nullptr</code>或已删除的内存（野指针）。</li><li>边界条件：处理空链表、单节点链表等情况时要特别注意。</li></ul><p> </p><h2 id="inline"><code>inline</code></h2><p>内联函数，编译器会尝试用函数内的代码替换掉函数调用语句</p><p>传统函数调用过程：</p><ul><li>执行到函数调用语句</li><li>将返回地址，参数等压入栈</li><li>跳转到函数体的内存地址开始执行</li><li>函数执行完毕，将返回值存入指定位置</li><li>跳转回之前保存的地址，继续执行调用处的下一条指令</li></ul><p>这个过程对于功能简单，调用频繁的小函数，这种开销可能比函数本身执行的时间还长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>减少调用开销</li><li>避免宏定义的缺点</li></ul><p> </p><h1 id="lambda表达式">Lambda表达式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 递归函数例子</span></span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有两个点，无法组成三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用，修改 res 相当于修改 memo[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123; <span class="comment">// 枚举顶点 k</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + v[i] * v[j] * v[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>[&amp;]</code>表示能够捕获外部作用域所有变量，<code>this auto&amp;&amp;</code>允许Lambda实现自递归，<code>-&gt;int</code>表示返回类型为整数（也可以为空），<code>int&amp; res</code>表示修改这个值同时会修改对应的的<code>memo</code>的值，实现记忆化。</p><p>由捕获列表，参数列表，返回类型和函数体构成。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/hexo/"/>
    <url>/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo指令">Hexo指令：</h1><p> 新建博客：<code>hexo new'xxx'</code></p><p> 清除之前所有的公共文件：<code>hexo clean</code></p><p> 重新生成html文件：<code>hexo g</code></p><p> 上传到GitHub：<code>hexo d</code></p><p>==&gt;清除/生成/部署：<code>hexo clean &amp;&amp; hexo g -d</code></p><p> 查看hexo版本：<code>hexo version</code></p><p> </p><h1 id="hexo美化">Hexo美化</h1><p> </p><h1 id="git指令">Git指令：</h1><p> 测试Github到SSH的连接：<code>ssh -T git@github.com</code></p><p> 测试到Github的网络连接是否通畅：<code>ping github</code></p><p><em># ping命令使用 ICMP 协议，git 命令使用 HTTP/HTTPS 协议。</em></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ping</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标记语言</title>
    <link href="/markdown/"/>
    <url>/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法">Markdown语法</h1><h2 id="链接">链接</h2><p>效果：<a href="url">链接文本</a></p><p>格式：<code>[链接文本](url)</code></p><p> </p><h2 id="指数">指数</h2><p>效果：2<sup>n</sup></p><p>格式：<code>2&lt;sup&gt;n&lt;/sup&gt;</code></p><p> </p><h2 id="列表">列表</h2><p>效果：</p><ul><li><p>列表一</p></li><li><p>列表二</p><p>格式：<code>- 列表一</code></p></li></ul><p> </p><h2 id="斜体">斜体</h2><p>效果：<em>斜体</em></p><p>格式：<code>*斜体*</code></p><p> </p><h2 id="加粗">加粗</h2><p>效果：<strong>加粗</strong></p><p>格式：<code>**加粗**</code></p><p> </p><h2 id="公式">公式</h2><p>效果：<spanclass="math inline"><em>h</em><sub><em>t</em></sub></span></p><p>格式：<code>$h_t$</code></p><p> </p><h2 id="表格">表格</h2><p>效果：</p><table><thead><tr><th>列A</th><th>列B</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>格式：<code>|列A|列B|</code></p><p> </p><h2 id="引用">引用</h2><p>效果：</p><blockquote><p>引用部分</p></blockquote><p>格式：<code>&gt; 引用部分</code></p><p> </p><p> </p><h1 id="latex语法">LaTex语法</h1><h2 id="数学符号">数学符号</h2><h3 id="中括号">中括号</h3><p><span class="math display">$$\left \{\begin{aligned}&amp; abc\\&amp; def\end{aligned}\right.$$</span> 格式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\left</span> <span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">&amp;</span> abc</span><br><span class="line"><span class="keyword">\\</span><span class="built_in">&amp;</span> def</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\right</span>.</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">∈</span></td><td style="text-align: center;"><code>\in</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∀</span></td><td style="text-align: center;"><code>\forall</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∩</span></td><td style="text-align: center;"><code>\cap</code></td></tr><tr><td style="text-align: center;"><span class="math inline">≤</span></td><td style="text-align: center;"><code>\leq</code></td></tr><tr><td style="text-align: center;"><span class="math inline">⋯</span></td><td style="text-align: center;"><code>\cdots</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline">$\frac{a}{b}$</span></td><td style="text-align: center;"><code>\frac&#123;a&#125;&#123;b&#125;</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em><sub><em>b</em></sub></span></td><td style="text-align: center;"><code>a_b</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em><sup><em>b</em></sup></span></td><td style="text-align: center;"><code>a^b</code></td></tr><tr><td style="text-align: center;"><span class="math inline">$\textabc$</span></td><td style="text-align: center;"><code>\text abc</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em>  <em>b</em></span></td><td style="text-align: center;"><code>a \quad b</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline">$\sum_{i=1}^n$</span></td><td style="text-align: center;"><code>\sum_&#123;i=1&#125;^n</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>x̄</em></span></td><td style="text-align: center;"><code>\bar x</code></td></tr><tr><td style="text-align: center;"><span class="math inline">{}</span></td><td style="text-align: center;"><code>\&#123;\&#125;</code></td></tr></tbody></table><p> </p><h2 id="希腊字母">希腊字母</h2><table><thead><tr><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline"><em>δ</em></span></td><td style="text-align: center;"><code>\delta</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>Δ</em></span></td><td style="text-align: center;"><code>\Delta</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∇</span></td><td style="text-align: center;"><code>\nabla</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∂</span></td><td style="text-align: center;"><code>\partial</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>θ</em></span></td><td style="text-align: center;"><code>\theta</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>λ</em></span></td><td style="text-align: center;"><code>\lambda</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>ε</em></span></td><td style="text-align: center;"><code>\varepsilon</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>α</em></span></td><td style="text-align: center;"><code>\alpha</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>σ</em></span></td><td style="text-align: center;"><code>\sigma</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>φ</em></span></td><td style="text-align: center;"><code>\varphi</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/vue/"/>
    <url>/vue/</url>
    
    <content type="html"><![CDATA[<p>Vue3</p><p>​描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。</p><p>​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。</p><p>​ 命令：</p><p><em># 创建Vue项目</em> <code>npm init vue@latest</code></p><p><em># 启动开发服务器</em></p><p><code>npm install</code></p><p><code>npm run dev</code></p><p><em># 打开图形化界面</em></p><p><code>npm install @vue/cli</code></p><p><code>vue ui</code></p><p>Vite</p><p>​描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。</p><p>​ 组成：</p><ul><li><p>开发服务器：基于原生ES模块，提供超快的热更新。</p></li><li><p>构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。</p><p>优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/docker/"/>
    <url>/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><p>描述：开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上，也可以实现虚拟化。</p><p>优点：跨平台一致性，资源高效，快速部署，隔离性。</p><p>常用命令：</p><p>查看运行中的容器：<code>docker ps</code>；查看所有容器（包括已经停止的）：<code>docker ps -a</code></p><p>停止容器：<code>docker stop xxx</code>；停止后删除容器：<code>docker rm xxx</code></p><p>查看镜像：<code>docker images</code></p><p>创建新容器：<code>docker run -d --name xxx -p my_image:xxx</code></p><blockquote><p><code>d</code>：后台运行；<code>name</code>：指定容器名；<code>p</code>：映射端口；<code>my_image</code>：使用的镜像名/标签。</p></blockquote><p>创建容器网络：<code>docker network create xxx</code></p><blockquote><p>加入同一网络就用<code>docker run</code>加上<code>--network</code></p></blockquote><p>重启容器：<code>docker restart</code></p><p>拉取镜像：<code>docker pull</code></p><p>进入容器内部：<code>docker exec -it &lt;容器ID&gt; /xxx</code></p><p>杀死进程：<code>kill -9 项目ID</code></p><p>命令大全：<ahref="https://www.runoob.com/docker/docker-command-manual.html">Docker命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/computerNetworks/"/>
    <url>/computerNetworks/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip">TCP/IP</h1><h2 id="五层模型">五层模型</h2><p> 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。</p><p> 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。</p><p> 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。</p><p> 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。</p><p> 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。</p><h2 id="http请求过程">HTTP请求过程</h2><p>从浏览器，操作系统，网络设备到服务器共同参与的协作过程。</p><p> 过程：</p><figure><img src="http.png" alt="八个阶段" /><figcaption aria-hidden="true">八个阶段</figcaption></figure><p>1、URL解析</p><p>用户输入，浏览器解析（协议、域名、路径），浏览器检查</p><p>2、DNS域名解析</p><p>浏览器查找顺序（浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt;网络服务供应商的DNS服务器 -&gt; 递归查询），返回IP</p><p>3、建立TCP连接（三次握手）</p><p>浏览器先和服务器建立一条可靠的传输通道，即TCP连接。</p><p>4、发送HTTP请求</p><p>浏览器发送请求报文</p><ul><li>请求行：请求方法，请求的URL路径，HTTP协议版本。<ul><li><code>GET /index.html HTTP/1.1</code></li></ul></li><li>请求头：包含关于客户端和环境的信息的键值对。<ul><li><code>Host: www.example.com</code>（必需，指定域名）</li><li><code>User-Agent</code>（浏览器身份标识），<code>Accept</code>（客户端接收的内容类型）等</li></ul></li><li>请求体：通常只在POST/PUT方法中存在，包含提交给服务器的数据。</li></ul><p>5、服务器处理请求并返回HTTP响应</p><p>服务器收到请求报文后，会进行处理（例如，由Web服务器软件（如Nginx/Apache）处理静态请求，或由应用服务器（如Tomcat/Node.js）处理动态请求），然后返回一个HTTP响应报文。</p><p>服务器发送响应报文</p><ul><li>状态行：HTTP协议版本、状态码和状态消息。<ul><li><code>HTTP/1.1 200 OK</code>，<code>HTTP/1.1 404 Not Found</code>，<code>HTTP/1.1 500 Internal Server Error</code></li></ul></li><li>响应头：包含关于服务器和响应主体的信息，键值对。<ul><li><code>Content-Type</code>，<code>Content-Length</code>，<code>Set-Cookie</code></li></ul></li><li>响应体：请求的真正资源内容，HTML文档、图片数据等。</li></ul><p>6、浏览器解析渲染页面</p><p>浏览器收到响应后，会根据响应头中的<code>Content-Type</code>来决定如何处理响应体。</p><p>生成DOM树，CSSOM树，合并构建渲染树，布局，绘制。</p><p>7、连接结束（四次握手）</p><p>HTTP是一种无状态协议，默认完成请求就会关闭连接。</p><p>8、后续交互</p><p>一个完整的页面通常需要加载很多资源（CSS, JS,图片等）。对于HTTP/1.1，浏览器会对同一个域名建立多个TCP连接（通常是6-8个）来并行下载这些资源，以加快速度。HTTP/2则允许在一个TCP连接上进行多路复用，效率更高。</p><p> </p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><table><thead><tr><th>特性</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接<br>建立连接三次握手，释放连接四次握手。</td><td>无连接的<br>直接发送数据。</td></tr><tr><td>可靠性</td><td>高<br>通过确认，重传，校验，流量控制，拥塞控制等手段确保数据无差错，不丢失等。</td><td>低<br>不提供任何可靠机制，不确认是否收到，可能丢失，乱序或重复。</td></tr><tr><td>数据形式</td><td>面向字节流<br>无结构，无边界，应用程序自己处理粘包/拆包问题。</td><td>面向数据包<br>独立，有边界，一次发送就是一个完整报文。</td></tr><tr><td>速度和开销</td><td>速度慢，开销大<br>各种机制增加开销，减慢速度。</td><td>速度快，开销小<br>延迟极低，传输效率高。</td></tr><tr><td>传输模式</td><td>全双工<br>连接双方可以同时发送和接收数据。</td><td>支持单播，多播，广播。</td></tr><tr><td>应用场景</td><td>网页浏览（HTTP/HTPPS）<br>文件传输（FTP）<br>电子邮件（SMTP，IMAP）<br>远程登陆（SSH）</td><td>视频流媒体，语音通话<br>在线游戏<br>DNS查询<br>TFTP（简单文件传输）<br>广播/多播</td></tr></tbody></table><p> </p><p> </p><p>LocalStorage和SessionStorage的区别</p><figure><img src="LocalStorage.png" alt="LocalStorage.png" /><figcaption aria-hidden="true">LocalStorage.png</figcaption></figure><p>LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。</p><p> </p><p> </p><p>WebSocket</p><p>在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。</p><p>HTTP：无状态，单向请求-响应模式===&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。</p><p>WebRTC</p><p>虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN/TURN服务器。</p><p>信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
