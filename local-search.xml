<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>利用Koishi和Onebot在本机Docker上部署自己的群聊机器人</title>
    <link href="/koishiBot/"/>
    <url>/koishiBot/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><p>下载并成功运行Docker。</p><p> </p><h1 id="开始">开始</h1><h2id="拉取镜像koishijskoishi和initialencounterllonebot到本地">1、拉取镜像<code>koishijs/koishi</code>和<code>initialencounter/llonebot</code>到本地</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull koishijs/koishi</span><br><span class="line">docker pull initialencounter/llonebot</span><br></pre></td></tr></table></figure><h2 id="创建docker网络">2、创建Docker网络</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create netName</span><br></pre></td></tr></table></figure><h2 id="创建容器并连接网络">3、创建容器并连接网络</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> koishiContainer <span class="literal">--network</span> netName <span class="literal">-p</span> <span class="number">5140</span>:<span class="number">5140</span> koishijs/koishi</span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> llonebotContainer <span class="literal">--network</span> netName <span class="literal">-p</span> <span class="number">3080</span>:<span class="number">3080</span> initialencounter/llonebot</span><br></pre></td></tr></table></figure><h2 id="测试是否联通">4、测试是否联通</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> koishiContainer ping llonebotContainer</span><br></pre></td></tr></table></figure><h2 id="登录koishi和onebot">5、登录Koishi和onebot</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5140</span>/</span><br><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3080</span>/</span><br></pre></td></tr></table></figure><h2 id="在onebot中配置适配器">6、在onebot中配置适配器</h2><figure><img src="1.png" alt="启用ws正向适配器" /><figcaption aria-hidden="true">启用ws正向适配器</figcaption></figure><p>Token随便设置，和koishi中保持一致。</p><figure><img src="2.png" alt="启用ws反向适配器" /><figcaption aria-hidden="true">启用ws反向适配器</figcaption></figure><p>我两个都打开了，虽然后面连接只用了正向。</p><figure><img src="3.png" alt="效果" /><figcaption aria-hidden="true">效果</figcaption></figure><h2 id="在koishi中配置插件">7、在koishi中配置插件</h2><figure><img src="4.png" alt="在插件市场中搜索adapter-onebot" /><figcaptionaria-hidden="true">在插件市场中搜索adapter-onebot</figcaption></figure><p>添加后再返回“插件市场”中点“修改”-“配置”，跳转到“插件配置”中启用此插件。</p><figure><img src="5.png" alt="adapter-onebot中配置" /><figcaption aria-hidden="true">adapter-onebot中配置</figcaption></figure><p>selfId填写自己的机器人账号，token和上面保持一致，protocol使用ws，endpoint为<code>ws://llonebotContainer(你的onebot容器名):3001/</code>。</p><figure><img src="6.png" alt="最后运行日志为连接代表连接成功" /><figcaptionaria-hidden="true">最后运行日志为连接代表连接成功</figcaption></figure><p> </p><h1 id="测试">测试</h1><p>给机器人发送<code>help</code>，测试。</p><blockquote><p>如果有问题可以更新一下koishi其他插件，在“依赖管理”中，点右上角小火箭一键更新。</p></blockquote><p>额外的：</p><p>推荐插件<code>chatluna</code>，机器人其他功能（聊天、语言、图片…），以后再写…</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Koishi</tag>
      
      <tag>Onebot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReactBug</title>
    <link href="/reactBug/"/>
    <url>/reactBug/</url>
    
    <content type="html"><![CDATA[<h1 id="reactbug">ReactBug</h1><h2 id="问题">问题</h2><h3 id="启动">启动</h3><p>启动时先在终端<code>cd</code>跳转根目录，然后<code>npm start</code>来启动前端，<code>npx kill-port 3000</code>可以用于消除这个端口。</p><p> </p><h3id="为什么要前后端分离分别在终端中启动">为什么要前后端分离，分别在终端中启动？</h3><p>开发的时候前后端分离有利于分别调试，部署上线的时候再合并。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/springBoot/"/>
    <url>/springBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot">SpringBoot</h1><figure><img src="intro.png" alt="介绍" /><figcaption aria-hidden="true">介绍</figcaption></figure><p>SpringBoot是一个Spring模块，提供了RAD(快速应用程序开发)功能。它用于创建独立的基于Spring的应用程序，需要最少的Spring配置就可以运行。</p><p>即Spring框架和嵌入式服务器的组合。</p><blockquote><p>自动配置了 Web 服务、JSON 转换、Tomcat 服务器等，不用手动配置XML。</p><p>即自带内嵌Tomcat的Java程序，运行后监听<code>localhost:8080</code></p></blockquote><p> </p><h1 id="结构">结构</h1><table><thead><tr><th style="text-align: center;">层</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr><td style="text-align: center;"><code>@SpringBootApplication</code></td><td style="text-align: center;">主类，入口</td></tr><tr><td style="text-align: center;">config</td><tdstyle="text-align: center;">配置类，用于全局配置，在启动时加载，注册拦截器等。</td></tr><tr><tdstyle="text-align: center;">controller<br>filter<br>interceptor<br>exception</td><tdstyle="text-align: center;">控制层，接受前端请求，并调用服务层。<br>过滤器，来自Servlet，作用整个Servlet层。<br>拦截器，来自SpringMVC，控制层的横切，请求到达之前/之后的公共逻辑。<br>异常层，控制层的横切，控制异常。</td></tr><tr><td style="text-align: center;">service</td><tdstyle="text-align: center;">服务层，处理业务逻辑，并调用持久层。</td></tr><tr><td style="text-align: center;">repository</td><td style="text-align: center;">持久层，操作数据库。</td></tr><tr><td style="text-align: center;">model</td><td style="text-align: center;">实体层，映射数据库表。</td></tr><tr><td style="text-align: center;">common</td><tdstyle="text-align: center;">通用层，可以封装前后端接口等，被所有曾通用</td></tr></tbody></table><p> </p><p> </p><h1 id="注解">注解</h1><h2 id="component"><code>@Component</code></h2><p>作用：在组件扫描时，带有<code>@Component</code>及其衍生注解的类会被注册为Bean，通用组件，任何需要托管的类都可以用这个组件。</p><p>衍生注解：</p><ul><li><code>@Service</code>：服务层，处理业务逻辑。</li><li><code>@Repository</code>：持久层，处理数据库操作。</li><li><code>@Controller</code>：控制层，处理Web请求。</li><li><code>@Configuration</code>：配置类，注册Bean，有动态代理增强。</li></ul><p>用法：注解在类上。</p><h3 id="configuration"><code>@Configuration</code></h3><p>作用：配置类功能，可以用来定义<code>Bean</code>，相当于XML文件，允许在其下使用<code>@Bean</code>的注解来注册Bean到Spring容器。</p><blockquote><p>本质也是个特殊的<code>@Component</code>，会被组件扫描，会启用动态代理增强机制，保证多个<code>@Bean</code>之间安全相互调用，返回的是同一个Bean实例。</p></blockquote><p>用法：注解在类上。</p><p> </p><h2 id="componentscan"><code>@ComponentScan</code></h2><p>作用：组件扫描功能，注册标注了<code>@Component</code>等注解的类为Bean。</p><blockquote><p>扫描范围默认为当前包及其子包的所有组件。</p></blockquote><p>用法：注解在类上。</p><p> </p><h2 id="autowired"><code>@Autowired</code></h2><p>作用：用于将Spring容器内的某个Bean自动注入到另一个类的字段/构造器/方法。</p><blockquote><p>自动注入是IOC（控制反转）的一部分，减少耦合，由Spring容器管理依赖关系。</p><p>如果是构造函数注入的话不需要<code>@Autowired</code>，Spring容器会自动注入。</p></blockquote><p>用法：</p><ul><li>注解在字段上；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;  <span class="comment">// 自动注入Spring容器内的UserRepository类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注解在Setter方法上</li></ul><h3 id="qualifier"><code>@Qualifier</code></h3><p>作用：自动注入有多个类型匹配的Bean时，明确指定注入哪个Bean。</p><p>用法：和<code>@Autowired</code>一起注解。</p><p> </p><h2 id="控制类">控制类</h2><h3 id="requestmapping"><code>@RequestMapping</code></h3><p>作用：请求映射功能，可以映射URL路径。</p><p>用法：注解在类上或者方法上。</p><p>属性：</p><ul><li><code>value</code>：指定URL路径（可省略）</li><li><code>method</code>：指定HTTP方法（GET，POST等）</li><li><code>params</code>：限制请求必须包含/不包含哪些参数</li></ul><p>衍生注解：</p><ul><li><code>@GetMapping("/path")</code>等价于<code>@RequestMapping(value="/path", method=RequestMethod.GET)</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code>：通常包含请求体，请求更新的资源。</li><li><code>@DeleteMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span>  <span class="comment">// 公共前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-list&quot;</span>; <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-created&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="pathvariable"><code>@PathVariable</code></h3><p>作用：从请求的URL路径中提取参数值，传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><blockquote><p>如果有多个时，如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;userId&#125;/posts/&#123;postId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPostByUser</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, <span class="meta">@PathVariable(&quot;postId&quot;)</span> Long postId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User ID: &quot;</span> + userId + <span class="string">&quot;, Post ID: &quot;</span> + postId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> </p><h3 id="requestparam"><code>@RequestParam</code></h3><p>作用：从请求的URL查询字符串中提取参数（<code>?key=value</code>），传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> String name,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> <span class="type">int</span> age</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// name = &quot;Tom&quot;, age = 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Searched for &quot;</span> + name + <span class="string">&quot;, age &quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li><p><code>value/name</code>：指定查询字符串的参数名。</p></li><li><p><code>required</code>：是否必须提供。</p></li></ul><blockquote><p>true（默认）</p></blockquote><ul><li><code>defaultValue</code>：参数缺失时的默认值。</li></ul><p> </p><h3 id="requestbody"><code>@RequestBody</code></h3><p>作用：接收客户端发送的JSON数据并转化为对象。</p><p>用法：注解在形参上。</p><p> </p><h3 id="responsebody"><code>@ResponseBody</code></h3><p>作用：方法的返回值会直接写入HTTP响应体，返回JSON或XML数据。</p><p>用法：注解在方法上。</p><blockquote><p>在带有<code>@Controller</code>或组合注解标记的类下，对带有<code>@RequestMapping</code>及其衍生注解（如<code>@GetMapping</code>、<code>@PostMapping</code>等）的请求处理方法起作用。</p><p>不过一半可以直接<code>@RestController</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 直接返回字符串内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="异常类">异常类</h2><h3 id="controlleradvice"><code>@ControllerAdvice</code></h3><p>作用：让该类能拦截并处理全局 Controller层的异常，当项目中任意一个控制类抛出异常时，Spring会自动把异常传递到这里匹配对应的 <code>@ExceptionHandler</code>。</p><p>用法：注解在类上。</p><p><code>@ExceptionHandler</code></p><p>作用：当抛出特定类型的异常时，匹配这个方法。</p><p>用法：注解在方法上。</p><p> </p><h2 id="实体类">实体类</h2><h3 id="entity"><code>@Entity</code></h3><p>作用：JPA库中，标记当前类是一个实体类，对应数据库中的一张表，类下的字段对应表中的列。</p><p>用法：注解在类上。</p><p><strong><code>@ID</code></strong></p><p>作用：标识实体类的主键字段。</p><p>用法：注解在字段上。</p><p><strong><code>@GeneratedValue</code></strong></p><p>作用：搭配<code>@ID</code>，指定主键的生成策略。</p><p>属性：</p><ul><li><code>strategy</code></li></ul><blockquote><p>GenerationType.IDENTITY：使用数据库的自增长策略来生成主键值。</p></blockquote><p>用法：注解在字段上。</p><p> </p><h3 id="jsonidentityinfo"><code>@JsonIdentityInfo</code></h3><p>作用：避免双向关系导致的无限递归，在序列化时，如果一个对象已经被序列化过了，就只输出它的标识属性。</p><p>用法：注解在类上。</p><p>属性：</p><ul><li><p><code>generator</code>：指定如何生成对象的唯一标识。</p><blockquote><p><code>ObjectIdGenerators.PropertyGenerator.class</code></p></blockquote></li><li><p><code>property</code>：指定哪个字段作为唯一标识，一般是<code>id</code>。</p></li></ul><p> </p><h3 id="onetomany"><code>@OneToMany</code></h3><p>作用：表示一对多的关系，多的将会在数据库中添加一个外键用来指向一的键。</p><p>用法：注解在字段上。</p><p>属性：</p><ul><li><p><code>mappedBy</code>：表示这一方不是维护关系的一方，没有外键。</p><blockquote><p>通常就是这个类。</p></blockquote></li><li><p><code>cascade</code>：级联操作，对一做数据库操作时会传递到多的数据库中。</p><blockquote><p><code>CascadeType.ALL</code></p></blockquote></li><li><p><code>orphanRemoval</code>：是否移除多的一方的孤儿对象。</p><blockquote><p><code>true</code>时表示移除孤儿对象。</p></blockquote><p>例如：<code>owner类中的pets字段</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany(mappedBy = &quot;owner&quot;, cascade = CascadeType.ALL)</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;Pet&gt; pets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>@ManyToOne</code></strong></p><p>作用：表示多对一的关系。</p><p>用法：注解在字段上。</p><p><strong><code>@JoinColumn</code></strong></p><p>作用：指定外键列。</p><p>用法：注解在字段上。</p><p>属性：</p><ul><li><code>name</code>：生成外键列的名字。</li></ul><p> </p><h2 id="通用类">通用类</h2><h3 id="data"><code>@Data</code></h3><p>作用：Lombok库，包括<code>@Getter</code>，<code>@Setter</code>，<code>@ToString</code>，<code>@EqualsAndHashCode</code>，<code>@RequiredArgsConstructor</code>方法。</p><p>用法：注解在类上。</p><p><code>@NoArgsConstructor</code>和<code>@AllArgsConstructor</code>也是Lombok库中，可以自动生成无参构造和全参构造。</p><p> </p><h3id="enableautoconfiguration"><code>@EnableAutoConfiguration</code></h3><p>作用：自动配置功能，会根据所添加的依赖如<code>spring-boot-starter-web</code>，<code>spring-boot-starter-data-jpa</code>等），自动配置好相应的组件，无需手写配置。</p><p>用法：注解在类上。</p><p> </p><h2 id="组合注解">组合注解</h2><h3 id="springbootapplication"><code>@SpringBootApplication</code></h3><p>描述：组合注解，主类入口，包含了<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p><p>用法：注解在类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(StudentApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>SpringApplication.run</code>会启动内置的Tomcat服务器；扫描整个项目；自动注册<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>等组件，运行时在本地监听<code>8080</code>端口。</p></blockquote><p> </p><h3 id="restcontroller"><code>@RestController</code></h3><p>描述：包含了<code>@Controller</code>和<code>@ResponseBody</code>。</p><p>用法：注解在类上。</p><p> </p><h3 id="restcontrolleradvice"><code>@RestControllerAdvice</code></h3><p>描述：包含了<code>@ControllerAdvice</code>和<code>@ResponseBody</code>。</p><p>用法：注解在类上。</p><p> </p><h1 id="配置文件">配置文件</h1><p>作用：设置应用的全局属性和行为</p><h2 id="server"><code>server</code></h2><p><code>port</code>：设置服务器端口。</p><blockquote><p><code>8080</code></p></blockquote><p> </p><h2 id="spring"><code>spring</code></h2><h3 id="application"><code>application</code></h3><p><code>name</code>：设置应用名称。</p><h3 id="datasource"><code>datasource</code></h3><ul><li><code>url</code>：指定连接到Mysql数据库的地址和端口。</li></ul><blockquote><p><code>jdbc:mysql://localhost:3306/数据库名</code>：默认。</p></blockquote><ul><li><code>driver-class-name</code>：JDBC驱动程序的类名。</li></ul><blockquote><p><code>com.mysql.cj.jdbc.Driver</code></p></blockquote><ul><li><code>name</code></li><li><code>password</code></li></ul><h3 id="jpa"><code>jpa</code></h3><p><code>hibernate.ddl-auto</code>：控制 Hibernate在启动时对数据库表结构的自动更新行为。</p><blockquote><p><code>update</code>：如果有新的实体类或字段，Hibernate会自动尝试更新数据库表结构，使其与实体类匹配。</p><p><code>create</code>：每次启动应用时都会删除现有的数据库表，并根据实体类重新创建表格。</p></blockquote><p><code>show-sql</code>：用于开启在控制台显示执行的 SQL 语句。</p><blockquote><p><code>true</code>：开启。</p></blockquote><p> </p><p> </p><h1 id="依赖">依赖</h1><h2id="spring-boot-starter-web"><code>spring-boot-starter-web</code></h2><p>作用：集成了Web相关的所有常用依赖的启动器。</p><p>内容：</p><ul><li>Spring Web；</li><li>Jackson：用于处理JSON的转换；</li><li>Tomcat：默认嵌入式容器。</li></ul><p> </p><h2id="spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></h2><p>作用：集成了 Spring Data JPA 提供的 Repository模式，能够通过接口操作数据库，无需手动编写实现类。</p><p>内容：</p><ul><li>Spring Data JPA：提供接口减少数据库操作；</li><li>Hibernate：映射数据库中的表和Java对象的关系；</li></ul><p> </p><h1 id="bean方法"><code>Bean</code>方法</h1><blockquote><p>非核心配置Bean要用<code>Autowired</code>注入前，需要在配置类中提前配置。</p></blockquote><h2 id="核心配置">核心配置</h2><h3 id="addinterceptors"><code>addInterceptors()</code></h3><p><code>void addInterceptors(InterceptorRegistry registry)</code></p><p>作用：用于注册拦截器。</p><p>方法：</p><ul><li><code>registry.addInterceptor(自定义的拦截器)</code>：添加哪些拦截器。</li><li><code>registry.addPathPatterns("/path")</code>：拦截哪些路径。</li></ul><p> </p><h3 id="securityfilterchain"><code>SecurityFilterChain</code></h3><p>作用：定义 HTTP安全策略，即哪些URL需要认证；添加自定义过滤器，检查Token，返回过滤器链。</p><blockquote><p>在这里实现登录Token认证之后，最好再加保存到浏览器中，例如<code>HttpOnly Cookie</code>。</p></blockquote><p> </p><h3 id="authenticationmanager"><code>authenticationManager</code></h3><p>作用：提供 SpringSecurity的核心认证管理器，处理身份验证。</p><p> </p><h2 id="过滤器">过滤器</h2><h3 id="onceperrequestfilter"><code>OncePerRequestFilter</code></h3><p>作用：Spring 提供的基类，保证每个请求只执行一次过滤。</p><p> </p><h2 id="拦截器">拦截器</h2><h3 id="prehandle"><code>preHandle()</code></h3><p><code>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code></p><p>作用：在请求到达Controller前执行，如果返回<code>false</code>，请求会被终止，不会进入后续的 Controller 或<code>postHandle()</code>、<code>afterCompletion()</code> 方法。</p><p>方法：</p><ul><li><code>request.getMethod()</code>：返回请求方法（Get/Post）。</li><li><code>getRequestURI()</code>：返回请求路径。</li></ul><p> </p><p> </p><h2 id="服务层">服务层</h2><h3 id="passencoder"><code>PassEncoder</code></h3><p>作用：SpringSecurity提供的密码加密器，用于对用户密码进行安全加密和验证。</p><p>方法：</p><ul><li><code>String encode(rawPassword)</code>：把用户输入的明文密码加密成一段不可逆的哈希字符串。</li><li><code>boolean matches(rawPassword, encodedPassword)</code>：验证明文密码是否与数据库中的加密密码匹配。</li></ul><p> </p><h2 id="util层"><code>Util</code>层</h2><h3 id="jwtutil"><code>JwtUtil</code></h3><p>作用：可以生成、解析和验证token，封装用户信息，过期时间等，作为无状态的登录凭证。</p><blockquote><p>注意生成/解析Token时使用<code>Key</code>对象，老版本的字符串密钥不兼容。</p></blockquote><p>使用</p><p> </p><h2 id="持久层">持久层</h2><h3 id="crudrepository"><code>CrudRepository</code></h3><p>方法：</p><ul><li><p><code>Iterable&lt;T&gt; findAll()</code>：表示查询结果的集合。</p><blockquote><p>可以直接转化为<code>List&lt;S&gt;</code>返回。</p></blockquote></li><li><p><code>Page&lt;T&gt; findAll(Pageable pageable)</code>：分页查询。</p><blockquote><p><code>Page</code>有以下属性：<code>getSize()</code>：每页大小；<code>getNumber()</code>：当前页索引。<code>Pageable</code>可以由<code>PageRequest.of(page, size)</code>来构造。</p></blockquote></li><li><p><code>T save(T entity)</code>：根据实体是否有ID来执行插入或者更新操作，返回保存后的实体对象。</p></li><li><p><code>Optional&lt;T&gt; findById(id)</code>：从数据库中查询<code>id</code>的实体，并返回<code>Optional</code>类，可以存储一个实体，也可以表示没有值。</p><blockquote><p>配合<code>orElseThrow()</code>，<code>Optional</code>的方法，如果有值则会返回值，无值则为抛出异常，例如可以配合Lambda表达式<code>() -&gt; new RuntimeException("xxx not found")</code>。</p><p><code>findByNameContaining()</code>，<code>Containing</code>关键字可以实现按照模糊名查找。</p></blockquote></li><li><p><code>void delete(T entity)</code>：根据实体删除。</p><blockquote><p><code>void deleteById(ID id)</code>可以根据<code>id</code>删除。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/react/"/>
    <url>/react/</url>
    
    <content type="html"><![CDATA[<h1 id="react">React</h1><h2 id="语法">语法</h2><h3 id="语法糖">语法糖</h3><p>React 的 JSX 是 JavaScript 对象的语法糖，以大写字母开头的名称（如<code>&lt;Login /&gt;</code>）会被认为是 React 组件，而小写字母（如<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>）则被认为是原生 HTML标签，都是JSX，React 会把它转换成真实DOM元素。</p><p> </p><h3 id="组件模块">组件/模块</h3><p>作用：可以将导入的变成自定义组件/库中的组件，相当于组件函数。例如<code>&lt;Login /&gt;</code>等价于<code>React.createElement(Login)</code>，多编译了一步。</p><p><strong>函数组件</strong></p><p><code>function App() &#123;&#125;</code></p><p>作用：相当于一个普通的JS函数，返回JSX或React元素，React会把会根据返回值渲染页面。</p><p><strong>受控组件</strong></p><p><code>value=&#123;form.username&#125;</code></p><p>作用：值完全由React状态控制，初始渲染，再配合事件处理函数实现更新。</p><p> </p><h2 id="关键字">关键字</h2><h3 id="importexport"><code>import/export</code></h3><p>作用：导入/导出模块</p><p><code>import App from './App'</code>：导入，命名新的组件的名字。</p><p><code>import &#123; apiFetch &#125; from './api'</code>：命名的导入。</p><p><code>export default App</code>：默认导出，每个模块只能有一个<code>default export</code>。</p><p><code>export async function apiFetch(url, options = &#123;&#125;) &#123; ... &#125;</code>：命名导出，</p><p> </p><h3 id="asyncawait"><code>async</code>/<code>await</code></h3><p>作用：<code>async</code>标记函数是异步函数，返回一个Promise；<code>await</code> 只能在 <code>async</code>函数内使用，等待一个Promise对象完成，然后返回结果。</p><blockquote><p>能够让异步代码写的和同步代码顺序一样，避免回调地狱。</p></blockquote><p> </p><h3 id="obj"><code>...obj</code></h3><p>对象扩展运算符</p><p>作用：拷贝属性到新对象，合并对象，更新对象的字段。</p><blockquote><p>属性相同的会被后面的属性所替换。</p></blockquote><p> </p><h3 id="classname"><code>className</code></h3><p>作用：绑定<code>TailwindCSS</code>的关键字。</p><p> </p><h2 id="库包">库/包</h2><h3 id="react-router-dom"><code>react-router-dom</code></h3><p>作用：路由系统库，它负责根据浏览器URL的变化，动态渲染不同的组件页面，<code>Route</code>控制路径对应哪个组件。</p><p>标签：</p><p><strong><code>&lt;Router&gt;</code></strong></p><p>作用：整个应用的路由容器，它负责监听浏览器地址栏的变化，并根据路径决定显示哪个组件。</p><p><strong><code>&lt;Routes&gt;</code>/<code>&lt;Route&gt;</code></strong></p><p>作用：前者包括所有的<code>&lt;Route&gt;</code>，后者定义了“路径 →对应组件”的映射关系。</p><p>属性：</p><ul><li><code>path</code>：匹配的路径</li><li><code>element</code>：渲染的组件。</li></ul><p><strong><code>&lt;Navigate&gt;</code></strong></p><p>作用：跳转浏览器地址到指定路径。</p><p>属性：<code>to</code>：跳转的地址。</p><p> </p><h3 id="react-1"><code>react</code></h3><p>Hook：</p><blockquote><p>Hook是一种特殊函数，允许你在函数组件中“钩入”React的特性，比如状态管理、生命周期、上下文等。</p></blockquote><p><strong><code>useState</code></strong></p><p>作用：管理状态，返回一个长度为2的数组，<code>[当前状态值，更新函数]</code>。</p><p><strong><code>useNavigate</code></strong></p><p>作用：编程式导航，返回一个函数，可以用来更改路径，例如<code>const navigate = useNavigate();</code>，调用<code>navigate("/login")</code>等。</p><p> </p><h2 id="函数">函数</h2><h3 id="json"><code>json()</code></h3><p>可以将Response的HTTP响应体（通常JSON）转化成JS对象。</p><p> </p><h3 id="事件处理函数">事件处理函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setForm</span>(&#123; ...form, [e.<span class="property">target</span>.<span class="property">name</span>]: e.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义的<code>e</code>是事件对象。</p><blockquote><p>/可以作为<code>&lt;form onSubmit&gt;</code>的函数引用，引用时不要加()，否则会立刻执行。</p></blockquote><p>属性：</p><ul><li><code>e.target</code>：当前触发事件的元素，例如<code>&lt;input&gt;</code>。</li><li><code>e.target.name</code>：<code>input</code>的<code>name</code>属性…其他属性同理。</li><li><code>e.preventDefault()</code>：阻止表单的默认提交，因为React只渲染一次，提交后React状态会丢失，应该阻止提交，表单交给JS来完全控制。</li></ul><p> </p><h2 id="接口">接口</h2><h3 id="fetch-api"><code>Fetch API</code></h3><p><code>fetch(url, config)</code></p><p>作用：浏览器原生API，前端到后端的HTTP请求，返回Response对象。</p><p>参数：</p><ul><li><p><code>url</code>：后端<code>Controller</code>的路径。</p></li><li><p><code>config</code>：属性有<code>method</code>、<code>body</code>、<code>credentials</code>、<code>headers</code>等，也可以用<code>...options</code>来对象拓展，传入的<code>options</code>会合并进<code>fetch</code>。</p></li></ul><p>Response对象属性：<code>ok</code>表示HTTP响应是否成功；<code>message</code>：响应信息。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PureLibro</title>
    <link href="/pureLibro/"/>
    <url>/pureLibro/</url>
    
    <content type="html"><![CDATA[<p>PureLibro是一个本地阅读器，可以用这个在IOS手机上看小说/漫画，还是蛮方便的。</p><p>1、准备工作</p><p>在电脑上下载itunes，数据线连接手机，在手机上找一个iphones根目录下的文件夹，比如我是用的pages文稿，用来存放相关小说和漫画。</p><figure><img src="1.png" alt="点开左侧手机一样的图标，再点开左边的文件共享" /><figcaptionaria-hidden="true">点开左侧手机一样的图标，再点开左边的文件共享</figcaption></figure><p>2、传输</p><p>将文件夹中的小说/漫画文件拖动到pages文稿里的文件夹就行。</p><blockquote><p>小说和漫画格式仅支持它上面显示的，Zlibrary和Kmoe可以找一点这种文件资源。</p><p>漫画需额外注意，如果是zip格式，只能带最外面一层解压，内部图片文件的解压包需提前解压，内层PureLibro解压不出来。</p></blockquote><p>祝大家使用愉快~</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
      <category>IOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOS</tag>
      
      <tag>PureLibro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot问题</title>
    <link href="/springBootBug/"/>
    <url>/springBootBug/</url>
    
    <content type="html"><![CDATA[<h1 id="运行问题">运行问题</h1><p>启动新的SpringBoot项目时要把<code>pom.xml</code>添加为Maven项目，直至其图标变为蓝色。</p><p>运行项目时要<code>net start mysql</code>，再连接数据库。</p><p> </p><h2 id="循环依赖">循环依赖</h2><p>有的时候注入了在配置类下的字段的时候容易发生循环依赖，互相依赖对方，Spring无法决定谁先创建。</p><p>解决：最好修改配置类，将注入的实例独立，在方法参数层面注入，而非类字段上注入。</p><p> </p><h2 id="清理并重建项目">清理并重建项目</h2><p>1、清理缓存</p><p>打开IDEA，设置-是缓存失效-失效并重启。</p><p>2、清理Maven缓存</p><p><code>mvn clean install</code></p><p> </p><h1 id="数据库连接问题">数据库连接问题</h1><h2id="连接服务器时mysql忘记密码且文件不可读">连接服务器时，Mysql忘记密码且文件不可读</h2><p>在<code>Mysql/bin</code>文件夹下运行<code>mysqld --console</code>时报错<code>[ERROR] [MY-012271] [InnoDB] The innodb_system data file 'ibdata1' must be writable</code>。</p><p>1、停止Mysql<code>net stop mysql</code>；</p><p>2、检查<code>ibdata1</code>权限；</p><p>跳转到<code>Mysql/data</code>文件夹下，把<code>ibdata1</code>改为完全控制，再<code>mysqld --console</code>依然报错则第二步。</p><p>3、初始化<code>ibdata1</code>；</p><p>提前备份<code>Mysql/data</code>下数据，删除<code>Mysql/data</code>文件夹，先<code>mkdir data</code>，再跳转到<code>Mysql/bin</code>执行<code>mysqld --initialize-insecure --datadir="data目录" --console</code>。</p><p>重新<code>mysqld --console</code>成功后打开新窗口<code>mysql -u root</code>，重设密码<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';</code>。</p><p> </p><h2id="删除数据库时pathvariable没有被正确解析导致500">删除数据库时，<code>@PathVariable</code>没有被正确解析导致500</h2><p>1、修改<code>pom.xml</code>下<code>&lt;build&gt;</code>下的<code>&lt;configuration&gt;</code>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">    &lt;compilerArgs&gt;</span><br><span class="line">        &lt;arg&gt;-parameters&lt;/arg&gt; &lt;!-- 确保参数名信息被保留 --&gt;</span><br><span class="line">    &lt;/compilerArgs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>确保编译时保留了方法参数名称信息。</p><p>2、重新构建项目<code>mvn clean install</code>，再重新启动项目即可。</p><p> </p><h2id="连接数据库时报错public-key-retrieval-is-not-allowed">连接数据库时，报错<code>Public Key Retrieval is not allowed</code></h2><p>JDBC自动拒绝使用公钥加密登录，在连接的URL一栏中添加<code>?allowPublicKeyRetrieval=true&amp;useSSL=false</code>。</p><p> </p><h1 id="解决一对多时的无限序列化">解决一对多时的无限序列化</h1><p>用<code>@JsonIdentityInfo</code>注解，当这个对象已经被序列化时就只输出标识属性。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行工具</title>
    <link href="/commandLineTool/"/>
    <url>/commandLineTool/</url>
    
    <content type="html"><![CDATA[<h2 id="cmd">CMD</h2><p>command prompt，基础的命令执行环境，适合简单任务。</p><p>特点：</p><ul><li><p>处理的是文本字符串。</p></li><li><p>所有命令输出都是纯文本，无法直接操作结构化数据。</p></li><li><p>脚本语言为<code>.bat</code>和<code>.cmd</code></p></li></ul><p>常见命令：</p><ul><li>列出文件：<code>dir</code>。</li><li>显示当前路径：<code>cd</code>；更改目录：<code>cd C:\...</code>。</li></ul><p> </p><h2 id="powershell">PowerShell</h2><p>高级脚本和自动化工具。</p><p>特点：</p><ul><li>基于对象的管道机制。</li><li>可以直接访问和操作对象的属性，无需文本解析。</li><li>使用动词-名词格式命名命令，语义清晰。</li><li>脚本语言为<code>.ps1</code></li></ul><p>常见命令：</p><ul><li>列出文件：<code>Get-ChildItem</code>或<code>dir</code>。</li><li>显示当前路径：<code>Get-Location</code>；更改目录：<code>Set-Location C:\...</code>或<code>cd C:\...</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建模技术</title>
    <link href="/modelingTechnology/"/>
    <url>/modelingTechnology/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章">第一章</h1><h2 id="建模">建模</h2><p>定义：模型是对客观事物抽象出来的原型的替代物。</p><p>常见模型：实物模型、物理模型、符号模型（图表）。</p><p>数学建模：实际问题转化为数学问题。</p><p> </p><h2 id="数学建模的基本方法和步骤">数学建模的基本方法和步骤</h2><p>基本方法</p><ul><li>机理分析：对客观事物特性的认识====&gt;内部机理的数量规律（白箱）</li><li>测试分析：对量测数据的统计分析====&gt;与数据拟合最好的模型（黑箱）</li></ul><p>二者结合：机理分析建立模型结构，测试分析确定模型参数。</p><p>（建模主要指机理分析）</p><p> </p><h2 id="数学模型和数学建模">数学模型和数学建模</h2><p>第一性原理：看透事物本质的根本方法。</p><p>数学建模的一般步骤</p><ul><li>模型准备：形成清晰的问题。</li><li>模型假设：合理的，简化的。</li><li>模型构成：采用简单的数学工具。</li><li>模型求解</li><li>模型分析：误差，统计等。</li><li>模型检验：与实际现象，数据比较。</li><li>模型应用</li></ul><figure><img src="1.1.png" alt="数学建模的全过程" /><figcaption aria-hidden="true">数学建模的全过程</figcaption></figure><p>实践到理论再到实践。</p><p>特点：逼真性，条理性，可行性，渐进性，强健性，局限性，可转移性，非预制性。</p><p> </p><h2 id="优化建模">优化建模</h2><p>最小作用量原理：物理系统在从一个状态演化到另一个状态的过程中，会选择使作用量取得极值（通常是局部最小值）的路径。</p><p> 例如，费马原理：光在传播过程中，无论是直线传播、反射还是折射，都遵循时间最短或路径最短的原理。</p><p> </p><h2 id="最优化问题的一般形式及分类">最优化问题的一般形式及分类</h2><p>一般数学形式： <spanclass="math display">min<sub><em>x</em> ∈ <em>X</em></sub><em>f</em>(<em>x</em>)</span>其中，<spanclass="math inline"><em>f</em>(<em>x</em>)</span>是目标函数，<spanclass="math inline"><em>x</em></span>是决策变量，<spanclass="math inline"><em>X</em></span>是约束集合或可行域，构成优化问题的三要素。</p><p>可行域包含的点<spanclass="math inline"><em>x</em> ∈ <em>X</em></span>是可行解或可行点。<span class="math display">$$\left\{\begin{aligned}&amp; \min &amp;&amp; f(x)\\&amp; \text{s.t.} &amp;&amp; g_i(x) \leq 0, \; i = 1, \cdots, p\\&amp; &amp;&amp; h_j(x) = 0, \; j = 1, \cdots, q\end{aligned}\right.$$</span> 其中，<spanclass="math inline"><em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)<sup><em>T</em></sup></span>，<spanclass="math inline"><em>f</em>(<em>x</em>)</span>、<spanclass="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>、<spanclass="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>为 <span class="math inline"><em>x</em></span> 的实值函数。</p>引入向量函数符号$g(x) = ( g_1(x), , g_p(x) )^T <spanclass="math inline"><em>和</em></span> h(x) = ( h_1(x), , h_q(x))^T<span class="math inline"><em>后</em>：</span>$ {<p>. $$  </p><p>定义：</p><ul><li>对于最优化问题，若有<spanclass="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且有：</li></ul><p><spanclass="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>X</em></span></p><p>则称<spanclass="math inline"><em>x</em><sup>*</sup></span>是最优化问题的整体最优解，<spanclass="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是整体最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格最优解。</p><p> </p><ul><li>对于最优化问题，若有<spanclass="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且存在<spanclass="math inline"><em>x</em><sup>*</sup></span>的邻域<spanclass="math inline"><em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) = {<em>x</em> ∈ <em>R</em><sup><em>n</em></sup><em>且</em>||<em>x</em> − <em>x</em><sup>*</sup>|| &lt; <em>δ</em>}</span>使得：</li></ul><p><spanclass="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) ∩ <em>X</em></span></p><p>则称<spanclass="math inline"><em>x</em><sup>*</sup></span>是最优化问题的局部最优解，<spanclass="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是局部最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格局部最优解。</p><p> </p><p>分类：</p><ul><li>若<span class="math inline"><em>f</em>(<em>x</em>)</span>，<spanclass="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<spanclass="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>皆为线性函数，即为线性规划（LP）；至少一个非线性，则为非线性规划（NLP）。</li><li>若没有<spanclass="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<spanclass="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>，即<spanclass="math inline"><em>X</em> = ℝ<sup><em>n</em></sup></span>，则为无约束最优化问题。</li><li>若<span class="math inline"><em>f</em>(<em>x</em>)</span>，<spanclass="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<spanclass="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>皆为光滑函数，则为光滑优化，反之则为非光滑优化。</li></ul><figure><img src="1.2.png" alt="最优化问题的分类" /><figcaption aria-hidden="true">最优化问题的分类</figcaption></figure><p>一个优化问题可能属于多个类别。</p><p> </p><h2 id="机器学习问题">机器学习问题</h2><p>标准流程</p><ul><li>数据：模拟学习问题的输入和输出</li><li>模型：备选预测函数集合</li><li>算法-表现度量：指导优化的目标函数</li><li>算法-优化算法：计算优化问题最优解</li></ul><p>没有免费的午餐原理：该定理表明，在所有可能的问题中，平均而言，任何算法的性能都是相同的。（有得必有失，守恒，平衡）</p><p>奥卡姆剃刀原理：如无必要，勿增实体。</p><p> </p><h2 id="组合优化问题">组合优化问题</h2><p>定义：这类问题广泛存在于现实生活的各个领域，如物流、金融、计算机科学、生物信息学等。它关注于在给定的约束条件下，从一组可能的解中找出最优解。</p><h3 id="旅行商问题tsp">1、旅行商问题(TSP)</h3><p>在物流规划、电路板布线、生物学和交通规划等领域有重要应用。</p><p>随着城市数量的增加，问题的求解难度呈指数增长。</p><p>常用穷举法，动态规划，贪心，遗传等启发式算法。</p><h3 id="背包问题">2、背包问题</h3><p>在商业、组合数学、计算复杂性理论、密码学和应用数学等领域。</p><p>常用动态规划、分支限界法、遗传算法等。</p><h3 id="指派问题">3、指派问题</h3><p>一类特殊的线性规划问题，它要求将n项任务分配给n个人去完成，每个人只能完成一项任务，且每项任务只能由一个人完成。目标是找到一种分配方案，使得总成本（或总时间、总资源消耗等）最小。</p><p>在企业管理、资源分配、任务调度等领域有重要应用。</p><p>常用匈牙利算法等有效算法求解。</p><p> </p><p>还有调度问题、切割问题、装箱问题等等…</p><p> </p><p> </p><h1 id="第二章-连续最优化建模与应用">第二章 连续最优化建模与应用</h1><h2 id="非线性规划基础">非线性规划基础</h2><h3 id="梯度nabla-fx">梯度<spanclass="math inline">∇<em>f</em>(<em>x</em>)</span></h3><p>定义：<span class="math inline"><em>f</em>(<em>x</em>)</span>的<spanclass="math inline"><em>n</em></span>个偏导数为分量的向量。 <spanclass="math display">$$\nabla f(x) = \left[ \frac{\partial f(x)}{\partial x_1}, \frac{\partialf(x)}{\partial x_2}, \cdots, \frac{\partial f(x)}{\partial x_n}\right]^T$$</span></p><blockquote><p><spanclass="math inline">−∇<em>f</em>(<em>x</em>)</span>则为梯度下降方向，一般用于最优化问题，即梯度下降法。</p></blockquote><p>常用的梯度公式：</p><ul><li><spanclass="math inline"><em>f</em>(<em>x</em>)</span>为常数，则<spanclass="math inline">∇<em>f</em>(<em>x</em>)</span>=0；</li><li><spanclass="math inline"><em>f</em>(<em>x</em>) = <em>b</em><sup><em>T</em></sup><em>x</em></span>，则<spanclass="math inline">∇<em>f</em>(<em>x</em>) = <em>b</em></span>；</li><li><spanclass="math inline"><em>f</em>(<em>x</em>) = <em>x</em></span>，则<spanclass="math inline">∇<em>f</em>(<em>x</em>) = <em>I</em></span>（单位阵）；</li><li><spanclass="math inline"><em>f</em>(<em>x</em>) = <em>x</em><sup><em>T</em></sup><em>x</em></span>，则<spanclass="math inline">∇<em>f</em>(<em>x</em>) = 2<em>x</em></span>；</li><li><span class="math inline"><em>A</em></span>为对称矩阵，<spanclass="math inline"><em>f</em>(<em>x</em>) = <em>x</em><sup><em>T</em></sup><em>A</em><em>x</em></span>，则<spanclass="math inline">∇<em>f</em>(<em>x</em>) = 2<em>A</em><em>x</em></span></li></ul><p> </p><h3 id="n元二次函数">n元二次函数</h3><p>一般形式：<span class="math inline">$f(x_1, x_2, \cdots, x_n) =\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n a_{ij}x_i x_j + \sum_{i=1}^n b_ix_i + c$</span></p><blockquote><p>加上<span class="math inline">$\frac{1}{2}$</span>是<spanclass="math inline"><em>x</em><sub><em>i</em></sub><em>x</em><sub><em>j</em></sub></span>和<spanclass="math inline"><em>x</em><sub><em>j</em></sub><em>x</em><sub><em>i</em></sub></span>重复计算。</p></blockquote><p>矩阵形式：<span class="math inline">$f(x) = \frac{1}{2} x^T A x + b^Tx + c$</span>，其中<spanclass="math inline"><em>A</em> = <em>A</em><sup><em>T</em></sup></span></p><blockquote><p><span class="math inline"><em>A</em></span>是一个对称矩阵。</p></blockquote><p>二次型：<span class="math inline">$f(x) = \frac{1}{2} x^T Ax$</span></p><blockquote><p>只保留了二次项</p></blockquote><p>矩阵正定性：正定、半正定、负定、不定。</p><p> </p><h3 id="hessian矩阵">Hessian矩阵</h3><p>定义：多元函数<spanclass="math inline"><em>f</em>(<em>x</em>)</span>关于<spanclass="math inline"><em>x</em></span>的二阶导数。 <spanclass="math display">$$\nabla^2 f(x) = \nabla(\nabla f(x)) =\begin{bmatrix}\dfrac{\partial^2 f(x)}{\partial x_1^2} &amp; \dfrac{\partial^2f(x)}{\partial x_2 \partial x_1} &amp; \cdots &amp; \dfrac{\partial^2f(x)}{\partial x_n \partial x_1} \\\dfrac{\partial^2 f(x)}{\partial x_1 \partial x_2} &amp;\dfrac{\partial^2 f(x)}{\partial x_2^2} &amp; \cdots &amp;\dfrac{\partial^2 f(x)}{\partial x_n \partial x_2} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\dfrac{\partial^2 f(x)}{\partial x_1 \partial x_n} &amp;\dfrac{\partial^2 f(x)}{\partial x_2 \partial x_n} &amp; \cdots &amp;\dfrac{\partial^2 f(x)}{\partial x_n^2}\end{bmatrix}$$</span></p><blockquote><p>当<spanclass="math inline"><em>f</em>(<em>x</em>)</span>的所有二阶偏导数连续时，即<spanclass="math inline">$\dfrac{\partial^2 f(x)}{\partial x_i \partialx_j}=\dfrac{\partial^2 f(x)}{\partial x_j \partialx_i}$</span>时，Hessian矩阵是对称的。</p></blockquote><p> </p><h3 id="jacobi矩阵">Jacobi矩阵</h3><p>定义：<spanclass="math inline"><em>g</em>(<em>x</em>)</span>是一个向量值函数，Jacobi矩阵即为<spanclass="math inline"><em>g</em>(<em>x</em>)</span>在<spanclass="math inline"><em>x</em><sub>0</sub></span>处的导数。 <spanclass="math display">$$\nabla g(x_0) =\begin{bmatrix}\dfrac{\partial g_1(x_0)}{\partial x_1} &amp; \dfrac{\partialg_1(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partialg_1(x_0)}{\partial x_n} \\\dfrac{\partial g_2(x_0)}{\partial x_1} &amp; \dfrac{\partialg_2(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partialg_2(x_0)}{\partial x_n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\dfrac{\partial g_m(x_0)}{\partial x_1} &amp; \dfrac{\partialg_m(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partialg_m(x_0)}{\partial x_n}\end{bmatrix}$$</span>  </p><h3 id="taylor展开">Taylor展开</h3><p>定义：<spanclass="math inline"><em>f</em>(<em>x</em>)</span>是连续可微的，<spanclass="math inline"><em>p</em></span>是向量，那么 <spanclass="math display"><em>f</em>(<em>x</em> + <em>p</em>) = <em>f</em>(<em>x</em>) + ∇<em>f</em>(<em>x</em> + <em>t</em><em>p</em>)<sup><em>T</em></sup><em>p</em>,  其中0 &lt; <em>t</em> &lt; 1</span></p><blockquote><p>二阶连续可微，即可进一步<span class="math inline">$f(x + p) = f(x) +\nabla f(x)^T p + \frac{1}{2} p^T \nabla^2 f(x + tp) p$</span></p></blockquote><p> </p><h2 id="无约束可约最优化问题">无约束可约最优化问题</h2><h3 id="最优性条件">最优性条件</h3><p><span class="math display">$$\begin{aligned}&amp; \min &amp;&amp; f(x) \\&amp; \text{s.t.} &amp;&amp; x \in \mathbb{R}^n\end{aligned}$$</span></p><p>定理（必要条件）：设<spanclass="math inline"><em>f</em></span>在点<spanclass="math inline"><em>x</em><sup>*</sup> ∈ <em>R</em><sup><em>n</em></sup></span>处可微，若<spanclass="math inline"><em>x</em><sup>*</sup></span>是<spanclass="math inline"><em>m</em><em>i</em><em>n</em><em>f</em>(<em>x</em>)</span>的局部最优解，则<spanclass="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>。</p><blockquote><p>梯度为0的点称为函数的驻点，定理说明：这个点一定是驻点，但仅仅是一阶必要条件。</p><p>驻点可能是极小/极大，可能都不是，即为鞍点。</p></blockquote><p>定理（二阶充分必要条件）：设<spanclass="math inline"><em>f</em></span>在点<spanclass="math inline"><em>x</em><sup>*</sup> ∈ <em>R</em><sup><em>n</em></sup></span>处的Hessian矩阵<spanclass="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>)</span>存在，</p><ul><li>必要条件：若<spanclass="math inline"><em>x</em><sup>*</sup></span>是<spanclass="math inline"><em>f</em></span>的一个局部极小点，==&gt;<spanclass="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>，那么<spanclass="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>) ≽ 0</span>半正定；</li><li>充分条件：若<spanclass="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>，<spanclass="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>) ≻ 0</span>正定，那么<spanclass="math inline"><em>x</em><sup>*</sup></span>是<spanclass="math inline"><em>m</em><em>i</em><em>n</em><em>f</em>(<em>x</em>)</span>的严格局部最优解。</li></ul><blockquote><p>设点<spanclass="math inline"><em>x</em><sup>*</sup></span>满足一阶最优性条件，且该点处的Hessian矩阵不是半正定的，则<spanclass="math inline"><em>x</em><sup>*</sup></span>不是一个局部极小点。</p><p>事实上，该点是一个鞍点。</p></blockquote><p> </p><h4 id="最小二乘法"><strong>最小二乘法</strong></h4><p>损失函数： <span class="math display">$$J_l(\theta) = \frac{1}{2} \sum_{i=1}^n \left( h_\theta(x^{(i)}) -y^{(i)} \right)^2$$</span> 应用：曲线拟合、图像配准、信号去噪。</p><p> </p><h3 id="线搜索算法">线搜索算法</h3><figure><img src="2.1.png" alt="流程" /><figcaption aria-hidden="true">流程</figcaption></figure><p><spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>Δ</em><em>x</em><sup><em>k</em></sup></span></p><p><spanclass="math inline"><em>Δ</em><em>x</em><sup><em>k</em></sup> = <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span></p><blockquote><p><spanclass="math inline"><em>d</em><sup><em>k</em></sup></span>为第k轮搜索方向，<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>为第k轮步长。</p></blockquote><p> </p><h4id="下降方向特殊搜索方向"><strong>下降方向（特殊搜索方向）</strong></h4><p>定义：若存在<span class="math inline"><em>δ</em> &gt; 0</span>，<spanclass="math inline"><em>d</em> ∈ <em>R</em><sup><em>n</em></sup></span>，<spanclass="math inline"><em>d</em> ≠ 0</span>，使得<spanclass="math inline"><em>f</em>(<em>x</em> + <em>t</em><em>d</em>) &lt; <em>f</em>(<em>x</em>)</span>，<spanclass="math inline">∀<em>t</em> ∈ (0, <em>δ</em>)</span>，则称向量<spanclass="math inline"><em>d</em></span>是函数<spanclass="math inline"><em>f</em>(<em>x</em>)</span>在点<spanclass="math inline"><em>x</em></span>处下降方向。</p><blockquote><p>若<span class="math inline"><em>f</em>(<em>x</em>)</span>在<spanclass="math inline"><em>x</em></span>可导，则<spanclass="math inline">−∇<em>f</em>(<em>x</em>)</span>就是<spanclass="math inline"><em>f</em>(<em>x</em>)</span>在<spanclass="math inline"><em>x</em></span>处下降最快的方向。</p></blockquote><p> </p><p>最优步长： <spanclass="math display"><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup>) = min<sub><em>λ</em> ≥ 0</sub><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><em>d</em><sup><em>k</em></sup>)</span></p><blockquote><p><spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>即为最优步长。</p></blockquote><p>步骤：</p><ul><li>给出初始点<spanclass="math inline"><em>x</em><sup>0</sup></span>，令<spanclass="math inline"><em>k</em> = 0</span>；</li><li>按照某种规则，确定<spanclass="math inline"><em>d</em><sup><em>k</em></sup></span>；</li><li>按照某种规则，确定<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>，使得<spanclass="math inline"><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup>) &lt; <em>f</em>(<em>x</em><sup><em>k</em></sup>)</span>；</li><li>令<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，<spanclass="math inline"><em>k</em> := <em>k</em> + 1</span>；</li><li>判断<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>是否满足停止条件，是则停止，否则转第2步。</li></ul><p> </p><h4 id="算法收敛"><strong>算法收敛</strong></h4><p>定义：算法按<spanclass="math inline"><em>d</em><sup><em>k</em></sup></span>和<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>产生的迭代点列<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，如果点列<spanclass="math inline">{<em>x</em><sup><em>k</em></sup>}</span>收敛于最优解<spanclass="math inline"><em>x</em><sup>*</sup></span>，则称该算法收敛。</p><blockquote><p>如果进一步有$f(x<sup>0)&gt;f(x</sup>1)&gt; &gt;f(x^k)&gt;$，则称该算法为下降迭代算法。</p></blockquote><p>常用的收敛性判断条件：</p><ul><li><spanclass="math inline">∥<em>x</em><sup><em>k</em> + 1</sup> − <em>x</em><sup><em>k</em></sup>∥ &lt; <em>ε</em><sub>1</sub></span></li><li><spanclass="math inline">|<em>f</em>(<em>x</em><sup><em>k</em> + 1</sup>) − <em>f</em>(<em>x</em><sup><em>k</em></sup>)| &lt; <em>ε</em><sub>2</sub></span></li></ul><p>收敛速度： <span class="math display">$$\frac{\|x^{k+1} - x^*\|}{\|x^k - x^*\|^\alpha} &lt; \lambda, \quad\lambda, \alpha &gt; 0$$</span> 则称<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>的收敛阶为<spanclass="math inline"><em>α</em></span>。</p><blockquote><p><spanclass="math inline"><em>α</em> = 1</span>，线性收敛（k充分大）。</p><p><spanclass="math inline">1 &lt; <em>α</em> &lt; 2</span>，超线性收敛。</p><p><span class="math inline"><em>α</em> = 2</span>，二阶收敛。</p></blockquote><p> </p><h3 id="常用最优化算法">常用最优化算法</h3><h4 id="梯度法最速下降法">梯度法（最速下降法）</h4><p>定理：</p><p>设<span class="math inline"><em>f</em>(<em>x</em>)</span>在点<spanclass="math inline"><em>x̄</em></span>处可微，若存在<spanclass="math inline"><em>d</em> ∈ <em>R</em><sup><em>n</em></sup></span>，使得<spanclass="math display">∇<em>f</em>(<em>x̄</em>)<sup><em>T</em></sup><em>d</em> &lt; 0</span>则称向量<span class="math inline"><em>d</em></span>是<spanclass="math inline"><em>f</em></span>在点<spanclass="math inline"><em>x̄</em></span>处的下降方向。</p><blockquote><p><spanclass="math inline">−∇<em>f</em></span>是下降速度最快的方向，称为最速下降方向。</p><p>函数在某点的梯度不为0，则该梯度方向必定与过该点的等值面垂直。</p></blockquote><p>方向：<spanclass="math inline"><em>d</em><sup><em>k</em></sup> = −∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span></p><p>步长：</p><ul><li>可直接选取固定的<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>；</li><li>或者最优步长；</li><li>也可以依赖线搜索算法。</li></ul><p>思路：</p><ul><li>给定初始点<spanclass="math inline"><em>x</em><sup><em>k</em></sup> ∈ <em>R</em><sup><em>n</em></sup></span>，允许误差<spanclass="math inline"><em>ε</em> &gt; 0</span>，置<spanclass="math inline"><em>k</em> = 1</span>；</li><li>计算搜索方向<spanclass="math inline"><em>d</em><sup><em>k</em></sup> = −∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span>；</li><li>若<spanclass="math inline">∥<em>d</em><sup><em>k</em></sup>∥ ≤ <em>ε</em></span>停止，否则，从<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>出发，沿<spanclass="math inline"><em>d</em><sup><em>k</em></sup></span>进行一维搜索求<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>，找到最优步长；</li><li>令<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，置<spanclass="math inline"><em>k</em> := <em>k</em> + 1</span>，转第二步。</li></ul><blockquote><p>特点：线性收敛，容易产生扭摆现象造成早停，当<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>距离最优点<spanclass="math inline"><em>x</em><sup>*</sup></span>较远时，速度快；而接近最优点时，速度下降。</p></blockquote><p> </p><h4 id="牛顿法">牛顿法</h4><p>定理：</p><p>为了由<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>产生<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup></span>，在<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>附近用二次函数<spanclass="math inline"><em>Q</em>(<em>x</em>)</span>近似<spanclass="math inline"><em>f</em>(<em>x</em>)</span>，用<spanclass="math inline"><em>Q</em>(<em>x</em>)</span>的极小点作为<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup></span>。 <spanclass="math display">$$f(x) \approx Q(x) = f(x^k) + \nabla f(x^k)^T (x - x^k) + \frac{1}{2}(x -x^k)^T \nabla^2 f(x^k)(x - x^k)$$</span></p><blockquote><p>点<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>处的泰勒展开。</p></blockquote><p><span class="math display">$$Q(x) = f(x^k) + g_k^T \cdot (x - x^k) + \frac{1}{2}(x - x^k)^T G_k (x -x^k)$$</span></p><blockquote><p><span class="math inline">其中<em>g</em><sub><em>k</em></sub> = ∇<em>f</em>(<em>x</em><sup><em>k</em></sup>), <em>G</em><sub><em>k</em></sub> = ∇<sup>2</sup><em>f</em>(<em>x</em><sup><em>k</em></sup>)</span></p></blockquote><p>即<spanclass="math inline">∇<em>Q</em>(<em>x</em>) = <em>g</em><sub><em>k</em></sub> + <em>G</em><sub><em>k</em></sub>(<em>x</em> − <em>x</em><sup><em>k</em></sup>) = 0</span>，若<spanclass="math inline"><em>G</em><sub><em>k</em></sub></span>正定，即<spanclass="math inline"><em>G</em><sub><em>k</em></sub> ≻ 0</span>，则有<spanclass="math display"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> − <em>G</em><sub><em>k</em></sub><sup>−1</sup><em>g</em><sub><em>k</em></sub></span>，即为牛顿迭代公式。</p><blockquote><p>即<spanclass="math inline"><em>d</em><sup><em>k</em></sup> = −<em>G</em><sub><em>k</em></sub><sup>−1</sup><em>g</em><sub><em>k</em></sub></span>，<spanclass="math inline"><em>λ</em><sub><em>k</em></sub> = 1</span>。</p></blockquote><p>特点：</p><ul><li>收敛速度快，为二阶局部收敛。（需要二阶正定）</li><li>初始点最好选在最优点附近，一般先用最速下降法得到较低精度的解，再用牛顿法加速。</li></ul><h5 id="拟牛顿法">拟牛顿法</h5><p>用正定矩阵<spanclass="math inline"><em>H</em><sub><em>k</em></sub></span>代替<spanclass="math inline"><em>G</em><sub><em>k</em></sub><sup>−1</sup></span>，则有：<spanclass="math display"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> − <em>λ</em><sub><em>k</em></sub><em>H</em><sub><em>k</em></sub>∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span></p><blockquote><p>当<spanclass="math inline"><em>H</em><sub><em>k</em></sub> = <em>I</em></span>时，<spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> − <em>λ</em><sub><em>k</em></sub>∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span>，最速下降法。</p><p>当<spanclass="math inline"><em>H</em><sub><em>k</em></sub> = <em>G</em><sub><em>k</em></sub><sup>−1</sup></span>，<spanclass="math inline"><em>λ</em><sub><em>k</em></sub> = 1</span>时，牛顿法。</p></blockquote><p>拟牛顿条件： <spanclass="math display"><em>H</em><sub><em>k</em> + 1</sub><em>Δ</em><em>g</em><sub><em>k</em></sub> = <em>Δ</em><em>x</em><sup><em>k</em></sup></span></p><blockquote><p><spanclass="math inline"><em>g</em><sub><em>k</em></sub></span>为对<spanclass="math inline"><em>f</em>(<em>x</em>)</span>在<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>的梯度。</p></blockquote><p>步长可用最优步长。</p><p>优点：</p><ul><li>只需用到函数的一阶梯度</li><li>下降算法，全局收敛</li><li>不需要求逆矩阵（计算量小）</li><li>一般可达超线性收敛（速度快）</li></ul><p>衍生：</p><ul><li>DFP算法：</li></ul><p><span class="math display">$$H_{k+1} = H_k + \frac{\Delta x_k^T \Delta x_k}{\Delta x_k^T \Delta g_k}- \frac{H_k \Delta g_k \Delta g_k^T H_k}{\Delta g_k^T H_k \Delta g_k}$$</span> - BFGS算法：</p><p> </p><h3 id="步长线搜索算法">步长线搜索算法</h3><p>精确线搜索算法：<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>为最优步长。</p><p>非精确线搜索：依照线搜索准则。</p><ul><li>Armijo准则</li><li>Goldstein准则</li><li>Wolfe准则</li></ul><p>线搜索回退法</p><p> </p><h2 id="约束非线性最优化">约束非线性最优化</h2><h3 id="最优性条件-1">最优性条件</h3><p><span class="math display">$$\left\{\begin{array}{ll}\min        &amp; f(x) \\\text{s.t.} &amp; g(x) \geq 0 \\            &amp; h(x) = 0\end{array}\right.$$</span></p><blockquote><p>KKT必要条件</p></blockquote><p>构造拉格朗日函数： <span class="math display">$$L(x, \mu, \lambda) = f(x) - \sum_{j=1}^{m} \mu_j h_j(x) - \sum_{j=1}^{l}\lambda_j g_j(x) \\= f(x) - \mu^T h(x) - \lambda^T g(x)$$</span></p><blockquote><p><span class="math inline"><em>μ</em></span>和<spanclass="math inline"><em>λ</em></span>即为拉格朗日乘子</p></blockquote><p>则KKT条件可以表示为： <span class="math display">$$\nabla f(x^*) = \lambda^T \nabla g(x^*) + \mu^T \nabla h(x^*) \quad\text{稳定性条件} \\h(x^*) = 0 \quad\text{原问题可行性} \\g(x^*) \geq 0 \quad\text{原问题可行性} \\\lambda \geq 0 \quad\text{对偶可行性} \\\lambda^T g(x^*) = 0 \quad\text{互补松弛条件}$$</span></p><h4 id="kkt充分条件">KKT充分条件</h4><p>定理：设<span class="math inline"><em>f</em></span>为凸函数，<spanclass="math inline"><em>g</em><sub><em>i</em></sub></span>为凹函数，<spanclass="math inline"><em>h</em><sub><em>j</em></sub></span>为线性函数。对于<spanclass="math inline">$𝑥^*\in𝑆$</span>，若<spanclass="math inline"><em>f</em></span>，<spanclass="math inline"><em>g</em><sub><em>i</em></sub></span>，<spanclass="math inline"><em>h</em><sub><em>j</em></sub></span>在点<spanclass="math inline"><em>x</em><sup>*</sup></span>处可微，并且KKT条件成立，则<spanclass="math inline"><em>x</em><sup>*</sup></span>为优化问题的全局极小点。</p><h4 id="惩罚函数法">惩罚函数法</h4><p>思想：迭代过程中，罚函数法通过对不可行点施加惩罚，迫使迭代点向可行域靠近。一旦迭代点成为可行点，则这个可行点就是原问题的最优解。根据不同的罚函数有不同的罚方法。</p><blockquote><p>也成为序列无约束极小化方法，将有约束优化转换为一系列无约束优化问题进行求解。</p></blockquote><h5 id="外点法外惩法">外点法（外惩法）</h5><p>对于有约束原问题： <span class="math display">$$\min f(x) \\\text{s.t.} \quad g_i(x) \leq 0, \quad i = 1, \cdots, m$$</span> 转换为： <span class="math display">$$\min f(x) \\\text{s.t.} \quad x \in D$$</span></p><blockquote><p>其中<spanclass="math inline"><em>D</em> = {<em>x</em> ∣ <em>g</em>(<em>x</em>) ≤ 0}</span></p></blockquote><p>构造一个<spanclass="math inline"><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span>，使得<spanclass="math display"><em>φ</em><sub><em>k</em></sub>(<em>x</em>) = <em>f</em>(<em>x</em>) + <em>λ</em><sub><em>k</em></sub><em>p</em>(<em>x</em>)</span>其中<spanclass="math inline"><em>λ</em><sub>1</sub> &lt; <em>λ</em><sub>2</sub> &lt; ⋯ &lt; <em>λ</em><sub><em>k</em></sub>( ↑ ) → +∞</span>，并且</p><ul><li><span class="math inline"><em>p</em>(<em>x</em>) = 0</span>，当<spanclass="math inline"><em>x</em> ∈ <em>D</em></span>时；</li><li><spanclass="math inline"><em>p</em>(<em>x</em>) &gt; 0</span>，当<spanclass="math inline"><em>x</em> ∉ <em>D</em></span>时。</li></ul><blockquote><p>其中<spanclass="math inline"><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span>：增广函数；<spanclass="math inline"><em>p</em>(<em>x</em>)</span>：惩罚函数；<spanclass="math inline"><em>λ</em><sub><em>k</em></sub></span>：惩罚因子。</p></blockquote><p>定理：</p><p>当<spanclass="math inline"><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span>有最优解<spanclass="math inline"><em>x</em><sup>*</sup></span>,并且<spanclass="math inline"><em>x</em><sup>*</sup>(<em>λ</em><sub><em>k</em></sub>) ∈ <em>D</em></span>，即则<spanclass="math inline"><em>x</em><sup>*</sup>(<em>λ</em><sub><em>k</em></sub>)</span>也是原问题<spanclass="math inline"><em>𝑓</em>(<em>𝑥</em>)</span> 的最优解。</p><p>一般构造：</p><p><span class="math inline">$p(x) = \sum_{j=1}^{m} \left( \max\{g_j(x),0\} \right)^2 + \sum_{k=1}^{p} \left( h_k(x) \right)^2$</span></p><p><spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = arg min<sub><em>x</em> ∈ ℝ<sup><em>n</em></sup></sub><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span></p><h5 id="内点法内惩法">内点法（内惩法）</h5><p>使得迭代点是在可行域点集内部移动的，对接近可行域边界上的点施加越来越大的惩罚，对可行域边界上的点施加无限大的惩罚，阻碍迭代点穿越边界。</p><blockquote><p>等式约束不适用。</p></blockquote><p>此时 <span class="math display">$$\begin{aligned} D &amp;= \{x \mid g_i(x) \leq 0,\ i = 1, \dots, m\} \\&amp;= \partial D \cup \operatorname{int} D = \text{边界点集} \cup\text{内点集} \end{aligned}$$</span> 构造一个<spanclass="math inline"><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span>，使得<spanclass="math display"><em>φ</em><sub><em>k</em></sub>(<em>x</em>) = <em>f</em>(<em>x</em>) + <em>μ</em><sub><em>k</em></sub><em>q</em>(<em>x</em>)</span>一般构造：</p><p><span class="math inline">$q(x) = \sum_{j=1}^{m} -\frac{1}{g_j(x)}\text{或}q(x) = \sum_{j=1}^{m} \frac{1}{g_j^2(x)};$</span></p><p><spanclass="math inline"><em>x</em><sup><em>k</em> + 1</sup> = arg min<sub><em>x</em> ∈ ℝ<sup><em>n</em></sup></sub><em>φ</em><sub><em>k</em></sub>(<em>x</em>)</span></p><h4 id="增广拉格朗日乘子法">增广拉格朗日乘子法</h4><p>考虑等式约束问题： <span class="math display">$$\begin{aligned}&amp;\min f(x) \\&amp;\text{s.t. } h(x) = 0\end{aligned}$$</span> 构造增广拉格朗日函数： <span class="math display">$$\varphi(x, v, \mu) = f(x) + \sum_{i=1}^{l} v_i h_i(x) + \frac{1}{2}\sum_{i=1}^{l} \sigma_i h_i^2(x)$$</span></p><blockquote><p>其中，<span class="math inline"><em>v</em></span>为乘子；<spanclass="math inline"><em>σ</em></span>为惩罚因子。</p></blockquote><p>思路：</p><ul><li>求解<spanclass="math inline">min <em>φ</em>(<em>x</em>, <em>v</em><sup>(<em>k</em>)</sup>, <em>σ</em><sup>(<em>k</em>)</sup>)</span>，得到<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>，<spanclass="math inline"><em>k</em> = 0, 1, 2, ...</span>；</li><li>若<spanclass="math inline"><em>h</em>(<em>x</em><sup><em>k</em></sup>) = 0</span>，得到<spanclass="math inline"><em>x</em><sup><em>k</em></sup></span>以及乘子<spanclass="math inline"><em>v</em><sup><em>k</em></sup></span>；</li><li>否则调整<spanclass="math inline"><em>v</em><sup>(<em>k</em>)</sup></span>。</li></ul><blockquote><p><spanclass="math inline"><em>v</em><sup>(<em>k</em>)</sup></span>的更新：<spanclass="math inline"><em>v</em><sub><em>j</em></sub><sup>(<em>k</em> + 1)</sup> = <em>v</em><sub><em>j</em></sub><sup>(<em>k</em>)</sup> + <em>σ</em><em>h</em><sub><em>j</em></sub>(<em>x</em><sup><em>k</em></sup>), <em>j</em> = 1, 2, ..., <em>l</em></span></p><p>不需要更新<span class="math inline"><em>σ</em></span></p></blockquote><p> </p><p> </p><h1 id="第三章-线性规划">第三章 线性规划</h1><h2 id="线性规划及其概念">线性规划及其概念</h2><p><span class="math display">$$\left\{\begin{aligned}&amp; \min &amp;&amp; f(x)\\&amp; \text{s.t.} &amp;&amp; g_i(x) \leq 0, \; i = 1, \cdots, p\\&amp; &amp;&amp; h_j(x) = 0, \; j = 1, \cdots, q\end{aligned}\right.$$</span></p><blockquote><p>若<span class="math inline"><em>f</em>(<em>x</em>)</span>，<spanclass="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<spanclass="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>皆为线性函数，即为线性规划（LP）。</p></blockquote><p>LP模型的标准型 <span class="math display">$$\begin{aligned}&amp;\max \quad Z = c^{\mathrm{T}}x \\&amp;\text{s.t.} \quad\begin{cases}Ax = b \\x \geq 0\end{cases}\end{aligned}$$</span></p><blockquote><p>目标函数最大，约束条件等式，决策变量<spanclass="math inline"><em>x</em></span>非负，资源限量<spanclass="math inline"><em>b</em></span>非负。</p><p>如果<spanclass="math inline"><em>x</em><sub><em>j</em></sub></span>为自由变量，可令<spanclass="math inline"><em>x</em><sub><em>j</em></sub> = <em>x</em><sub><em>j</em></sub><sup>+</sup> − <em>x</em><sub><em>j</em></sub><sup>−</sup></span>，两个分量都非负即可。</p></blockquote><p>不等式变等式引进松弛变量和剩余变量，例如<spanclass="math inline"><em>A</em><em>x</em> &lt;  = <em>b</em></span>转换<spanclass="math inline"><em>A</em><em>x</em> + <em>s</em><em>i</em> = <em>b</em></span>（松弛变量）；<spanclass="math inline"><em>A</em><em>x</em> &gt;  = <em>b</em></span>转换<spanclass="math inline"><em>A</em><em>x</em> − <em>s</em><em>i</em> = <em>b</em></span>（剩余变量）。</p><p>定理1：若LP存在可行域，则一定为凸集。</p><blockquote><p>凸集：设<spanclass="math inline"><em>K</em></span>是n维欧式空间的一个点集，<spanclass="math inline"><em>x</em><sup>1</sup> ∈ <em>K</em></span>，<spanclass="math inline"><em>x</em><sup>2</sup> ∈ <em>K</em></span>，<spanclass="math inline"><em>x</em><sup>1</sup> ≠ <em>x</em><sup>2</sup></span>，<spanclass="math inline"><em>K</em></span>中这两点连线上的所有点<spanclass="math inline"><em>x</em> = <em>α</em><em>x</em><sup>1</sup> + (1 − <em>α</em>)<em>x</em><sup>2</sup> ∈ <em>K</em>, (0 &lt; <em>α</em> &lt; 1)</span>，则称<spanclass="math inline"><em>K</em></span>为凸集。</p></blockquote><p>定理2：若LP的可行域非空且有界，则必定有最优解。</p><p>定理3：若LP有最优解，则最优解一定可以在其可行域的某个顶点上取得。</p><p>定理4：LP问题可行域的顶点与其基本可行解一一对应。</p><p>设<span class="math inline"><em>m</em></span>个线性无关列是<spanclass="math inline"><em>A</em></span>前<spanclass="math inline"><em>m</em></span>列，<spanclass="math inline"><em>B</em> = (<em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, ..., <em>P</em><sub><em>m</em></sub>)</span>，则<spanclass="math inline"><em>P</em><sub><em>j</em></sub></span>为基向量，与其对应的变量<spanclass="math inline"><em>x</em><sub><em>j</em></sub></span>则为基变量。</p><p>例如： <span class="math display">$$\begin{aligned}\left\{\begin{array}{l}x_1 + 2x_2 \leq 8 \\x_2 \leq 2 \\x_1, x_2 \geq 0\end{array}\right.\quad \Rightarrow \quad\left\{\begin{array}{l}x_1 + 2x_2 + x_3 = 8 \\x_2 + x_4 = 2 \\x_1, x_2, x_3, x_4 \geq 0\end{array}\right.\end{aligned}$$</span> 则 <span class="math display">$$A = \begin{pmatrix}1 &amp; 2 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 1\end{pmatrix}= (P_1, P_2, P_3, P_4)$$</span></p><p><span class="math display">$$b=\begin{pmatrix}8\\2\end{pmatrix}$$</span></p><p>就有 <span class="math display">$$B_1=(P_1,P_2)=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix},B_2=(P_1,P_4)=\begin{pmatrix}1&amp;0\\0&amp;1\end{pmatrix},同理B_3-B_5$$</span></p><blockquote><p>没有<spanclass="math inline">(<em>P</em><sub>1</sub>, <em>P</em><sub>3</sub>)</span>因为<spanclass="math inline"><em>P</em><sub>1</sub> = <em>P</em><sub>3</sub></span>，所以<spanclass="math inline"><em>B</em></span>的个数<spanclass="math inline"> ≤ <em>C</em><sub><em>n</em></sub><sup><em>m</em></sup></span>，<spanclass="math inline"><em>n</em></span>为变量个数，<spanclass="math inline"><em>m</em></span>为等式个数。</p></blockquote><p><spanclass="math inline"><em>A</em><em>x</em> = <em>b</em></span>的所有解为：<span class="math display">$$x = \begin{bmatrix} x_B \\ x_N \end{bmatrix}= \begin{bmatrix} B^{-1}b - B^{-1}Nx_N \\ x_N \end{bmatrix}$$</span> 令所有非基变量<spanclass="math inline"><em>x</em><sub><em>N</em></sub> = 0</span>，得到一个特解<spanclass="math inline">$x=\begin{bmatrix}B^{-1}b\\0\end{bmatrix}$</span>称为基本解。基变量<spanclass="math inline"><em>x</em><sub><em>B</em></sub> = <em>B</em><sup>−1</sup><em>b</em></span>。</p><blockquote><p>有一个<spanclass="math inline"><em>B</em></span>就有一个基本解，个数也<spanclass="math inline"> ≤ <em>C</em><sub><em>n</em></sub><sup><em>m</em></sup></span>，但基本解不一定可行，只有<spanclass="math inline"><em>x</em><sub><em>B</em></sub> = <em>B</em><sup>−1</sup><em>b</em> ≥ 0</span>时，基本解为基本可行解，此时<spanclass="math inline"><em>B</em></span>为可行基；只是<spanclass="math inline"> &gt; 0</span>称为非退化的可行解。</p></blockquote><p><img src="3.1.png" /></p><p> </p><h2 id="单纯形法">单纯形法</h2><p>思路：从一个基本可行解出发，设法得到另一个更好的基本可行解，直到目标函数达到最优时，基本可行解即为最优解。</p><p>步骤：</p><ul><li>求一个基本可行解，称为初始基本可行解</li><li>最优条件检验。即检验任一基本可行解是否为最优解，是则停止计算，否则下一步。</li><li>确定改善方向，求得另一个更好的基本可行解，转上一步，直到最优解为止。</li></ul><p>示例： <span class="math display">$$\begin{aligned}\max \quad&amp; z = 50x_1 + 100x_2 \\\text{s.t.} \quad &amp;\begin{cases}2x_1 + 2x_2 \leq 600 \\5x_1 + 2.5x_2 \leq 1000 \\x_1 \leq 250 \\x_1, x_2 \geq 0\end{cases}\end{aligned}$$</span> 1、转化为标准型 <span class="math display">$$\begin{aligned}\max \quad &amp; z = 50x_1 + 100x_2 + 0s_1 + 0s_2 + 0s_3 \\\text{s.t.} \quad &amp;\begin{cases}x_1 + x_2 + s_1 &amp;= 300 \\2x_1 + x_2 + s_2 &amp;= 400 \\x_1 + s_3 &amp;= 250 \\x_1, x_2, s_1, s_2, s_3 &amp;\geq 0\end{cases}\end{aligned}$$</span> 2、提取系数，填入表格</p><table><thead><tr><th style="text-align: center;">迭代次数</th><th style="text-align: center;">基变量</th><th style="text-align: center;"><spanclass="math inline"><em>C</em><sub><em>B</em></sub></span></th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>1</sub></span><br>50</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>2</sub></span><br>100</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>1</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>2</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>3</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>b</em></span></th><th style="text-align: center;">比值<br><spanclass="math inline">$\frac{b_i}{a_{i2}}$</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline"><em>s</em><sub>1</sub></span></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">300</td><td style="text-align: center;"><spanclass="math inline">$\frac{300}{1}$</span></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>s</em><sub>2</sub></span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">400</td><td style="text-align: center;"><spanclass="math inline">$\frac{400}{1}$</span></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>s</em><sub>3</sub></span></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">250</td><td style="text-align: center;">\</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>z</em><sub><em>j</em></sub> = <em>C</em><sub><em>B</em></sub><em>N</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>σ</em><sub><em>j</em></sub> = <em>c</em><sub><em>j</em></sub> − <em>z</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;">50</td><td style="text-align: center;">100</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><spanclass="math inline"><em>x</em><sub>2</sub></span>对应的正检验数<spanclass="math inline"><em>σ</em><sub><em>j</em></sub></span>最大，所以选择<spanclass="math inline"><em>x</em><sub>2</sub></span>作为换入变量，在这个基础上的最小比值是<spanclass="math inline"><em>s</em><sub>1</sub></span>对应的，所以选择<spanclass="math inline"><em>s</em><sub>1</sub></span>作为换出变量，进行下一次迭代。</p><table><thead><tr><th style="text-align: center;">迭代次数</th><th style="text-align: center;">基变量</th><th style="text-align: center;"><spanclass="math inline"><em>C</em><sub><em>B</em></sub></span></th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>1</sub></span><br>50</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>2</sub></span><br>100</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>1</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>2</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>s</em><sub>3</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>b</em></span></th><th style="text-align: center;">比值<br><spanclass="math inline">$\frac{b_i}{a_{i2}}$</span></th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;"><spanclass="math inline"><em>x</em><sub>2</sub></span></td><td style="text-align: center;">100</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">300</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>s</em><sub>2</sub></span></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">100</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>s</em><sub>3</sub></span></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">250</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>z</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;">100</td><td style="text-align: center;">100</td><td style="text-align: center;">100</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>σ</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;">-50</td><td style="text-align: center;">0</td><td style="text-align: center;">-100</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><span class="math inline"><em>x</em><sub>2</sub></span>对应的<spanclass="math inline"><em>C</em><sub><em>B</em></sub></span>就是第一次的<spanclass="math inline"><em>σ</em><sub><em>j</em></sub></span>。</p><p>要把基变量其他行中的<spanclass="math inline"><em>x</em><sub>2</sub></span>消除，现在的<spanclass="math inline"><em>x</em><sub>2</sub></span>行是<spanclass="math inline"><em>x</em><sub>1</sub> + <em>x</em><sub>2</sub> + <em>s</em><sub>1</sub> = 300</span>，对于<spanclass="math inline"><em>s</em><sub>2</sub></span>行，消去<spanclass="math inline"><em>x</em><sub>2</sub></span>就变成<spanclass="math inline"><em>x</em><sub>1</sub> − <em>s</em><sub>1</sub> + <em>s</em><sub>2</sub> = 100</span>，其他行同理。</p><p>当前没有正的检验数可以带来增益，即当前为最优解。</p><p>因为此时<spanclass="math inline"><em>x</em><sub>1</sub></span>，<spanclass="math inline"><em>s</em><sub>1</sub></span>为非基变量，所以<spanclass="math inline"><em>x</em><sub>1</sub><sup>*</sup></span>=0，<spanclass="math inline"><em>s</em><sub>1</sub></span>=0，由<spanclass="math inline"><em>x</em><sub>1</sub> + <em>x</em><sub>2</sub> + <em>s</em><sub>1</sub> = 300</span>可以得出<spanclass="math inline"><em>x</em><sub>2</sub><sup>*</sup></span>=300，即最优解<spanclass="math inline"><em>x</em><sub>1</sub><sup>*</sup></span>=0，<spanclass="math inline"><em>x</em><sub>2</sub><sup>*</sup></span>=300，带入<spanclass="math inline"><em>z</em></span>=30000。</p><p> </p><p>引入的剩余/松弛变量无法构成一个单位矩阵的时候，为了获得单位矩阵，引入人工变量，采用大M法/两阶段法。</p><h3 id="大m法">大M法</h3><p>思路：当把人工变量从基变量中替换出来成为非基变量，剔除人工变量的剩余部分即为原问题的初始基本可行解。以后的计算与单纯形表解法相同，Ｍ只需认定是一个很大的正数即可。</p><p>示例： <span class="math display">$$\max \quad z = 2x_1 + 3x_2 - 5x_3\\\text{s.t.} \quad\begin{cases}x_1 + x_2 + x_3 = 7 \\2x_1 - 5x_2 + x_3 \geq 10 \\x_i \geq 0, \quad i = 1,2,3\end{cases}$$</span></p><blockquote><p>因为只引入一个剩余变量<spanclass="math inline"><em>x</em><sub>4</sub></span>的时候初始基变量一个都没有，所以需要引入人工变量，在大M法中引入的<spanclass="math inline"><em>x</em><sub>5</sub></span>，<spanclass="math inline"><em>x</em><sub>6</sub></span>视为一个无限大的正数。</p></blockquote><p><span class="math display">$$\max \quad z = 2x_1 + 3x_2 - 5x_3 - Mx_5 - Mx_6\\\text{s.t.} \quad\begin{cases}x_1 + x_2 + x_3 + x_5 = 7 \\2x_1 - 5x_2 + x_3 - x_4 + x_6 = 10 \\x_i \geq 0, \quad i = 1,2,3,4,5,6\end{cases}$$</span></p><table><thead><tr><th style="text-align: center;">迭代次数</th><th style="text-align: center;">基变量</th><th style="text-align: center;"><spanclass="math inline"><em>C</em><sub><em>i</em></sub></span></th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>1</sub></span><br>2</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>2</sub></span><br>3</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>3</sub></span><br>-5</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>4</sub></span><br>0</th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>5</sub></span><br><spanclass="math inline">−<em>M</em></span></th><th style="text-align: center;"><spanclass="math inline"><em>x</em><sub>6</sub></span><br><spanclass="math inline">−<em>M</em></span></th><th style="text-align: center;"><spanclass="math inline"><em>b</em></span></th><th style="text-align: center;">比值<br><spanclass="math inline">$\frac{b_i}{a_{i2}}$</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline"><em>x</em><sub>5</sub></span></td><td style="text-align: center;"><spanclass="math inline">−<em>M</em></span></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td><td style="text-align: center;"><spanclass="math inline">$\frac{7}{1}$</span></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>x</em><sub>6</sub></span></td><td style="text-align: center;"><spanclass="math inline">−<em>M</em></span></td><td style="text-align: center;">2</td><td style="text-align: center;">-5</td><td style="text-align: center;">1</td><td style="text-align: center;">-1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">10</td><td style="text-align: center;"><spanclass="math inline">$\frac{10}{2}$</span></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>z</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">−3<em>M</em></span></td><td style="text-align: center;"><spanclass="math inline">4<em>M</em></span></td><td style="text-align: center;"><spanclass="math inline">−2<em>M</em></span></td><td style="text-align: center;"><spanclass="math inline"><em>M</em></span></td><td style="text-align: center;"><spanclass="math inline">−<em>M</em></span></td><td style="text-align: center;"><spanclass="math inline">−<em>M</em></span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline"><em>σ</em><sub><em>j</em></sub></span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">3<em>M</em> + 2</span></td><td style="text-align: center;"><spanclass="math inline">−4<em>M</em> + 3</span></td><td style="text-align: center;"><spanclass="math inline">2<em>M</em> − 5</span></td><td style="text-align: center;"><spanclass="math inline">−<em>M</em></span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>最大的<spanclass="math inline"><em>σ</em><sub><em>j</em></sub></span>为<spanclass="math inline"><em>x</em><sub>1</sub></span>，换入<spanclass="math inline"><em>x</em><sub>1</sub></span>，计算比值…下面迭代按照单纯形法求解。</p><h3 id="两阶段法">两阶段法</h3><p>步骤：</p><ul><li><p>求解一个辅助线性规划</p><blockquote><p>目标函数取所有人工变量之和，并取最小化。</p><p>约束条件为原问题中引入人工变量后包含一个单位矩阵的标准型的约束条件。</p></blockquote></li><li><p>求原问题的最优解，在第一阶段已经求得原问题的一个初始基本可行解的基础上，继续用单纯形法求解原问题的最优解。</p></li></ul><hr /><p>内点算法可以降低单纯形法的复杂度。</p><p> </p><p> </p><h1 id="第四章-整数规划">第四章 整数规划</h1><p>定义：如果一个线性规划模型中的部分/全部的决策变量<spanclass="math inline"><em>x</em><sub><em>i</em></sub></span>取整数值，则称该线性规划模型为<strong>整数线性规划模型</strong>。</p><p>类型：纯整数规划/混合整数规划/0-1整数规划</p><h2 id="模型求解">模型求解</h2><h3 id="分支定界法">分支定界法</h3><p>在整数规划中，找到实际的整数解通常是困难的，因此我们首先求解其松弛问题，这样我们可以得到一个对原整数问题的最优解的估计。</p><p>松弛问题得到上界，分解问题得到下界，依据某个算法得到上/下界的序列，逐步缩小/放大上/下界。</p><p>求最优解：</p><p>1、若松弛问题无可行解，则整数规划无可行解；</p><p>2、若松弛问题最优解符合整数，则为整数规划最优解；</p><p>3、不符合整数，设最优值为<spanclass="math inline"><em>z̄</em></span>，初始定界，分枝，更新定界，比较和剪枝，重复直到无解或有最优解。</p><p>示例： <span class="math display">$$\begin{aligned}\max \quad &amp; z = 40x_1 + 90x_2 \\\text{s.t.} \quad &amp;\begin{cases}9x_1 + 7x_2 \leq 56 \\7x_1 + 20x_2 \leq 70 \\x_1, x_2 \geq 0,\ \text{且为整数}\end{cases}\end{aligned}$$</span> 1、化解为松弛问题： <span class="math display">$$\begin{aligned}\max \quad &amp; z = 40x_1 + 90x_2 \\\text{s.t.} \quad &amp;\begin{cases}9x_1 + 7x_2 \leq 56 \\7x_1 + 20x_2 \leq 70 \\x_1, x_2 \geq 0\end{cases}\end{aligned}$$</span> 2、使用单纯形法求解松弛问题： <span class="math display">$$\begin{aligned}\max \quad &amp; z = 40x_1 + 90x_2 \\\text{s.t.} \quad &amp;\begin{cases}9x_1 + 7x_2 +x_3= 56 \\7x_1 + 20x_2 +x_4= 70 \\x_1, x_2 \geq 0\end{cases}\end{aligned}$$</span> 解得： <span class="math display">$$\begin{cases}x_1 = \dfrac{630}{131} \\x_2 = \dfrac{238}{131}\end{cases}$$</span></p><p><span class="math display">$$\max z = \frac{46620}{131}$$</span></p><p>3、分支定界：</p><p>定界：<spanclass="math inline">$\bar{z}=\frac{46620}{131}$</span>，<spanclass="math inline">$\underline{z}=0$</span>，<spanclass="math inline">$\underline{z}\leq z^*\leq \bar{z}$</span></p><p>分支：<span class="math inline">$x_1 \leq \left\lfloor\frac{630}{131} \right\rfloor = 4$</span>和<spanclass="math inline">$x_1 \geq \left\lfloor \frac{630}{131}\right\rfloor+1 = 5$</span></p><blockquote><p>这个<spanclass="math inline">$\frac{630}{131}$</span>，可以任选一个不为整数<spanclass="math inline"><em>x</em></span>来分支。</p></blockquote><ul><li>分支1</li></ul><p><span class="math display">$$\begin{aligned}\max \quad &amp; z = 40x_1 + 90x_2 \\\text{s.t.} \quad &amp;\begin{cases}9x_1 + 7x_2 \leq 56 \\7x_1 + 20x_2 \leq 70 \\x_1 \leq 4 \\x_1, x_2 \geq 0\end{cases}\end{aligned}$$</span></p><p>解得： <span class="math display">$$\begin{cases}x_1 = 4 \\x_2 = 2.1\end{cases}$$</span></p><p><span class="math display">max <em>z</em> = 349</span></p><p>定界：<span class="math inline"><em>z̄</em> = 349</span>，<spanclass="math inline">$\underline{z}=0$</span>，<spanclass="math inline">$\underline{z}\leq z^*\leq \bar{z}$</span></p><ul><li>分支2</li></ul><p><span class="math display">$$\begin{aligned}\max \quad &amp; z = 40x_1 + 90x_2 \\\text{s.t.} \quad &amp;\begin{cases}9x_1 + 7x_2 \leq 56 \\7x_1 + 20x_2 \leq 70 \\x_1 \geq 5 \\x_1, x_2 \geq 0\end{cases}\end{aligned}$$</span></p><p>解得： <span class="math display">$$\begin{cases}x_1 = 5 \\x_2 = 1.57\end{cases}$$</span></p><p><span class="math display">max <em>z</em> = 341.4</span></p><p>更新定界：<span class="math inline"><em>z̄</em> = 341.4</span>，<spanclass="math inline">$\underline{z}=0$</span>，<spanclass="math inline">$\underline{z}\leq z^*\leq \bar{z}$</span></p><hr /><p>分支1：<spanclass="math inline"><em>x</em><sub>2</sub> ≤ ⌊2.1⌋ = 2</span>，<spanclass="math inline"><em>x</em><sub>2</sub> ≥ ⌊2.1⌋ + 1 = 3</span></p><ul><li>分支1.1</li></ul><p>解得 <span class="math display">$$\begin{cases}x_1 = 4 \\x_2 = 2\end{cases}$$</span></p><p><span class="math display">max <em>z</em> = 340</span></p><p>更新定界为：<spanclass="math inline"><em>z̄</em> = 341.4</span>，<spanclass="math inline">$\underline{z}=340$</span>，<spanclass="math inline">$\underline{z}\leq z^*\leq \bar{z}$</span></p><blockquote><p>因为两个解都符合整数条件，所以此时更新的是下界。</p></blockquote><ul><li>分支1.2</li></ul><p>解得 <span class="math display">$$\begin{cases}x_1 = 1.43 \\x_2 = 3\end{cases}$$</span></p><p><span class="math display">max <em>z</em> = 327.4</span></p><p><strong>剪枝</strong>，因为<spanclass="math inline">327.4 &lt; 340</span></p><p>重复分支定界法。</p><hr /><p>最终求得最终解为 <span class="math display">$$\begin{cases}x_1 = 4 \\x_2 = 2\end{cases}$$</span></p><p><span class="math display">max <em>z</em> = 340</span></p><p> </p><h3 id="割平面法">割平面法</h3><p>当问题涉及到大量的整数变量或二进制变量时，基本思想是通过逐步引入限制条件（割平面）来逐渐逼近问题的整数解，从而提高解的质量。</p><p>也是结合单纯形法，当求得一个非整数最优解的时候，写出当前基变量所在行的约束等式，构造切割方程，再带入求解。</p><p> </p><h1 id="第五章-图论建模与应用">第五章 图论建模与应用</h1><h2 id="图论与应用问题建模概念">图论与应用问题建模概念</h2><p>研究图和线组成的“图形”问题，例如哥尼斯堡七桥，哈密尔顿回路，四色定理。</p><p>应用：随机图论、网络图论、代数图论、 拓扑图论、极值图论。</p><p><strong>图</strong></p><p>概念：描述事物或对象之间联系或相互作用状态，由若干个给定的顶点、及若干条连接两个顶点的边所构成的图形。<spanclass="math inline"> &lt; <em>V</em>, <em>E</em>&gt;</span>表示，<spanclass="math inline">|<em>V</em>|</span>表示顶点集合，<spanclass="math inline">|<em>E</em>|</span>表示边集合。</p><p>分类：</p><ul><li><p>无向/有向图：每条边都是无向/有向边。</p><blockquote><p>有向边也叫弧</p></blockquote></li><li><p>简单图：既不含平行边也不含环的图</p><blockquote><p>平行边：关联的一对顶点的边多于1条。</p></blockquote></li><li><p>赋权图：每条边都附有一个实数（权）</p><blockquote><p>记作<spanclass="math inline"><em>G</em> = (<em>V</em>, <em>E</em>, <em>W</em>)</span></p></blockquote></li></ul><p><strong>度</strong></p><ul><li><p>无向图中，与顶点<spanclass="math inline"><em>v</em></span>关联的边的数目（环算两个）称为<spanclass="math inline"><em>v</em></span>的度，记作<spanclass="math inline"><em>d</em>(<em>v</em>)</span></p><blockquote><p>无向图中所有顶点的度数之和是边数的两倍</p></blockquote></li><li><p>有向图中，从<spanclass="math inline"><em>v</em></span>引出的度为出度<spanclass="math inline"><em>d</em><sup>+</sup>(<em>v</em>)</span>，对应入度<spanclass="math inline"><em>d</em><sup>−</sup>(<em>v</em>)</span>，<spanclass="math inline"><em>d</em>(<em>v</em>) = <em>d</em><sup>+</sup>(<em>v</em>) + <em>d</em><sup>−</sup>(<em>v</em>)</span></p><blockquote><p>有向图中也满足，同时所有顶点的入读之和等于所有顶点的出度之和，都为边数。</p></blockquote></li></ul><p>推论：任何图的奇顶点的总数必定为偶数。</p><p><strong>道路</strong></p><ul><li><p>迹：各边相异的道路</p></li><li><p>轨道：各顶点相异的道路，记为<spanclass="math inline"><em>P</em>(<em>v</em><sub>0</sub>, <em>v</em><sub><em>k</em></sub>)</span></p></li><li><p>回路：起点和终点重合的道路。</p><blockquote><p>圈：起点和终点重合的轨道，根据长度有奇/偶圈。</p><p>距离：<span class="math inline"><em>u</em></span>和<spanclass="math inline"><em>v</em></span>的最短轨道之长</p></blockquote></li></ul><p><strong>矩阵表示</strong></p><ul><li>邻接矩阵</li></ul><p><span class="math display">$$w_{ij} =\begin{cases}1, &amp; \text{顶点 } v_i \text{ 与 } v_j \text{ 有边} \\0, &amp; i = j \text{ 或顶点 } v_i \text{ 与 } v_j \text{ 无边}\end{cases}$$</span></p><p>当为赋权图的时候，1变成边的权。</p><ul><li>关联矩阵</li></ul><p><span class="math display">$$m_{ij} =\begin{cases}+1, &amp; \text{顶点 } v_i \text{ 与边 } e_j \text{ 关联} \\0,  &amp; \text{顶点 } v_i \text{ 与边 } e_j \text{ 不关联}\end{cases}$$</span></p><blockquote><p>环算两个</p></blockquote><p>当为有向图的时候， <span class="math display">$$m_{ij} =\begin{cases}1, &amp; \text{顶点 } v_i \text{ 是弧 } a_j \text{ 的} {\text{始端}} \\-1, &amp; \text{顶点 } v_i \text{ 是弧 } a_j \text{ 的} {\text{末端}} \\0, &amp; \text{顶点 } v_i \text{ 与弧 } a_j \text{ 不关联}\end{cases}$$</span></p><ul><li>可达矩阵（有向图）</li></ul><p><span class="math display">$$P_{ij} =\begin{cases}1, &amp; v_i \text{ 可达 } v_j \\0, &amp; \text{否则}\end{cases}$$</span></p><p> </p><h2 id="最大流问题">最大流问题</h2><p>城市视为顶点，管道视为边，容量视为权，输送线路抽象成一个有向赋权图<spanclass="math inline"><em>G</em>(<em>V</em>, <em>E</em>, <em>C</em>)</span>。</p><blockquote><p>同时要记录实际流量<spanclass="math inline"><em>f</em>(<em>u</em>, <em>v</em>)</span>（小于容量<spanclass="math inline"><em>c</em>(<em>u</em>, <em>v</em>)</span>）</p></blockquote><p><strong>弧的类型</strong></p><ul><li>饱和弧：<spanclass="math inline"><em>f</em>(<em>𝑢</em>, <em>𝑣</em>) = <em>c</em>(<em>𝑢</em>, <em>𝑣</em>)</span></li><li>非饱和弧：<spanclass="math inline"><em>f</em>(<em>𝑢</em>, <em>𝑣</em>) &lt; <em>c</em>(<em>𝑢</em>, <em>𝑣</em>)</span></li><li>零流弧：<spanclass="math inline"><em>f</em>(<em>𝑢</em>, <em>𝑣</em>) = 0</span></li><li>非零流弧：<spanclass="math inline"><em>f</em>(<em>𝑢</em>, <em>𝑣</em>) &gt; 0</span></li></ul><p><strong>链</strong></p><p>容量网络<span class="math inline"><em>G</em></span>中顶点序列<spanclass="math inline">(<em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ..., <em>u</em><sub><em>n</em></sub>, <em>v</em>)</span>为一条链，要求相邻两个顶点之间有一条弧，从起点<spanclass="math inline"><em>s</em></span>到终点<spanclass="math inline"><em>t</em></span>为正方向。</p><blockquote><p>前向弧：和链的方向一致的弧，记为<spanclass="math inline"><em>P</em><sup>+</sup></span></p><p>反向弧：和链的方向相反的弧，记为<spanclass="math inline"><em>P</em><sup>−</sup></span></p></blockquote><p><strong>增广路径</strong></p><p>设<span class="math inline"><em>𝑓</em></span>是一个容量网络<spanclass="math inline"><em>𝐺</em></span>中的一个可行流，<spanclass="math inline"><em>𝑃</em></span>是从<spanclass="math inline"><em>𝑠</em></span>到<spanclass="math inline"><em>𝑡</em></span>的一条链，若<spanclass="math inline"><em>𝑃</em></span>满足下列条件：</p><p>（1）在𝑃的所有前向弧<spanclass="math inline"> &lt; <em>𝑢</em>, <em>𝑣</em>&gt;</span>上，<spanclass="math inline">0 ≤ <em>𝑓</em>(<em>𝑢</em>, <em>𝑣</em>) &lt; <em>𝑐</em>(<em>𝑢</em>, <em>𝑣</em>)</span>，即𝑃中每一条弧都是非饱和弧；</p><p>（2）在𝑃的所有后向弧<spanclass="math inline"> &lt; <em>𝑢</em>, <em>𝑣</em>&gt;</span>上，<spanclass="math inline">0 &lt; <em>𝑓</em>(<em>𝑢</em>, <em>𝑣</em>) ≤ <em>𝑐</em>(<em>𝑢</em>, <em>𝑣</em>)</span>，即𝑃中每一条弧都是非零流弧。</p><p>则称<span class="math inline"><em>P</em></span>为增广路径。</p><p>增广路算法：从任何一个可行流开始，沿着增广路径对网络流进行增广，直到网络中不存在增广路为止。</p><p><strong>Ford-Fulkerson算法</strong></p><p>广度优先搜索</p><figure><img src="5.1.png" alt="示例" /><figcaption aria-hidden="true">示例</figcaption></figure><figure><img src="5.2.png" alt="初次流网络和残差网络" /><figcaption aria-hidden="true">初次流网络和残差网络</figcaption></figure><figure><img src="5.3.png" alt="初次找寻增广路径" /><figcaption aria-hidden="true">初次找寻增广路径</figcaption></figure><figure><img src="5.4.png" alt="第二次流网络和残差网络" /><figcaption aria-hidden="true">第二次流网络和残差网络</figcaption></figure><p>不断寻找增广路径，直到不存在，无法增加流量为止。</p><p>Edmonds-Karp算法</p><p>Dinic算法：深度优先搜索、剪枝</p><p>预流推进算法</p><h2 id="最小割问题">最小割问题</h2><p>割：在容量网络<spanclass="math inline"><em>𝐺</em>(<em>𝑉</em>, <em>𝐸</em>)</span>中，设<spanclass="math inline"><em>𝐸</em>’ ⊆ <em>𝐸</em></span>，如果在<spanclass="math inline"><em>𝐺</em></span>中删去<spanclass="math inline"><em>𝐸</em>’</span>后不再连通，则 称<spanclass="math inline"><em>𝐸</em>’</span>是<spanclass="math inline"><em>𝐺</em></span>的割。割将<spanclass="math inline"><em>𝐺</em></span>的顶点集𝑉划分成两个子集<spanclass="math inline"><em>𝑆</em></span>和<spanclass="math inline"><em>𝑇</em></span>，将割记为<spanclass="math inline">(<em>𝑆</em>, <em>𝑇</em>)</span>。</p><blockquote><p>如果割所划分的两个顶点子集满足<spanclass="math inline"><em>s</em> ∈ <em>S</em></span>，<spanclass="math inline"><em>t</em> ∈ <em>T</em></span>，则为<spanclass="math inline"><em>S</em> − <em>T</em></span>割。</p></blockquote><p>横跨：弧<spanclass="math inline"> &lt; <em>u</em>, <em>v</em>&gt;</span>，其中<spanclass="math inline"><em>u</em> ∈ <em>S</em>, <em>v</em> ∈ <em>T</em></span>。这个弧就横跨割。</p><p><spanclass="math inline"><em>S</em> − <em>T</em><em>图</em></span>：</p><ul><li>一个源点和一个汇点</li><li>每条边都有一个非负的权值</li><li>容量<spanclass="math inline"><em>c</em>(<em>u</em>, <em>v</em>)</span>等于0，说明不存在边</li></ul><p>割的容量：<spanclass="math inline">(<em>S</em>, <em>T</em>)</span>为<spanclass="math inline"><em>G</em>(<em>V</em>, <em>E</em>)</span>的一个割，容量为所有前向弧的容量的总和，最小割即为容量最小的割。</p><blockquote><p>统计容量的时候，不统计反向弧的容量。</p></blockquote><p><strong>最大流的流值<spanclass="math inline">≤</span>最小割的容量</strong></p><p>净流量：<spanclass="math inline"><em>f</em>(<em>S</em>, <em>T</em>)</span>，统计净流量的时候，反向弧是负值。</p><p>网络流：网络流的流量等于任何割的净流量，小于等于任何割的容量。</p><p>最大流最小割定理：对于容量网络<spanclass="math inline"><em>G</em>(<em>V</em>, <em>E</em>)</span>，其最大流的流量等于最小割的容量。</p><p>对偶问题：求最小割的容量就转化为求最大流的流量，求边或者子集的时候，在最大流的时候，从顶点<spanclass="math inline"><em>s</em></span>出发，如果<spanclass="math inline">0 &lt; <em>f</em>(<em>u</em>, <em>v</em>) &lt; <em>c</em>(<em>u</em>, <em>v</em>)</span>，就把这个边加入割，可达的顶点加入<spanclass="math inline"><em>S</em></span>，最后没加入的其他顶点加入<spanclass="math inline"><em>T</em></span>。</p><p> </p><p> </p><h1 id="第六章-进化算法与应用">第六章 进化算法与应用</h1>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海游记</title>
    <link href="/travel_SH/"/>
    <url>/travel_SH/</url>
    
    <content type="html"><![CDATA[<p>22号农历八月初一的生日，刚好朋友来上海面试，和朋友到这里提前过国庆，顺便过个生日游玩一下。</p><h1 id="豫园">豫园</h1><p>来上海第一感觉是外国人真的很多，大街上到处可见，不愧是中国第一大国际化都市。尤其是旅游景点，各国的游客都来拜访这里，豫园挺大的，绕着走也得走很一会，但人流大了显得有点逼仄，景色优美，很多假山假石，环境很清新，算是工业化城市中难得的原始景色了，听说傍晚来这里景色更好。</p><figure><img src="yuyuan01.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan02.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan03.png" alt="豫园外" /><figcaption aria-hidden="true">豫园外</figcaption></figure><p>周一不开门，门票可以提前预约。</p><p>——2025/9/21 周日</p><p> </p><h1 id="城隍庙">城隍庙</h1><p>城隍庙离豫园非常近，拜佛的地方，进去就是大殿，旁边也有月老殿、财神殿等，进去可以拿香火上香，来这里知道了上香要用左手在前右手在后。</p><figure><img src="chenghuangmiao01.png" alt="城隍庙大门" /><figcaption aria-hidden="true">城隍庙大门</figcaption></figure><figure><img src="chenghuangmiao02.png" alt="城隍庙出口" /><figcaption aria-hidden="true">城隍庙出口</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="裕兴记">裕兴记</h1><p>苏州风味的蟹黄面，118/碗，感觉有点贵，口味一般般吧，但是面料感觉挺不错的，带有小料、生姜汤和枸杞茶，如果只是作为高档的那种早餐应该还不错。</p><figure><img src="yuxingji.png" alt="蟹黄面" /><figcaption aria-hidden="true">蟹黄面</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="鸟醺烧鸟居酒屋">鸟醺烧鸟居酒屋</h1><p>日料，点了爆黄喉，棒棒鸡，牛肉乌冬和拉面，还有附赠的可尔必思和鸡腿肉，还有餐后的烤菠萝和冰淇淋，感觉还不错，至少口味和酱料这方面跟我之前吃过的日料还是不一样，有点独特的感觉，也很平价，环境专门布置成日风，服务周到，应该算没有踩到坑（笑）。</p><figure><img src="niaoxun01.png" alt="菜品" /><figcaption aria-hidden="true">菜品</figcaption></figure><figure><img src="niaoxun02.png" alt="环境" /><figcaption aria-hidden="true">环境</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="百联zx">百联ZX</h1><p>魔都二次元的必经之地！很多专卖店，各种热门甚至一些比较冷门的IP谷子都有，从小徽章，亚克力牌到玩偶，手办等，很有氛围，六层逛个爽，这里也全是同好，进来感觉浓浓的异次元感啊！顺便帮朋友代购了点火影的谷子（以后我有钱了也要来这里买手办！）</p><figure><img src="bailian01.png" alt="热门IP墙" /><figcaption aria-hidden="true">热门IP墙</figcaption></figure><figure><img src="bailian02.png" alt="玩偶" /><figcaption aria-hidden="true">玩偶</figcaption></figure><figure><img src="bailian03.png" alt="东映动画" /><figcaption aria-hidden="true">东映动画</figcaption></figure><figure><img src="bailian04.png" alt="一乐拉面" /><figcaption aria-hidden="true">一乐拉面</figcaption></figure><figure><img src="bailian05.png" alt="卡卡西" /><figcaption aria-hidden="true">卡卡西</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="静安大悦城">静安大悦城</h1><p>这里主要还是商城，但是北座的6F还是8F有一些谷子店，潮玩星球之类的，有个书店很大，里面各种漫画都有，包括很冷门的IP！这应该是相对于百联的优势了，但是二次元的店家很少，就一层之中的几个店吧，专营店址类的也不多。</p><figure><img src="dayuecheng01.png" alt="各种漫画" /><figcaption aria-hidden="true">各种漫画</figcaption></figure><figure><img src="dayuecheng02.png" alt="JOJO" /><figcaption aria-hidden="true">JOJO</figcaption></figure><figure><img src="dayuecheng03.png" alt="排着特别长的队，好像是hellokitty" /><figcaptionaria-hidden="true">排着特别长的队，好像是hellokitty</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="南京路">南京路</h1><p>人是真的多！尽管是周末非假期晚上，各地的游客都是多如牛毛的，两侧是建筑风格很有历史感的高级奢饰品店，感受氛围系列。</p><figure><img src="nanjinglu01.png" alt="南京路中" /><figcaption aria-hidden="true">南京路中</figcaption></figure><figure><img src="nanjinglu02.png" alt="接近外滩" /><figcaption aria-hidden="true">接近外滩</figcaption></figure><figure><img src="nanjinglu03.png" alt="和平饭店" /><figcaption aria-hidden="true">和平饭店</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="上海博物馆东馆">上海博物馆东馆</h1><p>有很多层，从青铜器，玉器到陶瓷等，每一层都很大要逛很久，挺累的，对历史感兴趣的话这里应该很好玩。</p><figure><img src="shangbo01.png" alt="外面" /><figcaption aria-hidden="true">外面</figcaption></figure><figure><img src="shangbo02.png" alt="一楼青铜馆" /><figcaption aria-hidden="true">一楼青铜馆</figcaption></figure><figure><img src="shangbo03.png" alt="玉如意" /><figcaption aria-hidden="true">玉如意</figcaption></figure><figure><img src="shangbo04.png" alt="青铜剑" /><figcaption aria-hidden="true">青铜剑</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="东方明珠">东方明珠</h1><p>在陆家嘴桥上看的，这里拍照打卡的人很多，视角还不错，上去逛好像要￥199，下次再来！</p><p><img src="dongfang01.png" /></p><p><img src="dongfang02.png" /></p><p><img src="dongfang03.png" /></p><p>——2025/9/22 周一</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>上海</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>上海</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毗卢寺/鸡鸣寺游记</title>
    <link href="/travel_JM/"/>
    <url>/travel_JM/</url>
    
    <content type="html"><![CDATA[<p>今天天气不错，想着去逛了毗卢寺和鸡鸣寺，拜一拜也帮朋友求一下，都离学校不算很远，走一走。</p><h1 id="毗卢寺">毗卢寺</h1><p>这里还是比较偏的，人流很少。</p><figure><img src="house.png" alt="河边豪斯" /><figcaption aria-hidden="true">河边豪斯</figcaption></figure><p>路过的河边看到的小豪斯，有小河有花园，住起来应该很舒服。</p><figure><img src="door01.png" alt="毗卢寺侧门" /><figcaption aria-hidden="true">毗卢寺侧门</figcaption></figure><p>旁边是小学，对门是医院，这附近环境非常安静，很适合休闲散心。</p><figure><img src="mainHall01.png" alt="大殿总览" /><figcaption aria-hidden="true">大殿总览</figcaption></figure><p>布局简单，大概是正殿和两个偏殿，左侧还有一个鼓楼，正殿对着的是烧香的地方。</p><figure><img src="mainHall02.png" alt="大殿" /><figcaption aria-hidden="true">大殿</figcaption></figure><figure><img src="statue01.png" alt="弥勒佛" /><figcaption aria-hidden="true">弥勒佛</figcaption></figure><figure><img src="statue02.png" alt="金刚" /><figcaption aria-hidden="true">金刚</figcaption></figure><figure><img src="statue03.png" alt="释迦牟尼佛" /><figcaption aria-hidden="true">释迦牟尼佛</figcaption></figure><p>供奉的是弥勒佛和释加牟尼，背面也有一个不知道是菩萨还是什么的。</p><p>门票￥10，上香免费，出来的时候有几个找你算手相算命的，有钱的可以试试。</p><p>——2025/9/11周四</p><p> </p><h1 id="鸡鸣寺">鸡鸣寺</h1><p>南朝四百八十寺之首，南京旅游地标性建筑。</p><figure><img src="jiming01.png" alt="25年3月" /><figcaption aria-hidden="true">25年3月</figcaption></figure><figure><img src="jiming02.png" alt="9月" /><figcaption aria-hidden="true">9月</figcaption></figure><p>三月晚上去看过一次樱花，物是人非事事休。</p><figure><img src="hall01.png" alt="昆仑宝殿" /><figcaption aria-hidden="true">昆仑宝殿</figcaption></figure><p>进去应该是比较先看到的，结构是环形+向上的感觉，有一点绕，出口在入口右手边，很多殿林立，感觉里面建筑学很高深。</p><figure><img src="tower01.png" alt="药师佛塔" /><figcaption aria-hidden="true">药师佛塔</figcaption></figure><p>供奉的是药师佛/药师如来。</p><p>春山撩乱水纵横，篱落荒畦草自生。 独往独来山下路，笋舆看得绿阴成。</p><p>——王安石《台城寺侧独行》</p><figure><img src="hall02.png" alt="藏经阁/法堂" /><figcaption aria-hidden="true">藏经阁/法堂</figcaption></figure><p>药师佛塔之后，顺时针绕。</p><figure><img src="roof.png" alt="屋顶" /><figcaption aria-hidden="true">屋顶</figcaption></figure><p>进上香广场的楼梯处。</p><figure><img src="tower02.png" alt="寺里最高的塔" /><figcaption aria-hidden="true">寺里最高的塔</figcaption></figure><p>在上香的最高的广场点即可看到。</p><p>门票￥10，上香免费，很大，人也比较多。</p><p>——2025/9/11周四</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>南京</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>南京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/os/"/>
    <url>/os/</url>
    
    <content type="html"><![CDATA[<h1 id="线程多开的弊端">线程多开的弊端</h1><p>1、系统资源消耗过大</p><ul><li>内存开销：每个线程需要独立的线程栈（几百 KB 到数MB），线程数多了会占用大量内存。</li><li>句柄/内核对象消耗：OS维护线程管理信息（TCB，线程控制块），也是负担。</li></ul><p>2、频繁上下文切换</p><ul><li>CPU可能一直在进行多线程切换而非执行实际任务，性能反而降低。</li></ul><p>3、线程调度开销增加</p><ul><li>线程调度器要在大量线程中决定调度，调度队列变长，增加调度延迟。</li></ul><p>4、竞争和同步问题</p><ul><li>多线程共享内存时，访问同一资源产生竞争，增加死锁，活锁等风险。</li></ul><p>5、缓存一致性和CPU亲和性问题</p><ul><li>如果线程频繁切换核，可能导致缓存失效，增加内存访问延迟。</li></ul><p>6、程序稳定性风险</p><ul><li>线程数超过系统支持的最大值可能导致线程创建失败或者系统卡顿甚至崩溃。</li></ul><p>改善：</p><ul><li>采用线程池：用固定数量线程复用，避免无限创建。</li><li>异步/事件驱动模型：在 I/O 密集型任务中，比开很多线程更高效。</li><li>限制线程数：一般根据 CPU核心数 和 任务性质（CPU 密集 or I/O密集）来决定线程数量。</li></ul><p> </p><h1 id="simd">SIMD</h1><p>单指令多数据</p><p>一种并行计算方式，允许处理器用一条指令同时对多个数据元素进行操作。</p><p>最常见的CPU向量化技术，MIMD则是多核CPU的通用并行方式。</p><p>实现方式：</p><ul><li>寄存器向量化：CPU有专门的向量寄存器（如Intel AVX，SSE）：<ul><li>SSE：128b向量寄存器</li><li>AVX：256b向量寄存器</li></ul></li><li>GPU并行：GPU本身就非常擅长SIMD计算，每个线程执行相同指令，处理不同数据。</li></ul><p>优点：</p><ul><li>提升速度</li><li>降低功耗</li><li>适合向量化任务：图像滤波，矩阵运算，信号处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/java/"/>
    <url>/java/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构">JVM内存结构</h1><p>JVM 执行 Java程序时会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途、创建和销毁时间。</p><p>1、程序计数器（Program Counter Register）</p><p>当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>特点：</p><ul><li><p>线程私有：每条线程有个独立的PCR，互不影响，独立存储。</p></li><li><p>如果正在执行Java方法，PCR的值为正在执行的JVM的字节码指令地址；如果是Native方法，值为空。</p></li><li><p>唯一一个没有<code>OutOfMemoryError</code>情况的区域</p></li></ul><p>2、Java虚拟机栈（Java Virtual Machine Stacks）</p><p>Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧 (StackFrame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到完成的过程，对应着一个栈帧在JVM栈中从入栈到出栈的过程。</p><p>特点：</p><ul><li>线程私有</li><li>存储内容：局部变量表，编译期可知的基本数据类型，对象引用类型和返回地址类型。</li><li>异常：<code>StackOverflowError</code>，<code>OutOfMemoryError</code></li></ul><p>3、本地方法栈（Native Method Stack）</p><p>与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行 Java方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>特点和虚拟机栈类似。</p><p>4、Java堆（Java Heap）</p><p>此内存区唯一的目的就是存放对象实例，基本在这里分配内存，通常所说的堆内存就是Java堆。</p><p>特点：</p><ul><li>线程共享：Java堆是虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。</li><li>GC 堆：Java 堆是垃圾收集器管理的主要区域，也被称为”GC堆“。</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>5、方法区（Method Area）</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>特点：</p><ul><li>线程共享</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>6、运行时常量池（Runtime Constant Pool）</p><p>方法区的一部分，常量池表 (Constant PoolTable)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的RCP中。</p><p>特点：</p><ul><li>动态性，并非预置入 Class文件常量池的内容才能进入RCP，运行期间也可能将新的常量放入池中。</li></ul><p>7、直接内存（Direct Memory）</p><p>并不是虚拟机运行时数据区的一部分，但也有可能导致<code>OutOfMemoryError</code>。</p><p> </p><p> </p><h1 id="java内存模型jmm">Java内存模型（JMM）</h1><p>抽象的概念，并不真实存在，核心目标是解决多线程环境下的三个问题：</p><ul><li>原子性：一个操作或多个操作要么全部执行成功，要么全部不执行。</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>规定了：</p><ul><li>所有的变量都在主存（MM）中</li><li>每条线程还有自己的工作内存（WM），WM中保存了被该线程使用到的变量的MM副本拷贝。</li><li>线程对变量的所有操作（读取、赋值等）都必须在WM中进行，而不能直接读写MM中的变量。</li><li>不同的线程之间也无法直接访问对方WM中的变量，线程间变量值的传递均需要通过MM来完成。</li></ul><p>当一个线程操作变量时，流程通常是：</p><ul><li>从MM中拷贝变量副本到WM</li><li>在WM中修改副本的值</li><li>在某个时间点，将WM的值刷新回MM</li></ul><p> </p><h2 id="volatile"><code>volatile</code></h2><p>轻量级同步机制，主要解决了可见性和有序性，不保证原子性，开销低，仅能修饰变量。</p><p>保证可见性：当一个变量<code>A</code>被声明为<code>volatile</code>后。</p><ul><li>写：对<code>A</code>的写操作会立刻强制刷新到MM。</li><li>读：对<code>A</code>的读操作会强制从MM中重新读取最新的值。</li></ul><p>保证有序性：通过插入内存屏障来禁止指令重排序。</p><ul><li>写：写之前的所有普通变量的写操作都完成并且已经刷新到MM。</li><li>读：读之后的所有后续普通变量的读/写操作都不会被重排序到该读操作之前。</li></ul><p>局限：不保证原子性，可以用<code>synchronized</code>保证原子性。</p><p> </p><p> </p><h1 id="java对象引用模式">JAVA对象引用模式</h1><p>Java的引用模式是其内存管理和对象访问的核心，Java通过引用来间接操作所有对象。</p><p>对象：堆内存中实际存在的数据实体，包含了其所属类的所有成员的变量的值。</p><p>引用：一个变量，其值是对象在堆内存中的地址，引用本身存储在栈内存或另一个对象中。</p><p>关键点：</p><ul><li><code>new</code>在堆上创建对象，并返回该对象的地址。</li><li><code>=</code>是复制地址值并非复制对象，多个引用指向同一个对象。</li><li><code>null</code>不指向任何对象。</li></ul><p>参数传递：</p><p>Java中只有按值传递，传递的是地址的副本，并非引用更不是对象。</p><p> </p><h1id="equals和的区别"><code>equals()</code>和<code>==</code>的区别</h1><table><thead><tr><th>特性</th><th><code>equlas</code></th><th><code>==</code></th></tr></thead><tbody><tr><td>本质</td><td>操作符</td><td>方法（定义在<code>Object</code>类中）</td></tr><tr><td>比较对象</td><td>内存地址</td><td>内容（需要重写，比如<code>String</code>,<code>Integer</code>）</td></tr><tr><td>比较基本类型</td><td>实际值</td><td>不能用于基本类型</td></tr><tr><td>是否可自定义</td><td>否</td><td>是</td></tr></tbody></table><p> </p><h1id="arraylist和linkedlist的区别"><code>ArrayList</code>和<code>LinkedList</code>的区别</h1><table><thead><tr><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr><td>底层数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr><td>获取元素</td><td>O(1)<br>支持随机访问</td><td>O(n)<br>从表头或者表尾开始遍历</td></tr><tr><td>插入/删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr><td>遍历效率</td><td>高</td><td>低</td></tr><tr><td>内存占用</td><td>小</td><td>大</td></tr><tr><td>应用场景</td><td>读多写少，绝大多数情况</td><td>写多读少，栈，队列等</td></tr></tbody></table><p> </p><h1 id="接口">接口</h1><p>一种抽象类型，定义类必须实现的方法的集合，但接口本身不能有方法的具体实现（Java8之后<code>default</code>和<code>static</code>可以实现），主要提供一种规范，使得不同类可以通过统一接口进行交互，而不关心具体实现。</p><p>实现接口：<code>implements</code></p><p>特点：</p><ul><li>多实现</li><li>解耦：减少类之间的耦合</li><li>多态：实现运行时多态</li></ul><p> </p><h1 id="函数覆写">函数覆写</h1><p>子类重新定义从父类继承而来的同名函数，以实现不同的功能。</p><p>要求：</p><ul><li>方法签名相同：函数名，参数个数、类型都必须相同。</li></ul><p><em># 参数列表必须完全相同，不一致则变成函数重载（overload）</em></p><ul><li>访问权限：子类方法的访问权限不能比父类更严格。</li><li>多态体现：当父类指针/引用调用函数时，会根据实际对象类型执行子类方法（支持虚函数/动态绑定）。</li></ul><p>关键字：<code>virtual</code>，<code>override</code></p><p> </p><h1 id="java泛型">Java泛型</h1><p>写一个类或者方法时，不指定具体的数据类型，而是用一个类型参数来代替，使用时再指定具体类型，减少强制类型转换的需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.<span class="built_in">setContent</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str = stringBox.<span class="built_in">getContent</span>(); <span class="comment">// 不需要强转</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.<span class="built_in">setContent</span>(<span class="number">123</span>);</span><br><span class="line">Integer num = intBox.<span class="built_in">getContent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意用于方法时，想返回这个Box，必须要类似public static &lt;T&gt; box&lt;T&gt; success(T data)</span></span><br><span class="line"><span class="comment">// 必须提前声明&lt;T&gt;，不然会报错。</span></span><br></pre></td></tr></table></figure><p>不止是类，还可以用于泛型接口，方法等。</p><p>优点：</p><ul><li>类型安全</li><li>减少强制转换</li><li>可读性强</li></ul><blockquote><p>不能用于基本类型</p></blockquote><p>常用场景：集成框架，工具类方法，通用对象封装。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ssh连接github失败</title>
    <link href="/sshBug/"/>
    <url>/sshBug/</url>
    
    <content type="html"><![CDATA[<p>先尝试<code>ssh -T git@github.com</code>。</p><p> </p><p>有可能是22端口被阻隔了，尝试443端口，在config中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com </span><br><span class="line">        Hostname ssh.github.com </span><br><span class="line">        Port 443</span><br><span class="line">        User git</span><br><span class="line">        ProxyCommand connect -S 系统代理地址 %h %p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/machineLearning/"/>
    <url>/machineLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><figure><img src="machineLearningProcess.png" alt="流程示例" /><figcaption aria-hidden="true">流程示例</figcaption></figure><figure><img src="mlClassfication.png" alt="类型" /><figcaption aria-hidden="true">类型</figcaption></figure><figure><img src="mlWork.png" alt="工作流" /><figcaption aria-hidden="true">工作流</figcaption></figure><p> </p><h1 id="神经网络">神经网络</h1><figure><img src="cnnBasic.png" alt="基础" /><figcaption aria-hidden="true">基础</figcaption></figure><p>神经元接收输入信号，通过加权求和后与偏置相加，然后通过激活函数处理以产生输出。神经元的权重和偏置是网络学习过程中需要调整的参数。</p><p> </p><h2 id="前馈神经网络">前馈神经网络</h2><figure><img src="fnn.png" alt="Feedforward Neural Network，FNN" /><figcaption aria-hidden="true">Feedforward NeuralNetwork，FNN</figcaption></figure><p>基本单元，前馈神经网络特点是数据从输入层开始，经过一个或多个隐藏层，最后到达输出层，全过程没有循环或反馈。</p><p> </p><h2 id="循环神经网络">循环神经网络</h2><figure><img src="rnn.png" alt="Recurrent Neural Network, RNN" /><figcaption aria-hidden="true">Recurrent Neural Network,RNN</figcaption></figure><p>专门处理序列数据的神经网络，能够捕获输入数据中时间或顺序信息的依赖关系,在自然语言处理（NLP）、语音识别、时间序列预测等任务中有着广泛的应用。</p><p>关键特性：其能够保持隐状态（hiddenstate），使得网络能够记住先前时间步的信息。</p><p>隐状态：通过上一时间步的隐状态和当前输入共同计算得到的。</p><p> 公式：<spanclass="math inline"><em>h</em><sub><em>t</em></sub> = <em>f</em>(<em>W</em><sub><em>h</em><em>h</em></sub><em>h</em><sub><em>t</em> − 1</sub> + <em>W</em><sub><em>x</em><em>h</em></sub><em>x</em><sub><em>t</em></sub> + <em>b</em><sub><em>h</em></sub>)</span></p><p><em># <spanclass="math inline"><em>h</em><sub><em>t</em></sub></span>：当前时刻隐状态；<spanclass="math inline"><em>h</em><sub><em>t</em> − 1</sub></span>：前一时刻隐状态；<spanclass="math inline"><em>W</em><sub><em>x</em><em>h</em></sub>, <em>W</em><sub><em>h</em><em>h</em></sub></span>：权重矩阵；<spanclass="math inline"><em>x</em><sub><em>t</em></sub></span>：当前时刻的输入；<spanclass="math inline"><em>b</em><sub><em>h</em></sub></span>：偏置；<spanclass="math inline"><em>f</em>()</span>：激活函数。</em></p><p>输出：不仅依赖当前输入，还依赖于隐状态的历史信息。</p><p> 公式：<spanclass="math inline"><em>y</em><sub><em>t</em></sub> = <em>W</em><sub><em>h</em><em>y</em></sub><em>h</em><sub><em>t</em></sub> + <em>b</em><sub><em>y</em></sub></span></p><p><em># <spanclass="math inline"><em>y</em><sub><em>t</em></sub></span>：t时刻的输出向量；<spanclass="math inline"><em>W</em><sub><em>h</em><em>y</em></sub></span>：隐状态到输出状态的矩阵。</em></p><figure><img src="unfoldRnn.png" alt="展开视图" /><figcaption aria-hidden="true">展开视图</figcaption></figure><p> </p><h2 id="卷积神经网络">卷积神经网络</h2><figure><img src="cnn.png" alt="Convolutional Neural Networks, CNN" /><figcaption aria-hidden="true">Convolutional Neural Networks,CNN</figcaption></figure><p>专门用于处理具有网格状拓扑结构数据（如图像）的深度学习模型，是计算机视觉任务（如图像分类、目标检测和分割）的核心技术。</p><p> </p><h2 id="transformer模型">Transformer模型</h2><p>一种基于注意力机制的深度学习模型，仅依赖注意力机制来处理序列数据，从而实现更高的并行性和更快的训练速度。</p><figure><img src="transformer.png" alt="transformer结构" /><figcaption aria-hidden="true">transformer结构</figcaption></figure><p>结构：</p><ul><li>编码器（Encoder）：由NN层相同的模块堆叠而成，每层包含两个子层，每个子层后面都接有残差连接（Residual Connection） 和 层归一化（LayerNormalization）。</li></ul><p> 多头自注意力机制（Multi-HeadSelf-Attention）：计算输入序列中每个词与其他词的相关性。</p><p> 前馈神经网络（FNN）：对每个词进行独立的非线性变化。</p><ul><li>解码器（Decoder）：由NN层相同的模块堆叠而成，每层包含三个子层，每个子层后面都接有残差连接和层归一化。</li></ul><p> 掩码多头自注意力机制（Masked Multi-HeadSelf-Attention）：计算输出序列中每个词和其他词的相关性。</p><p><em># 使用掩码防止未来信息泄露</em></p><p> 交叉注意力机制（Encoder-DecoderAttention）：计算输出序列与输入序列的相关性。</p><p> 前馈神经网络（FNN）</p><p>核心思想：</p><ul><li>自注意力机制（Self-Attention）：允许模型在处理序列时，动态地为每个位置分配不同的权重，从而捕捉序列中任意两个位置之间的依赖关系。</li><li>多头注意力（Multi-HeadAttention）：将输入分成多个子空间，每个子空间独立计算注意力，最后将结果拼接起来。</li><li>位置编码（PositionalEncoding）：位置编码被用来为输入序列中的每个词添加位置信息，代替序列信息（如RNN中的时间步）。</li></ul><p>优势：并行计算，长距离依赖（解决RNN的梯度消失），可扩展性。</p><p>应用：NLP（机器翻译，GPT），CV（图像分类，目标检测），多模态任务。</p><p> </p><p> </p><h1 id="conda指令">Conda指令</h1><p> 查看环境：<code>conda env list</code></p><p> 进入环境：<code>conda activate 环境名称</code></p><p> 退出环境：<code>conda deactivate</code></p><p> 删除环境：<code>conda remove --name 环境名称 --all</code></p><p> 更换为阿里云镜像源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p><p> 查看当前源：<code>pip config list</code></p><p> 查看当前包：<code>pip list</code></p><p> 下载依赖包requirements.txt：<code>pip install -r requirements.txt</code></p><p> </p><p> </p><h1 id="训练模型">训练模型</h1><p>模型文件=模型结构+预训练权重</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/web/"/>
    <url>/web/</url>
    
    <content type="html"><![CDATA[<p>Json对象和数组：</p><p>​ 对象是键值对集合，数组是值的有序列表；</p><p>​Json对象的值可以包含数组，数组的元素也可以是一个对象，能够支持多层嵌套。</p><p> </p><p>前端渲染和后端渲染：</p><figure><img src="render.png" alt="render.png" /><figcaption aria-hidden="true">render.png</figcaption></figure><p>​ 前端渲染：React,Vue等；后端渲染：传统PHP,Java,Python等。</p><p>​现代开发常采用混合方案：同构渲染，首次访问使用SSR快速呈现内容，后续交互转为CSR提供流畅体验，如Next.js (React), Nuxt.js (Vue)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript</title>
    <link href="/javascript/"/>
    <url>/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="文件与拖拽api的底层原理">文件与拖拽API的底层原理</h1><p>文件API：</p><p> 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；</p><p> 无路径访问：JavaScript无法知晓真正的文件路径；</p><p> 同源限制：读取的文件内容只能在当前页面上下文使用。</p><p>拖拽API：</p><p>拖拽本质是操作系统提供的跨应用（跨源）通信机制。</p><p>过程：</p><p> 拖拽开始时，OS创建“拖拽会话”；</p><p> 拖拽过程中，系统跟踪光标位置并查询下方的放置目标；</p><p> 放置时，系统协调数据传递。</p><figure><img src="dragAndDrop.png" alt="拖拽实现的层次" /><figcaption aria-hidden="true">拖拽实现的层次</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascipt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/dsa/"/>
    <url>/dsa/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="枚举算法">枚举算法</h2><p>描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。</p><p>核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解，关注枚举的上下界。</p><p>优点：简单基本，便于实现，容易调试，正确性容易证明。</p><p>流程：</p><ul><li><p>确定枚举对象、枚举的上下界、判断条件。</p></li><li><p>枚举可能的情况并验证是否是问题的解。</p></li><li><p>考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。</p><p>题库：百钱买百鸡，LeetCode78，611，1504，1733，2048，2749。</p></li></ul><p> </p><h2 id="贪心算法">贪心算法</h2><p>描述：每一步都做出在当前看来是最好的选择，期望通过局部最优选择来达到全局最优解。</p><p>核心思想：局部最优，不可回溯，期望全局最优。</p><blockquote><p>贪心只做局部最优选择，不保证全局最优。</p></blockquote><p>优点：高效，简单直观。</p><p>流程：</p><ul><li>建立数学模型</li><li>分解问题</li><li>制定贪心策略</li><li>求解子问题</li><li>合并成原问题解</li></ul><p>题库：LeetCode45，134，1578，1792，2598，3350，3397。</p><p> </p><h2 id="回溯算法">回溯算法</h2><p>描述：通过深度优先(DFS)搜索策略来遍历所有可能的候选解，并在搜索过程中利用剪枝来避免无效搜索，提高效率。</p><p>核心思想：</p><ul><li>路径：从根节点到当前节点所做出的选择序列。</li><li>选择列表：在当前节点可以做出的所有选择。</li><li>结束条件：找到一个解或停止。</li></ul><p>流程：</p><ul><li>在当前节点遍历所有选择</li><li>找到解做出选择并加入当前路径</li><li>递归进入下一个状态</li><li>递归返回后，撤销刚才的选择（<strong>回溯</strong>）</li></ul><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;result_type&gt; result;  <span class="comment">// 存储最终结果</span></span><br><span class="line">    vector&lt;current_path&gt; path;   <span class="comment">// 当前路径或状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(参数列表)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (满足终止条件) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (选择 in 选择列表) &#123;</span><br><span class="line">            <span class="keyword">if</span> (不满足约束条件) <span class="keyword">continue</span>;  <span class="comment">// 剪枝</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(选择);         <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(更新参数);          <span class="comment">// 递归进入下一层</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();              <span class="comment">// 撤销选择（回溯）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以配合lamdba表达式<code>auto dfs&#123;&#125;;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs,<span class="type">int</span> i,<span class="type">int</span> t)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n||t&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(candidates[i]&gt;t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 不选i+1</span></span><br><span class="line">    <span class="type">int</span> k=i;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>&amp;&amp;candidates[k<span class="number">+1</span>]==candidates[k])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(k<span class="number">+1</span>,t);</span><br><span class="line">    <span class="comment">// 选i+1</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(i<span class="number">+1</span>,t-candidates[i]);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题库：LeetCode 22，39，40，77，79。</p><p> </p><h2 id="动态规划">动态规划</h2><p>描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，能够避免重复计算子问题。</p><p>分成记忆化递归（自顶向下）和DP数组（自底向上）两种动态规划。</p><p>核心思想：拆分子问题、记住过往、减少重复计算。</p><p>流程：</p><ul><li><p>穷举分析</p></li><li><p>确认边界</p><ul><li>找出规律，确定最优子结构</li></ul><blockquote><p>动态规划问题即是递推问题，当前的决策结果是<code>f(n)</code>，则最有子结构就是要让<code>f(n-k)</code>最优，并且与后面的决策没有关系，能让后面的决策安心使用局部最优解。</p></blockquote><ul><li>写出状态转移方程</li></ul></li></ul><p>题库：0-1背包问题，LeetCode62，120，474，1277，1504，2327，3186，3494。</p><p> </p><h2 id="位运算算法">位运算算法</h2><p>大大提高程序的性能，0/1问题时好用。</p><p>题库：LeetCode50，78，2749。</p><p> </p><h2 id="模拟">模拟</h2><p>描述：完全按照题目的描述或者问题的真实发生过程，一步步地用代码复现出来从而得到答案。</p><p>核心思想：重视还原，过程再现。</p><p>流程：</p><ul><li>提炼规则</li><li>设计数据结构</li><li>分解步骤，模块化</li><li>注意边界</li></ul><p>特点：思路直观，实现繁琐。</p><p>题库：LeetCode6，54，3446。</p><p> </p><h2 id="堆算法">堆算法</h2><p>描述：特殊的完全二叉树，可以用一维数组存储。</p><p>堆的更新和维护：</p><p> 入堆<code>push()</code>，时间复杂度<code>O(log n)</code></p><p> 出堆<code>pop()</code>，时间复杂度<code>O(log n)</code></p><p> 访问栈顶<code>top()</code>，时间复杂度<code>O(1)</code></p><p> 建堆，时间复杂度<code>O(nlog n)</code></p><blockquote><p>即堆中插入n个元素</p></blockquote><p>应用：优先队列。</p><p>题库：LeetCode 1792。</p><p> </p><h2 id="分支限界法">分支限界法</h2><p>描述：</p><ul><li>分支：将大问题划分为若干子问题，形成解空间树，每个结点代表一个子问题，每条分支表示对子问题的一种约束或决策。</li><li>限界：对每个子问题，计算一个上下界，即它可能取得的最优解的范围，如果某个子问题的最优解范围不可能优于当前已知的最优解，就剪枝（丢弃该子问题）。</li></ul><p>流程：</p><ul><li>定义问题的解空间</li><li>从根结点开始分支，产生子问题</li><li>对每个子问题计算限界</li><li>子问题放入候选结点表（队列/堆等）</li><li>从候选结点表中选择结点展开（搜索策略）</li><li>结点满足约束并且更优就继续分支，不满足就剪枝</li><li>重复直到候选结点表为空或者找到全局最优</li></ul><p>题库：0-1背包问题。</p><p> </p><h2 id="双指针">双指针</h2><p>描述：使用两个指针（索引）在数据结构中协同工作，一般分为同向指针或者相向指针。</p><p>滑动窗口也是一种双指针，左指针收缩窗口，右指针扩展窗口。</p><p>流程：</p><ul><li>数据结构进行排序</li><li>边界</li><li>指针移动条件</li><li>重复元素处理</li></ul><p>题库：LeetCode11，15，16，75，611， 2348。</p><p> </p><h2 id="前缀和">前缀和</h2><p>描述：高效处理区间和的技巧。</p><p>将区间求和的操作从O(n)优化为O(1)，例如，求<code>sum[l,r]</code>的暴力解法是遍历<code>[l,r]</code>；而预先处理<code>prefix[i]</code>，<code>sum[l,r]</code>即为<code>prefix[r]-prefix[l-1]</code>。</p><p>构造时<code>prefix[x]=prefix[x-1]+a[x]</code>。</p><p>核心思想：预处理前缀和，换取查询效率；适合于频繁查询但不修改。</p><p>题库：LeetCode3147，3346。</p><p><strong>差分数组</strong></p><p>描述：在区间的边界上做标记，最后通过前缀和恢复原数组。</p><blockquote><p>前缀和的互补技巧。</p></blockquote><p>构造时<code>d[i]=a[i]-a[i-1]</code>，恢复时<code>a[i]=a[i-1]+d[i]</code>。</p><p>同理，例如将遍历<code>[l,r]</code>的数组区间，每个加<code>x</code>，转换为<code>d[l]+=x</code>和<code>d[r+1]-=x</code>。</p><p>二维的时候，<code>mat[i][j]=diff[i][j]+mat[i−1][j]+mat[i][j−1]−mat[i−1][j−1]</code>，如果要将区间<code>row1,row2,col1,col2</code>内的矩形元素全部<code>+x</code>，则为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff[row1][col1]+=x;</span><br><span class="line">diff[row2+1][col1]-=x;</span><br><span class="line">diff[row1][col2+1]-=x;</span><br><span class="line">diff[row2+1][col2+1]+=x;</span><br></pre></td></tr></table></figure><blockquote><p>注意边界。</p></blockquote><p>题库：LeetCode2536，3346。</p><p> </p><p> </p><h1 id="结构">结构</h1><h2 id="折半查找树">折半查找树</h2><p>即二叉搜索树，Binary Search Tree，BST</p><p>每个结点最多有两个孩子，对于任一结点<code>node</code>：</p><p>左子树上的所有键小于<code>node-&gt;key</code>，右子树上的所有键大于<code>node-&gt;key</code>。</p><p>若树的高度为<code>h</code>，查找/插入/删除复杂度为O(h)，遍历O(n)。</p><p> </p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><p>包括深度优先遍历（DFS）和广度优先遍历（BFS）</p><p>1、深度优先遍历</p><p>按访问顺序不同，可分为前序遍历，中序遍历，后序遍历。</p><p>（1）前序遍历</p><p>顺序：根 -&gt; 左子树 -&gt; 右子树</p><p>可以用于复制树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><p>顺序：左子树 -&gt; 根 -&gt;右子树</p><p>对于二叉搜索树来说，中序遍历的结果就是升序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><p>顺序：左子树 -&gt; 右子树 -&gt; 根</p><p>删除树节点或者释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、广度优先遍历</p><p>又叫层序遍历，从根节点开始逐层从左到右访问。</p><p>输出层次结构，求出树的高度、最短路径等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//队列，FIFO</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="有向图邻接表">有向图邻接表</h2><p>常用的图存储结构，适合存储稀疏图（顶点多，边少）</p><ul><li>有向图：每条边都有方向，比如<code>u-&gt;v</code>表示从顶点<code>u</code>指向顶点<code>v</code>。</li><li>邻接表：为图中的每个顶点建立一个链表/动态数组，存储从该顶点出发的所有边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>; <span class="comment">// 顶点个数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，1-based</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">adj[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">adj[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> </p><h2 id="单调栈">单调栈</h2><p>常用于求取下一个最小元素/最大元素，栈中元素是单调递减/递增。</p><p> </p><h1 id="stl">STL</h1><h2 id="ascii">ASCII</h2><p>小写字母的ASCII码=大写字母的ASCII码+32。</p><p> </p><h2 id="正整数向上取整">正整数向上取整</h2><p>方法：<code>int div=(a+b-1)/b</code></p><p>如果<code>a</code>整除<code>b</code>，那么加上的<code>b+1</code>还不足以跨越到下一个整数；如果<code>a</code>不整除<code>b</code>，那么跨越下一个整数。</p><p> </p><h2 id="int最小数和最大数">int最小数和最大数</h2><p><code>INT_MIN</code>和<code>INT_MAX</code>，分别为-2<sup>31</sup>和2<sup>31</sup>-1。</p><p> </p><h2 id="整数取模的最小非负整数">整数取模的最小非负整数</h2><p><code>(x%m+m)%m</code>，<code>x</code>如果为负数，加上<code>m</code>变为正数再取模；<code>x</code>为正数和<code>0</code>无影响。</p><p> </p><h2 id="快速幂算法">快速幂算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) ans *= x;</span><br><span class="line">    x *= x;</span><br><span class="line">    N /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：将指数作为二进制，每次向右移动一位，将<code>x</code>翻倍，最低位为<code>1</code>的就累乘到<code>ans</code>中，将时间复杂度从O(n)变成O(logn)。</p><p> </p><h2 id="短路求值">短路求值</h2><p>C++逻辑中的<code>||</code>是短路机制，只要前者条件满足就不会计算后者，因此在遍历容器时如果遇到<code>i+1</code>这种可以<code>if(i==length-1||colors[i]!=colors[i+1])</code>，只要没到最后一个元素就不会越界访问。</p><p> </p><h2 id="最小公约数最大公倍数">最小公约数/最大公倍数</h2><p>格式：<code>gcd()</code>和<code>lcm()</code></p><p>C++中自带，<code>0</code>和其他数的<code>gcd()</code>是其他数，区间求<code>gcd()</code>可以用枚举更新。</p><p> </p><h2 id="swap"><code>swap()</code></h2><p>格式：<code>void swap(T&amp; a,T&amp; b)</code></p><p>时间复杂度和空间复杂度都是O(1)。</p><p> </p><h2 id="sort"><code>sort()</code></h2><p>格式：<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p><p>拓展：<code>ranges::sort(xx)</code>等价于<code>std::(sort.begin(),sort.end())</code></p><blockquote><p>迭代器范围：<code>[first, last)</code>是一个左闭右开的区间，例如使用索引和迭代器结合时要用<code>begin()+i</code>和<code>begin()+j+1</code>。</p><p>如果是二维数组，默认按照<code>first</code>进行排序。</p><p>性能：时间复杂度为O(nlogn)。</p></blockquote><p> </p><h2 id="min_element"><code>min_element()</code></h2><p>格式：<code>min_element(begin(),end())</code></p><p>作用：返回<code>[begin,end)</code>范围内最小的迭代器，可以在前面加解引用符号<code>*</code>，即为返回值。</p><p>示例：<code>return *min_element(matrix.begin(),matrix.end())</code></p><p> </p><h2 id="lower_bound"><code>lower_bound()</code></h2><p>格式：<code>auto it = lower_bound(xx.begin(),xx.end(),x)</code></p><p>作用：找到这个容器下第一个大于等于<code>x</code>的元素，并返回迭代器（要求容器有序）。</p><p>平均时间复杂度：O(log n)。</p><p> </p><h2 id="clamp"><code>clamp()</code></h2><p>格式：<code>int x=clamp(value,lo,hi)</code></p><p>作用：返回区间[lo,hi]之间最接近value的值。</p><blockquote><p>即为<code>min(max(value, lo), hi)</code></p></blockquote><p> </p><h2 id="getline"><code>getline()</code></h2><p>格式：<code>istream&amp; getline(istream&amp; is, string&amp; str, char delim);</code></p><blockquote><p><code>is</code>是输入流对象，可以是<code>cin</code>或者<code>stringstream</code>，<code>str</code>是用来存储的字符串变量，<code>delim</code>是可选的分隔符。</p></blockquote><p>作用：默认从当前位置读到换行符<code>\n</code>为止，例如<code>getline(cin, str, ',')</code>可以读取输入流直到<code>,</code>为止。</p><p>和<code>cin&gt;&gt;</code>混用时注意要清空缓冲区<code>cin.ignore()</code>。</p><p> </p><h2 id="move"><code>move()</code></h2><p>作用：避免深拷贝操作，将容器的内容全部转移，转移后的容器会变为空。</p><blockquote><p>可以和<code>emplace_back</code>配合<code>xxx.emplace_back(move(xx))</code></p></blockquote><p> </p><h2 id="static"><code>static</code></h2><p>作用于局部变量时：使得变量的生命周期延长至整个程序运行期间，而不是随着函数调用结束而销毁。</p><p>作用于成员变量时：所有该类的对象共享同一个静态成员变量。</p><p> </p><h2 id="优先队列">优先队列</h2><p>特殊的队列，每个元素都有优先级，最先取出优先级最高的元素，堆顶是最大/最小元素，可以在<code>struct&#123;&#125;;</code>中提前声明，</p><p>格式：<code>priority_queue&lt;元素类型,底层容器类型,比较函数类型&gt;</code></p><p><em>#注：声明忽略后面两个参数时自动按照最大堆排列，即按照从前往后比较的最大元素的排列。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，char可以换成自定义的struct</span></span><br><span class="line">priority_queue&lt;<span class="type">char</span>,vector&lt;<span class="type">char</span>&gt;,CompareASCII&gt;pq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认最小堆/最大堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line"><span class="comment">// 最大优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><p>重载运算符：</p><p><em>#一般<code>const</code>修饰，重载运算符不必修改对象，引用传递避免不必要的拷贝，提高效率，返回值必须为bool。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆，栈顶是优先级最小的，最大堆反之用&lt;。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareASCII</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; a,<span class="type">const</span> <span class="type">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入：<code>push()</code>（只能接受一个参数，必须是已经构造好的元素）或者<code>emplace()</code></p><p><em># 不支持随机访问修改</em></p><p>时间复杂度：插入和删除都是<code>O(log n)</code>。</p><p> </p><h2 id="vector">Vector</h2><p>构造：<code>vector(size_type n, const T&amp; val)</code></p><p>直接在末尾构造对象：<code>emplace_back(构造需要的数据)</code></p><blockquote><p>省去一次拷贝。</p></blockquote><p>清空所有元素：<code>clear()</code></p><blockquote><p>清空可以用<code>empty()</code>判断</p></blockquote><p>是否为空矩阵：<code>empty()</code></p><blockquote><p><code>0</code>不能用此判断</p></blockquote><p> </p><h2 id="string">String</h2><p>获取子字符串：<code>substr(size_t pos,size_t len)</code></p><blockquote><p><code>pos</code>：子字符串的起始位置，默认0；<code>len</code>：提取的字符数量，默认一直提取到末尾</p></blockquote><p>找到子字符或子字符串：<code>find()</code></p><blockquote><p>返回起始位置</p></blockquote><p>将字符串转换为整数：<code>stoi(const string&amp; s,size_t* idx,int base)</code></p><blockquote><p><code>s</code>：需转换的字符串；<code>idx</code>：可选指针；<code>base</code>：可选的转换的进制</p></blockquote><p>删除最后一个字符：<code>pop_back()</code></p><blockquote><p>字符串不能为空</p></blockquote><p>在用<code>char</code>构建<code>string</code>的时候，不能直接相加，<code>char+char</code>会被判定为<code>int</code>，可以用<code>push_back()</code>或者<code>str+=c</code>。</p><p>遇到字母的<code>string</code>，解题时可以考虑枚举26个英文字母。</p><p> </p><h2 id="stack">Stack</h2><p>初始化：<code>stack&lt;T&gt; s</code></p><p>栈的元素个数：<code>size()</code></p><p>自底向上拼接栈中元素(<code>string</code>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string res;</span><br><span class="line">vector&lt;string&gt; parts;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    parts.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = parts.<span class="built_in">rbegin</span>(); it != parts.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    res += *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用了vector的反向迭代器从后向前。</p></blockquote><p> </p><h2 id="位运算">位运算</h2><p> 计算整数中二进制为1的个数：<code>popcount(T x)</code></p><p><em>#<code>T</code>：无符号的整数类型，例如<code>unsigned int</code>，<code>unsigned long</code>，<code>uint64_t</code>等；<code>x</code>：整数</em></p><p> </p><h2 id="模板类">模板类</h2><h3 id="pair"><code>&lt;pair&gt;</code></h3><p>定义好的迷你结构体，将两个数据打包成一个整体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    T1 first;   <span class="comment">// 第一个元素</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>T1</code>和<code>T2</code>可以为其他不同类型，例如<code>pair&lt;int,string&gt;</code>，经常用于键值对，函数返回值，构造容器等。</p><p> </p><h3 id="tuple"><code>&lt;tuple&gt;</code></h3><p>固定大小，异质（可以是不同类型）的容器</p><p>构造：<code>tuple&lt;T1,T2,T3&gt; myTuple(t1,t2,t3)</code></p><p>访问：<code>T1 first=get&lt;0&gt;(myTuple)</code>，也可以修改</p><p>支持比较：比较的是字典序</p><p> </p><h2 id="无序有序关联容器">无序/有序关联容器</h2><h3 id="无序基于哈希表实现">无序：基于哈希表实现</h3><p>1、哈希集合：<code>unordered_set&lt;key&gt;</code></p><ul><li><p>元素是唯一的，检查一个元素是否存在于集合当中</p></li><li><p>用法：</p><ul><li>插入：<code>insert(key)</code></li><li>查找：<code>find(key)</code>，返回的是迭代器，一般配合<code>end()</code>使用进行判断</li></ul><blockquote><p><code>count(num)</code>，返回的是0/1，表示集合中是否存在<code>num</code>。</p></blockquote><ul><li>删除：<code>erase(key)</code></li></ul></li></ul><p>2、哈希表：<code>unordered_map&lt;key,value&gt;</code></p><ul><li><p>key是唯一的</p></li><li><p>用法：</p><ul><li>插入：<code>insert(&#123;key,value&#125;)</code>，或者<code>map[key]=value</code></li></ul><blockquote><p>注意，<code>it</code>指向<code>pair&lt;const Key, Value&gt;</code>的对象，不能通过<code>it</code>修改键，但可以修改值，<code>it-&gt;first</code>是键，<code>it-&gt;second</code>是值。</p></blockquote><ul><li>访问：<code>map[key]</code></li></ul></li></ul><p>3、性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(1)，但最坏情况可能是O(n)。</li><li>元素顺序：无序</li></ul><h3 id="有序基于红黑树实现">有序：基于红黑树实现</h3><p>红黑树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(logn)，从而确保了所有主要操作的时间复杂度都是稳定的 O(log n)。</p><p>有序集合：<code>set&lt;key&gt;</code>和有序表：<code>map&lt;key,value&gt;</code></p><blockquote><p>用法同哈希集合和哈希表。</p></blockquote><p>性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(log n)</li><li>元素顺序：默认按键排列升序</li></ul><p> </p><h2 id="listsetmap">List，Set，Map</h2><table><thead><tr><th>特性</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>顺序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr><td>可重复</td><td>可以</td><td>不可以</td><td>键不重复</td></tr><tr><td>访问方式</td><td>下标索引</td><td>无索引</td><td>key查找</td></tr><tr><td>用途</td><td>保存序列</td><td>保存唯一元素</td><td>键值对应关系</td></tr></tbody></table><p> </p><h2 id="链表">链表</h2><p>线性数据结构，链表中的元素在内存中不是连续存放的，通过指针将一系列节点连接起来，形成逻辑上的序列。</p><p>节点：</p><ul><li>数据域：用于存储实际的数据（可以是整数、字符串、对象等）。</li><li>指针域：一个指向下一个节点的指针。</li></ul><p>单向链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据域，这里以整数为例</span></span><br><span class="line">    ListNode* next;     <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，方便创建节点</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构：</p><ul><li>头节点：链表的第一个节点。通过一个指向头节点的指针（<code>head</code>）来访问整个链表。如果链表为空，<code>head</code>指针为 <code>nullptr</code>。</li><li>尾节点：链表的最后一个节点。它的 <code>next</code> 指针指向<code>nullptr</code>。</li></ul><p>方法：</p><ul><li>创建链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建几个节点</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>遍历链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头部插入节点（时间复杂度O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtHead</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点的next指向原来的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;       <span class="comment">// 新节点成为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾部插入节点（时间复杂度O(n)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtTail</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode; <span class="comment">// 如果链表为空，新节点就是头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 将尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除节点（时间复杂度O(n)，已知位置就是O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == val) &#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找要删除节点的前一个节点</span></span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span> &amp;&amp; current-&gt;next-&gt;data != val) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>内存管理：在 C++ 中使用 <code>new</code> 创建的节点，必须使用<code>delete</code> 手动释放，否则会导致内存泄漏。</li><li>指针安全：操作指针时要格外小心，避免访问 <code>nullptr</code>或已删除的内存（野指针）。</li><li>边界条件：处理空链表、单节点链表等情况时要特别注意。</li></ul><p> </p><h2 id="inline"><code>inline</code></h2><p>内联函数，编译器会尝试用函数内的代码替换掉函数调用语句</p><p>传统函数调用过程：</p><ul><li>执行到函数调用语句</li><li>将返回地址，参数等压入栈</li><li>跳转到函数体的内存地址开始执行</li><li>函数执行完毕，将返回值存入指定位置</li><li>跳转回之前保存的地址，继续执行调用处的下一条指令</li></ul><p>这个过程对于功能简单，调用频繁的小函数，这种开销可能比函数本身执行的时间还长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>减少调用开销</li><li>避免宏定义的缺点</li></ul><p> </p><h1 id="lambda表达式">Lambda表达式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 递归函数例子</span></span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有两个点，无法组成三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用，修改 res 相当于修改 memo[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123; <span class="comment">// 枚举顶点 k</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + v[i] * v[j] * v[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>[&amp;]</code>表示能够访问外部作用域所有变量，<code>this auto&amp;&amp;</code>允许Lambda实现自递归，<code>-&gt;int</code>表示返回类型为整数（也可以为空），<code>int &amp; res</code>表示修改这个值同时会修改对应的的<code>memo</code>的值，实现记忆化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/hexo/"/>
    <url>/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo指令">Hexo指令：</h1><p> 新建博客：<code>hexo new'xxx'</code></p><p> 清除之前所有的公共文件：<code>hexo clean</code></p><p> 重新生成html文件：<code>hexo g</code></p><p> 上传到GitHub：<code>hexo d</code></p><p>==&gt;清除/生成/部署：<code>hexo clean &amp;&amp; hexo g -d</code></p><p> 查看hexo版本：<code>hexo version</code></p><p> </p><h1 id="hexo美化">Hexo美化</h1><p> </p><h1 id="git指令">Git指令：</h1><p> 测试Github到SSH的连接：<code>ssh -T git@github.com</code></p><p> 测试到Github的网络连接是否通畅：<code>ping github</code></p><p><em># ping命令使用 ICMP 协议，git 命令使用 HTTP/HTTPS 协议。</em></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ping</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标记语言</title>
    <link href="/markdown/"/>
    <url>/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法">Markdown语法</h1><h2 id="链接">链接</h2><p>效果：<a href="url">链接文本</a></p><p>格式：<code>[链接文本](url)</code></p><p> </p><h2 id="指数">指数</h2><p>效果：2<sup>n</sup></p><p>格式：<code>2&lt;sup&gt;n&lt;/sup&gt;</code></p><p> </p><h2 id="列表">列表</h2><p>效果：</p><ul><li><p>列表一</p></li><li><p>列表二</p><p>格式：<code>- 列表一</code></p></li></ul><p> </p><h2 id="斜体">斜体</h2><p>效果：<em>斜体</em></p><p>格式：<code>*斜体*</code></p><p> </p><h2 id="加粗">加粗</h2><p>效果：<strong>加粗</strong></p><p>格式：<code>**加粗**</code></p><p> </p><h2 id="公式">公式</h2><p>效果：<spanclass="math inline"><em>h</em><sub><em>t</em></sub></span></p><p>格式：<code>$h_t$</code></p><p> </p><h2 id="表格">表格</h2><p>效果：</p><table><thead><tr><th>列A</th><th>列B</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>格式：<code>|列A|列B|</code></p><p> </p><h2 id="引用">引用</h2><p>效果：</p><blockquote><p>引用部分</p></blockquote><p>格式：<code>&gt; 引用部分</code></p><p> </p><p> </p><h1 id="latex语法">LaTex语法</h1><h2 id="数学符号">数学符号</h2><h3 id="中括号">中括号</h3><p><span class="math display">$$\left \{\begin{aligned}&amp; abc\\&amp; def\end{aligned}\right.$$</span> 格式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\left</span> <span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">&amp;</span> abc</span><br><span class="line"><span class="keyword">\\</span><span class="built_in">&amp;</span> def</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\right</span>.</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">∈</span></td><td style="text-align: center;"><code>\in</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∀</span></td><td style="text-align: center;"><code>\forall</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∩</span></td><td style="text-align: center;"><code>\cap</code></td></tr><tr><td style="text-align: center;"><span class="math inline">≤</span></td><td style="text-align: center;"><code>\leq</code></td></tr><tr><td style="text-align: center;"><span class="math inline">⋯</span></td><td style="text-align: center;"><code>\cdots</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline">$\frac{a}{b}$</span></td><td style="text-align: center;"><code>\frac&#123;a&#125;&#123;b&#125;</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em><sub><em>b</em></sub></span></td><td style="text-align: center;"><code>a_b</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em><sup><em>b</em></sup></span></td><td style="text-align: center;"><code>a^b</code></td></tr><tr><td style="text-align: center;"><span class="math inline">$\textabc$</span></td><td style="text-align: center;"><code>\text abc</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>a</em>  <em>b</em></span></td><td style="text-align: center;"><code>a \quad b</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline">$\sum_{i=1}^n$</span></td><td style="text-align: center;"><code>\sum_&#123;i=1&#125;^n</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>x̄</em></span></td><td style="text-align: center;"><code>\bar x</code></td></tr><tr><td style="text-align: center;"><span class="math inline">{}</span></td><td style="text-align: center;"><code>\&#123;\&#125;</code></td></tr></tbody></table><p> </p><h2 id="希腊字母">希腊字母</h2><table><thead><tr><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline"><em>δ</em></span></td><td style="text-align: center;"><code>\delta</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>Δ</em></span></td><td style="text-align: center;"><code>\Delta</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∇</span></td><td style="text-align: center;"><code>\nabla</code></td></tr><tr><td style="text-align: center;"><span class="math inline">∂</span></td><td style="text-align: center;"><code>\partial</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>θ</em></span></td><td style="text-align: center;"><code>\theta</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>λ</em></span></td><td style="text-align: center;"><code>\lambda</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>ε</em></span></td><td style="text-align: center;"><code>\varepsilon</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>α</em></span></td><td style="text-align: center;"><code>\alpha</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>σ</em></span></td><td style="text-align: center;"><code>\sigma</code></td></tr><tr><td style="text-align: center;"><spanclass="math inline"><em>φ</em></span></td><td style="text-align: center;"><code>\varphi</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/vue/"/>
    <url>/vue/</url>
    
    <content type="html"><![CDATA[<p>Vue3</p><p>​描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。</p><p>​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。</p><p>​ 命令：</p><p><em># 创建Vue项目</em> <code>npm init vue@latest</code></p><p><em># 启动开发服务器</em></p><p><code>npm install</code></p><p><code>npm run dev</code></p><p><em># 打开图形化界面</em></p><p><code>npm install @vue/cli</code></p><p><code>vue ui</code></p><p>Vite</p><p>​描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。</p><p>​ 组成：</p><ul><li><p>开发服务器：基于原生ES模块，提供超快的热更新。</p></li><li><p>构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。</p><p>优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/docker/"/>
    <url>/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><p>描述：开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上，也可以实现虚拟化。</p><p>优点：跨平台一致性，资源高效，快速部署，隔离性。</p><p>基本命令：</p><p> 查看运行中的容器：<code>docker  ps</code></p><p> 进入容器内部：<code>docker exec -it &lt;容器ID&gt; /bin/bash</code></p><p> 杀死进程：<code>kill -9 项目ID</code></p><p>命令大全：<ahref="https://www.runoob.com/docker/docker-command-manual.html">Docker命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/computerNetworks/"/>
    <url>/computerNetworks/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip">TCP/IP</h1><h2 id="五层模型">五层模型</h2><p> 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。</p><p> 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。</p><p> 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。</p><p> 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。</p><p> 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。</p><h2 id="http请求过程">HTTP请求过程</h2><p>从浏览器，操作系统，网络设备到服务器共同参与的协作过程。</p><p> 过程：</p><figure><img src="http.png" alt="八个阶段" /><figcaption aria-hidden="true">八个阶段</figcaption></figure><p>1、URL解析</p><p>用户输入，浏览器解析（协议、域名、路径），浏览器检查</p><p>2、DNS域名解析</p><p>浏览器查找顺序（浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt;网络服务供应商的DNS服务器 -&gt; 递归查询），返回IP</p><p>3、建立TCP连接（三次握手）</p><p>浏览器先和服务器建立一条可靠的传输通道，即TCP连接。</p><p>4、发送HTTP请求</p><p>浏览器发送请求报文</p><ul><li>请求行：请求方法，请求的URL路径，HTTP协议版本。<ul><li><code>GET /index.html HTTP/1.1</code></li></ul></li><li>请求头：包含关于客户端和环境的信息的键值对。<ul><li><code>Host: www.example.com</code>（必需，指定域名）</li><li><code>User-Agent</code>（浏览器身份标识），<code>Accept</code>（客户端接收的内容类型）等</li></ul></li><li>请求体：通常只在POST/PUT方法中存在，包含提交给服务器的数据。</li></ul><p>5、服务器处理请求并返回HTTP响应</p><p>服务器收到请求报文后，会进行处理（例如，由Web服务器软件（如Nginx/Apache）处理静态请求，或由应用服务器（如Tomcat/Node.js）处理动态请求），然后返回一个HTTP响应报文。</p><p>服务器发送响应报文</p><ul><li>状态行：HTTP协议版本、状态码和状态消息。<ul><li><code>HTTP/1.1 200 OK</code>，<code>HTTP/1.1 404 Not Found</code>，<code>HTTP/1.1 500 Internal Server Error</code></li></ul></li><li>响应头：包含关于服务器和响应主体的信息，键值对。<ul><li><code>Content-Type</code>，<code>Content-Length</code>，<code>Set-Cookie</code></li></ul></li><li>响应体：请求的真正资源内容，HTML文档、图片数据等。</li></ul><p>6、浏览器解析渲染页面</p><p>浏览器收到响应后，会根据响应头中的<code>Content-Type</code>来决定如何处理响应体。</p><p>生成DOM树，CSSOM树，合并构建渲染树，布局，绘制。</p><p>7、连接结束（四次握手）</p><p>HTTP是一种无状态协议，默认完成请求就会关闭连接。</p><p>8、后续交互</p><p>一个完整的页面通常需要加载很多资源（CSS, JS,图片等）。对于HTTP/1.1，浏览器会对同一个域名建立多个TCP连接（通常是6-8个）来并行下载这些资源，以加快速度。HTTP/2则允许在一个TCP连接上进行多路复用，效率更高。</p><p> </p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><table><thead><tr><th>特性</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接<br>建立连接三次握手，释放连接四次握手。</td><td>无连接的<br>直接发送数据。</td></tr><tr><td>可靠性</td><td>高<br>通过确认，重传，校验，流量控制，拥塞控制等手段确保数据无差错，不丢失等。</td><td>低<br>不提供任何可靠机制，不确认是否收到，可能丢失，乱序或重复。</td></tr><tr><td>数据形式</td><td>面向字节流<br>无结构，无边界，应用程序自己处理粘包/拆包问题。</td><td>面向数据包<br>独立，有边界，一次发送就是一个完整报文。</td></tr><tr><td>速度和开销</td><td>速度慢，开销大<br>各种机制增加开销，减慢速度。</td><td>速度快，开销小<br>延迟极低，传输效率高。</td></tr><tr><td>传输模式</td><td>全双工<br>连接双方可以同时发送和接收数据。</td><td>支持单播，多播，广播。</td></tr><tr><td>应用场景</td><td>网页浏览（HTTP/HTPPS）<br>文件传输（FTP）<br>电子邮件（SMTP，IMAP）<br>远程登陆（SSH）</td><td>视频流媒体，语音通话<br>在线游戏<br>DNS查询<br>TFTP（简单文件传输）<br>广播/多播</td></tr></tbody></table><p> </p><p> </p><p>LocalStorage和SessionStorage的区别</p><figure><img src="LocalStorage.png" alt="LocalStorage.png" /><figcaption aria-hidden="true">LocalStorage.png</figcaption></figure><p>LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。</p><p> </p><p> </p><p>WebSocket</p><p>在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。</p><p>HTTP：无状态，单向请求-响应模式===&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。</p><p>WebRTC</p><p>虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN/TURN服务器。</p><p>信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
