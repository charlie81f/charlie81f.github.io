<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot问题</title>
    <link href="/2025/10/20/springBootBug/"/>
    <url>/2025/10/20/springBootBug/</url>
    
    <content type="html"><![CDATA[<h1 id="运行问题">运行问题</h1><p>运行新的SpringBoot项目时要把<code>pom.xml</code>添加为Maven项目，直至其图标变为蓝色。</p><p> </p><h2 id="清理并重建项目">清理并重建项目</h2><p>1、清理缓存</p><p>打开IDEA，设置-是缓存失效-失效并重启。</p><p>2、清理Maven缓存</p><p><code>mvn clean install</code></p><p> </p><h1 id="数据库连接问题">数据库连接问题</h1><h2 id="mysql忘记密码且文件不可读">Mysql忘记密码且文件不可读</h2><p>在<code>Mysql/bin</code>文件夹下运行<code>mysqld --console</code>时报错<code>[ERROR] [MY-012271] [InnoDB] The innodb_system data file 'ibdata1' must be writable</code>。</p><p>1、停止Mysql<code>net stop mysql</code>；</p><p>2、检查<code>ibdata1</code>权限；</p><p>跳转到<code>Mysql/data</code>文件夹下，把<code>ibdata1</code>改为完全控制，再<code>mysqld --console</code>依然报错则第二步。</p><p>3、初始化<code>ibdata1</code>；</p><p>提前备份<code>Mysql/data</code>下数据，删除<code>Mysql/data</code>文件夹，先<code>mkdir data</code>，再跳转到<code>Mysql/bin</code>执行<code>mysqld --initialize-insecure --datadir="data目录" --console</code>。</p><p>重新<code>mysqld --console</code>成功后打开新窗口<code>mysql -u root</code>，重设密码<code>ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';</code>。</p><p> </p><h2 id="删除数据库时pathvariable没有被正确解析导致500">删除数据库时<code>@PathVariable</code>没有被正确解析导致500</h2><p>1、修改<code>pom.xml</code>下<code>&lt;build&gt;</code>下的<code>&lt;configuration&gt;</code>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">    &lt;compilerArgs&gt;</span><br><span class="line">        &lt;arg&gt;-parameters&lt;/arg&gt; &lt;!-- 确保参数名信息被保留 --&gt;</span><br><span class="line">    &lt;/compilerArgs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>确保编译时保留了方法参数名称信息。</p><p>2、重新构建项目<code>mvn clean install</code>，再重新启动项目即可。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行工具</title>
    <link href="/2025/10/13/commandLineTool/"/>
    <url>/2025/10/13/commandLineTool/</url>
    
    <content type="html"><![CDATA[<h2 id="cmd">CMD</h2><p>command prompt，基础的命令执行环境，适合简单任务。</p><p>特点：</p><ul><li><p>处理的是文本字符串。</p></li><li><p>所有命令输出都是纯文本，无法直接操作结构化数据。</p></li><li><p>脚本语言为<code>.bat</code>和<code>.cmd</code></p></li></ul><p>常见命令：</p><ul><li>列出文件：<code>dir</code>。</li><li>显示当前路径：<code>cd</code>；更改目录：<code>cd C:\...</code>。</li></ul><p> </p><h2 id="powershell">PowerShell</h2><p>高级脚本和自动化工具。</p><p>特点：</p><ul><li>基于对象的管道机制。</li><li>可以直接访问和操作对象的属性，无需文本解析。</li><li>使用动词-名词格式命名命令，语义清晰。</li><li>脚本语言为<code>.ps1</code></li></ul><p>常见命令：</p><ul><li>列出文件：<code>Get-ChildItem</code>或<code>dir</code>。</li><li>显示当前路径：<code>Get-Location</code>；更改目录：<code>Set-Location C:\...</code>或<code>cd C:\...</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建模技术</title>
    <link href="/2025/09/24/modelingTechnology/"/>
    <url>/2025/09/24/modelingTechnology/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章">第一章</h1><h2 id="建模">建模</h2><p>定义：模型是对客观事物抽象出来的原型的替代物。</p><p>常见模型：实物模型、物理模型、符号模型（图表）。</p><p>数学建模：实际问题转化为数学问题。</p><p> </p><h2 id="数学建模的基本方法和步骤">数学建模的基本方法和步骤</h2><p>基本方法</p><ul><li>机理分析：对客观事物特性的认识====&gt;内部机理的数量规律（白箱）</li><li>测试分析：对量测数据的统计分析====&gt;与数据拟合最好的模型（黑箱）</li></ul><p>二者结合：机理分析建立模型结构，测试分析确定模型参数。</p><p>（建模主要指机理分析）</p><p> </p><h2 id="数学模型和数学建模">数学模型和数学建模</h2><p>第一性原理：看透事物本质的根本方法。</p><p>数学建模的一般步骤</p><ul><li>模型准备：形成清晰的问题。</li><li>模型假设：合理的，简化的。</li><li>模型构成：采用简单的数学工具。</li><li>模型求解</li><li>模型分析：误差，统计等。</li><li>模型检验：与实际现象，数据比较。</li><li>模型应用</li></ul><figure><img src="1.1.png" alt="数学建模的全过程" /><figcaption aria-hidden="true">数学建模的全过程</figcaption></figure><p>实践到理论再到实践。</p><p>特点：逼真性，条理性，可行性，渐进性，强健性，局限性，可转移性，非预制性。</p><p> </p><h2 id="优化建模">优化建模</h2><p>最小作用量原理：物理系统在从一个状态演化到另一个状态的过程中，会选择使作用量取得极值（通常是局部最小值）的路径。</p><p> 例如，费马原理：光在传播过程中，无论是直线传播、反射还是折射，都遵循时间最短或路径最短的原理。</p><p> </p><h2 id="最优化问题的一般形式及分类">最优化问题的一般形式及分类</h2><p>一般数学形式： <span class="math display">min<sub><em>x</em> ∈ <em>X</em></sub><em>f</em>(<em>x</em>)</span> 其中，<span class="math inline"><em>f</em>(<em>x</em>)</span>是目标函数，<span class="math inline"><em>x</em></span>是决策变量，<span class="math inline"><em>X</em></span>是约束集合或可行域，构成优化问题的三要素。</p><p>可行域包含的点<span class="math inline"><em>x</em> ∈ <em>X</em></span>是可行解或可行点。 <span class="math display">$$\left\{\begin{aligned}&amp; \min &amp;&amp; f(x)\\&amp; \text{s.t.} &amp;&amp; g_i(x) \leq 0, \; i = 1, \cdots, p\\&amp; &amp;&amp; h_j(x) = 0, \; j = 1, \cdots, q\end{aligned}\right.$$</span> 其中，<span class="math inline"><em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)<sup><em>T</em></sup></span>，<span class="math inline"><em>f</em>(<em>x</em>)</span>、<span class="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>、<span class="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span> 为 <span class="math inline"><em>x</em></span> 的实值函数。</p><p>引入向量函数符号$g(x) = ( g_1(x), , g_p(x) )^T <span class="math inline"><em>和</em></span> h(x) = ( h_1(x), , h_q(x) )^T$后： <span class="math display">$$\left\{\begin{array}{ll}\min        &amp; f(x) \\\text{s.t.} &amp; g(x) \leq 0 \\            &amp; h(x) = 0\end{array}\right.$$</span>  </p><p>定义：</p><ul><li>对于最优化问题，若有<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且有：</li></ul><p><span class="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>X</em></span></p><p>则称<span class="math inline"><em>x</em><sup>*</sup></span>是最优化问题的整体最优解，<span class="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是整体最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格最优解。</p><p> </p><ul><li>对于最优化问题，若有<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且存在<span class="math inline"><em>x</em><sup>*</sup></span>的邻域<span class="math inline"><em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) = {<em>x</em> ∈ <em>R</em><sup><em>n</em></sup><em>且</em>||<em>x</em> − <em>x</em><sup>*</sup>|| &lt; <em>δ</em>}</span>使得：</li></ul><p><span class="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) ∩ <em>X</em></span></p><p>则称<span class="math inline"><em>x</em><sup>*</sup></span>是最优化问题的局部最优解，<span class="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是局部最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格局部最优解。</p><p> </p><p>分类：</p><ul><li>若<span class="math inline"><em>f</em>(<em>x</em>)</span>，<span class="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<span class="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>皆为线性函数，即为线性规划（LP）；至少一个非线性，则为非线性规划（NLP）。</li><li>若没有<span class="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<span class="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>，即<span class="math inline"><em>X</em> = ℝ<sup><em>n</em></sup></span>，则为无约束最优化问题。</li><li>若<span class="math inline"><em>f</em>(<em>x</em>)</span>，<span class="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>，<span class="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>皆为光滑函数，则为光滑优化，反之则为非光滑优化。</li></ul><figure><img src="1.2.png" alt="最优化问题的分类" /><figcaption aria-hidden="true">最优化问题的分类</figcaption></figure><p>一个优化问题可能属于多个类别。</p><p> </p><h2 id="机器学习问题">机器学习问题</h2><p>标准流程</p><ul><li>数据：模拟学习问题的输入和输出</li><li>模型：备选预测函数集合</li><li>算法-表现度量：指导优化的目标函数</li><li>算法-优化算法：计算优化问题最优解</li></ul><p>没有免费的午餐原理：该定理表明，在所有可能的问题中，平均而言，任何算法的性能都是相同的。（有得必有失，守恒，平衡）</p><p>奥卡姆剃刀原理：如无必要，勿增实体。</p><p> </p><h2 id="组合优化问题">组合优化问题</h2><p>定义：这类问题广泛存在于现实生活的各个领域，如物流、 金融、计算机科学、生物信息学等。它关注于在给定 的约束条件下，从一组可能的解中找出最优解。</p><h3 id="旅行商问题tsp">1、旅行商问题(TSP)</h3><p>在物流规划、电路板布线、生物学和交通规划等领域有重要应用。</p><p>随着城市数量的增加，问题的求解难度呈指数增长。</p><p>常用穷举法，动态规划，贪心，遗传等启发式算法。</p><h3 id="背包问题">2、背包问题</h3><p>在商业、组合数学、计算复杂性理论、密码学和应用数学等领域。</p><p>常用动态规划、分支限界法、遗传算法等。</p><h3 id="指派问题">3、指派问题</h3><p>一类特殊的线性规划问题，它要求将n项任务分配给n个人去完 成，每个人只能完成一项任务，且每项任务只能由一个人完成。目标是找 到一种分配方案，使得总成本（或总时间、总资源消耗等）最小。</p><p>在企业管理、资源分配、任务调度等领域有重要应用。</p><p>常用匈牙利算法等有效算法求解。</p><p> </p><p>还有调度问题、切割问题、装箱问题等等…</p><p> </p><p> </p><h1 id="第二章-连续最优化建模与应用">第二章 连续最优化建模与应用</h1><h2 id="非线性规划基础">非线性规划基础</h2><h3 id="梯度nabla-fx">梯度<span class="math inline">∇<em>f</em>(<em>x</em>)</span></h3><p>定义：<span class="math inline"><em>f</em>(<em>x</em>)</span>的<span class="math inline"><em>n</em></span>个偏导数为分量的向量。 <span class="math display">$$\nabla f(x) = \left[ \frac{\partial f(x)}{\partial x_1}, \frac{\partial f(x)}{\partial x_2}, \cdots, \frac{\partial f(x)}{\partial x_n} \right]^T$$</span></p><blockquote><p><span class="math inline"> − ∇<em>f</em>(<em>x</em>)</span>则为梯度下降方向，一般用于最优化问题，即梯度下降法。</p></blockquote><p>常用的梯度公式：</p><ul><li><span class="math inline"><em>f</em>(<em>x</em>)</span>为常数，则<span class="math inline">∇<em>f</em>(<em>x</em>)</span>=0；</li><li><span class="math inline"><em>f</em>(<em>x</em>) = <em>b</em><sup><em>T</em></sup><em>x</em></span>，则<span class="math inline">∇<em>f</em>(<em>x</em>) = <em>b</em></span>；</li><li><span class="math inline"><em>f</em>(<em>x</em>) = <em>x</em></span>，则<span class="math inline">∇<em>f</em>(<em>x</em>) = <em>I</em></span>（单位阵）；</li><li><span class="math inline"><em>f</em>(<em>x</em>) = <em>x</em><sup><em>T</em></sup><em>x</em></span>，则<span class="math inline">∇<em>f</em>(<em>x</em>) = 2<em>x</em></span>；</li><li><span class="math inline"><em>A</em></span>为对称矩阵，<span class="math inline"><em>f</em>(<em>x</em>) = <em>x</em><sup><em>T</em></sup><em>A</em><em>x</em></span>，则<span class="math inline">∇<em>f</em>(<em>x</em>) = 2<em>A</em><em>x</em></span></li></ul><p> </p><h3 id="n元二次函数">n元二次函数</h3><p>一般形式：<span class="math inline">$f(x_1, x_2, \cdots, x_n) = \frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n a_{ij}x_i x_j + \sum_{i=1}^n b_i x_i + c$</span></p><blockquote><p>加上<span class="math inline">$\frac{1}{2}$</span>是<span class="math inline"><em>x</em><sub><em>i</em></sub><em>x</em><sub><em>j</em></sub></span>和<span class="math inline"><em>x</em><sub><em>j</em></sub><em>x</em><sub><em>i</em></sub></span>重复计算。</p></blockquote><p>矩阵形式：<span class="math inline">$f(x) = \frac{1}{2} x^T A x + b^T x + c$</span>，其中<span class="math inline"><em>A</em> = <em>A</em><sup><em>T</em></sup></span></p><blockquote><p><span class="math inline"><em>A</em></span>是一个对称矩阵。</p></blockquote><p>二次型：<span class="math inline">$f(x) = \frac{1}{2} x^T A x$</span></p><blockquote><p>只保留了二次项</p></blockquote><p>矩阵正定性：正定、半正定、负定、不定。</p><p> </p><h3 id="hessian矩阵">Hessian矩阵</h3><p>定义：多元函数<span class="math inline"><em>f</em>(<em>x</em>)</span>关于<span class="math inline"><em>x</em></span>的二阶导数。 <span class="math display">$$\nabla^2 f(x) = \nabla(\nabla f(x)) =\begin{bmatrix}\dfrac{\partial^2 f(x)}{\partial x_1^2} &amp; \dfrac{\partial^2 f(x)}{\partial x_2 \partial x_1} &amp; \cdots &amp; \dfrac{\partial^2 f(x)}{\partial x_n \partial x_1} \\\dfrac{\partial^2 f(x)}{\partial x_1 \partial x_2} &amp; \dfrac{\partial^2 f(x)}{\partial x_2^2} &amp; \cdots &amp; \dfrac{\partial^2 f(x)}{\partial x_n \partial x_2} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\dfrac{\partial^2 f(x)}{\partial x_1 \partial x_n} &amp; \dfrac{\partial^2 f(x)}{\partial x_2 \partial x_n} &amp; \cdots &amp; \dfrac{\partial^2 f(x)}{\partial x_n^2}\end{bmatrix}$$</span></p><blockquote><p>当<span class="math inline"><em>f</em>(<em>x</em>)</span>的所有二阶偏导数连续时，即<span class="math inline">$\dfrac{\partial^2 f(x)}{\partial x_i \partial x_j}=\dfrac{\partial^2 f(x)}{\partial x_j \partial x_i}$</span>时，Hessian矩阵是对称的。</p></blockquote><p> </p><h3 id="jacobi矩阵">Jacobi矩阵</h3><p>定义：<span class="math inline"><em>g</em>(<em>x</em>)</span>是一个向量值函数，Jacobi矩阵即为<span class="math inline"><em>g</em>(<em>x</em>)</span>在<span class="math inline"><em>x</em><sub>0</sub></span>处的导数。 <span class="math display">$$\nabla g(x_0) =\begin{bmatrix}\dfrac{\partial g_1(x_0)}{\partial x_1} &amp; \dfrac{\partial g_1(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partial g_1(x_0)}{\partial x_n} \\\dfrac{\partial g_2(x_0)}{\partial x_1} &amp; \dfrac{\partial g_2(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partial g_2(x_0)}{\partial x_n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\dfrac{\partial g_m(x_0)}{\partial x_1} &amp; \dfrac{\partial g_m(x_0)}{\partial x_2} &amp; \cdots &amp; \dfrac{\partial g_m(x_0)}{\partial x_n}\end{bmatrix}$$</span>  </p><h3 id="taylor展开">Taylor展开</h3><p>定义：<span class="math inline"><em>f</em>(<em>x</em>)</span>是连续可微的，<span class="math inline"><em>p</em></span>是向量，那么 <span class="math display"><em>f</em>(<em>x</em> + <em>p</em>) = <em>f</em>(<em>x</em>) + ∇<em>f</em>(<em>x</em> + <em>t</em><em>p</em>)<sup><em>T</em></sup><em>p</em>,  其中 0 &lt; <em>t</em> &lt; 1</span></p><blockquote><p>二阶连续可微，即可进一步<span class="math inline">$f(x + p) = f(x) + \nabla f(x)^T p + \frac{1}{2} p^T \nabla^2 f(x + tp) p$</span></p></blockquote><p> </p><h2 id="无约束可约最优化问题">无约束可约最优化问题</h2><h3 id="最优性条件">最优性条件</h3><p><span class="math display">$$\begin{aligned}&amp; \min &amp;&amp; f(x) \\&amp; \text{s.t.} &amp;&amp; x \in \mathbb{R}^n\end{aligned}$$</span></p><p>定理（必要条件）：设<span class="math inline"><em>f</em></span>在点<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>R</em><sup><em>n</em></sup></span>处可微，若<span class="math inline"><em>x</em><sup>*</sup></span>是<span class="math inline"><em>m</em><em>i</em><em>n</em><em>f</em>(<em>x</em>)</span>的局部最优解，则<span class="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>。</p><blockquote><p>梯度为0的点称为函数的驻点，定理说明：这个点一定是驻点，但仅仅是一阶必要条件。</p><p>驻点可能是极小/极大，可能都不是，即为鞍点。</p></blockquote><p>定理（二阶充分必要条件）：设<span class="math inline"><em>f</em></span>在点<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>R</em><sup><em>n</em></sup></span>处的Hessian矩阵<span class="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>)</span>存在，</p><ul><li>必要条件：若<span class="math inline"><em>x</em><sup>*</sup></span>是<span class="math inline"><em>f</em></span>的一个局部极小点，==&gt;<span class="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>，那么<span class="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>) ≽ 0</span>半正定；</li><li>充分条件：若<span class="math inline">∇<em>f</em>(<em>x</em><sup>*</sup>) = 0</span>，<span class="math inline">∇<sup>2</sup><em>f</em>(<em>x</em><sup>*</sup>) ≻ 0</span>正定，那么<span class="math inline"><em>x</em><sup>*</sup></span>是<span class="math inline"><em>m</em><em>i</em><em>n</em><em>f</em>(<em>x</em>)</span>的严格局部最优解。</li></ul><blockquote><p>设点<span class="math inline"><em>x</em><sup>*</sup></span>满足一阶最优性条件，且该点处的Hessian矩阵不是半正定的，则<span class="math inline"><em>x</em><sup>*</sup></span>不是一个局部极小点。</p><p>事实上，该点是一个鞍点。</p></blockquote><p> </p><h4 id="最小二乘法"><strong>最小二乘法</strong></h4><p>损失函数： <span class="math display">$$J_l(\theta) = \frac{1}{2} \sum_{i=1}^n \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2$$</span> 应用：曲线拟合、图像配准、信号去噪。</p><p> </p><h3 id="线搜索算法">线搜索算法</h3><figure><img src="2.1.png" alt="流程" /><figcaption aria-hidden="true">流程</figcaption></figure><p><span class="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>Δ</em><em>x</em><sup><em>k</em></sup></span></p><p><span class="math inline"><em>Δ</em><em>x</em><sup><em>k</em></sup> = <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span></p><blockquote><p><span class="math inline"><em>d</em><sup><em>k</em></sup></span>为第k轮搜索方向，<span class="math inline"><em>λ</em><sub><em>k</em></sub></span>为第k轮步长。</p></blockquote><p> </p><h4 id="下降方向特殊搜索方向"><strong>下降方向（特殊搜索方向）</strong></h4><p>定义：若存在<span class="math inline"><em>δ</em> &gt; 0</span>，<span class="math inline"><em>d</em> ∈ <em>R</em><sup><em>n</em></sup></span>，<span class="math inline"><em>d</em> ≠ 0</span>，使得<span class="math inline"><em>f</em>(<em>x</em> + <em>t</em><em>d</em>) &lt; <em>f</em>(<em>x</em>)</span>，<span class="math inline">∀<em>t</em> ∈ (0, <em>δ</em>)</span>，则称向量<span class="math inline"><em>d</em></span>是函数<span class="math inline"><em>f</em>(<em>x</em>)</span>在点<span class="math inline"><em>x</em></span>处下降方向。</p><blockquote><p>若<span class="math inline"><em>f</em>(<em>x</em>)</span>在<span class="math inline"><em>x</em></span>可导，则<span class="math inline"> − ∇<em>f</em>(<em>x</em>)</span>就是<span class="math inline"><em>f</em>(<em>x</em>)</span>在<span class="math inline"><em>x</em></span>处下降最快的方向。</p></blockquote><p> </p><p>最优步长： <span class="math display"><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup>) = min<sub><em>λ</em> ≥ 0</sub><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><em>d</em><sup><em>k</em></sup>)</span></p><blockquote><p><span class="math inline"><em>λ</em><sub><em>k</em></sub></span>即为最优步长。</p></blockquote><p>步骤：</p><ul><li>给出初始点<span class="math inline"><em>x</em><sup>0</sup></span>，令<span class="math inline"><em>k</em> = 0</span>；</li><li>按照某种规则，确定<span class="math inline"><em>d</em><sup><em>k</em></sup></span>；</li><li>按照某种规则，确定<span class="math inline"><em>λ</em><sub><em>k</em></sub></span>，使得<span class="math inline"><em>f</em>(<em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup>) &lt; <em>f</em>(<em>x</em><sup><em>k</em></sup>)</span>；</li><li>令<span class="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，<span class="math inline"><em>k</em> := <em>k</em> + 1</span>；</li><li>判断<span class="math inline"><em>x</em><sup><em>k</em></sup></span>是否满足停止条件，是则停止，否则转第2步。</li></ul><p> </p><h4 id="算法收敛"><strong>算法收敛</strong></h4><p>定义：算法按<span class="math inline"><em>d</em><sup><em>k</em></sup></span>和<span class="math inline"><em>λ</em><sub><em>k</em></sub></span>产生的迭代点列<span class="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，如果点列<span class="math inline">{<em>x</em><sup><em>k</em></sup>}</span>收敛于最优解<span class="math inline"><em>x</em><sup>*</sup></span>，则称该算法收敛。</p><blockquote><p>如果进一步有$f(x<sup>0)&gt;f(x</sup>1)&gt; &gt;f(x^k)&gt; $，则称该算法为下降迭代算法。</p></blockquote><p>常用的收敛性判断条件：</p><ul><li><span class="math inline">∥<em>x</em><sup><em>k</em> + 1</sup> − <em>x</em><sup><em>k</em></sup>∥ &lt; <em>ε</em><sub>1</sub></span></li><li><span class="math inline">|<em>f</em>(<em>x</em><sup><em>k</em> + 1</sup>) − <em>f</em>(<em>x</em><sup><em>k</em></sup>)| &lt; <em>ε</em><sub>2</sub></span></li></ul><p>收敛速度： <span class="math display">$$\frac{\|x^{k+1} - x^*\|}{\|x^k - x^*\|^\alpha} &lt; \lambda, \quad \lambda, \alpha &gt; 0$$</span> 则称<span class="math inline"><em>x</em><sup><em>k</em></sup></span>的收敛阶为<span class="math inline"><em>α</em></span>。</p><blockquote><p><span class="math inline"><em>α</em> = 1</span>，线性收敛（k充分大）。</p><p><span class="math inline">1 &lt; <em>α</em> &lt; 2</span>，超线性收敛。</p><p><span class="math inline"><em>α</em> = 2</span>，二阶收敛。</p></blockquote><p> </p><h3 id="常用最优化算法">常用最优化算法</h3><h4 id="梯度法最速下降法">梯度法（最速下降法）</h4><p>定理：</p><p>设<span class="math inline"><em>f</em>(<em>x</em>)</span>在点<span class="math inline"><em>x̄</em></span>处可微，若存在<span class="math inline"><em>d</em> ∈ <em>R</em><sup><em>n</em></sup></span>，使得 <span class="math display">∇<em>f</em>(<em>x̄</em>)<sup><em>T</em></sup><em>d</em> &lt; 0</span> 则称向量<span class="math inline"><em>d</em></span>是<span class="math inline"><em>f</em></span>在点<span class="math inline"><em>x̄</em></span>处的下降方向。</p><blockquote><p><span class="math inline"> − ∇<em>f</em></span>是下降速度最快的方向，称为最速下降方向。</p><p>函数在某点的梯度不为0，则该梯度方向必定与过该点的等值面垂直。</p></blockquote><p>方向：<span class="math inline"><em>d</em><sup><em>k</em></sup> =  − ∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span></p><p>步长：</p><ul><li>可直接选取固定的<span class="math inline"><em>λ</em><sub><em>k</em></sub></span>；</li><li>或者最优步长；</li><li>也可以依赖线搜索算法。</li></ul><p>思路：</p><ul><li>给定初始点<span class="math inline"><em>x</em><sup><em>k</em></sup> ∈ <em>R</em><sup><em>n</em></sup></span>，允许误差<span class="math inline"><em>ε</em> &gt; 0</span>，置<span class="math inline"><em>k</em> = 1</span>；</li><li>计算搜索方向<span class="math inline"><em>d</em><sup><em>k</em></sup> =  − ∇<em>f</em>(<em>x</em><sup><em>k</em></sup>)</span>；</li><li>若<span class="math inline">∥<em>d</em><sup><em>k</em></sup>∥ ≤ <em>ε</em></span>停止，否则，从<span class="math inline"><em>x</em><sup><em>k</em></sup></span>出发，沿<span class="math inline"><em>d</em><sup><em>k</em></sup></span>进行一维搜索求<span class="math inline"><em>λ</em><sub><em>k</em></sub></span>，找到最优步长；</li><li>令<span class="math inline"><em>x</em><sup><em>k</em> + 1</sup> = <em>x</em><sup><em>k</em></sup> + <em>λ</em><sub><em>k</em></sub><em>d</em><sup><em>k</em></sup></span>，置<span class="math inline"><em>k</em> := <em>k</em> + 1</span>，转第二步。</li></ul><blockquote><p>特点：线性收敛，容易产生扭摆现象造成早停，当<span class="math inline"><em>x</em><sup><em>k</em></sup></span>距离最优点<span class="math inline"><em>x</em><sup>*</sup></span>较远时，速度快；而接近最优点时，速度下降。</p></blockquote><p> </p><h4 id="牛顿法">牛顿法</h4>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海游记</title>
    <link href="/2025/09/23/ShangHaiTravel/"/>
    <url>/2025/09/23/ShangHaiTravel/</url>
    
    <content type="html"><![CDATA[<p>22号农历八月初一的生日，刚好朋友来上海面试，和朋友到这里提前过国庆，顺便过个生日游玩一下。</p><h1 id="豫园">豫园</h1><p>来上海第一感觉是外国人真的很多，大街上到处可见，不愧是中国第一大国际化都市。尤其是旅游景点，各国的游客都来拜访这里，豫园挺大的，绕着走也得走很一会，但人流大了显得有点逼仄，景色优美，很多假山假石，环境很清新，算是工业化城市中难得的原始景色了，听说傍晚来这里景色更好。</p><figure><img src="yuyuan01.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan02.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan03.png" alt="豫园外" /><figcaption aria-hidden="true">豫园外</figcaption></figure><p>周一不开门，门票可以提前预约。</p><p>——2025/9/21 周日</p><p> </p><h1 id="城隍庙">城隍庙</h1><p>城隍庙离豫园非常近，拜佛的地方，进去就是大殿，旁边也有月老殿、财神殿等，进去可以拿香火上香，来这里知道了上香要用左手在前右手在后。</p><figure><img src="chenghuangmiao01.png" alt="城隍庙大门" /><figcaption aria-hidden="true">城隍庙大门</figcaption></figure><figure><img src="chenghuangmiao02.png" alt="城隍庙出口" /><figcaption aria-hidden="true">城隍庙出口</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="裕兴记">裕兴记</h1><p>苏州风味的蟹黄面，118/碗，感觉有点贵，口味一般般吧，但是面料感觉挺不错的，带有小料、生姜汤和枸杞茶，如果只是作为高档的那种早餐应该还不错。</p><figure><img src="yuxingji.png" alt="蟹黄面" /><figcaption aria-hidden="true">蟹黄面</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="鸟醺烧鸟居酒屋">鸟醺烧鸟居酒屋</h1><p>日料，点了爆黄喉，棒棒鸡，牛肉乌冬和拉面，还有附赠的可尔必思和鸡腿肉，还有餐后的烤菠萝和冰淇淋，感觉还不错，至少口味和酱料这方面跟我之前吃过的日料还是不一样，有点独特的感觉，也很平价，环境专门布置成日风，服务周到，应该算没有踩到坑（笑）。</p><figure><img src="niaoxun01.png" alt="菜品" /><figcaption aria-hidden="true">菜品</figcaption></figure><figure><img src="niaoxun02.png" alt="环境" /><figcaption aria-hidden="true">环境</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="百联zx">百联ZX</h1><p>魔都二次元的必经之地！很多专卖店，各种热门甚至一些比较冷门的IP谷子都有，从小徽章，亚克力牌到玩偶，手办等，很有氛围，六层逛个爽，这里也全是同好，进来感觉浓浓的异次元感啊！顺便帮朋友代购了点火影的谷子（以后我有钱了也要来这里买手办！）</p><figure><img src="bailian01.png" alt="热门IP墙" /><figcaption aria-hidden="true">热门IP墙</figcaption></figure><figure><img src="bailian02.png" alt="玩偶" /><figcaption aria-hidden="true">玩偶</figcaption></figure><figure><img src="bailian03.png" alt="东映动画" /><figcaption aria-hidden="true">东映动画</figcaption></figure><figure><img src="bailian04.png" alt="一乐拉面" /><figcaption aria-hidden="true">一乐拉面</figcaption></figure><figure><img src="bailian05.png" alt="卡卡西" /><figcaption aria-hidden="true">卡卡西</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="静安大悦城">静安大悦城</h1><p>这里主要还是商城，但是北座的6F还是8F有一些谷子店，潮玩星球之类的，有个书店很大，里面各种漫画都有，包括很冷门的IP！这应该是相对于百联的优势了，但是二次元的店家很少，就一层之中的几个店吧，专营店址类的也不多。</p><figure><img src="dayuecheng01.png" alt="各种漫画" /><figcaption aria-hidden="true">各种漫画</figcaption></figure><figure><img src="dayuecheng02.png" alt="JOJO" /><figcaption aria-hidden="true">JOJO</figcaption></figure><figure><img src="dayuecheng03.png" alt="排着特别长的队，好像是hellokitty" /><figcaption aria-hidden="true">排着特别长的队，好像是hellokitty</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="南京路">南京路</h1><p>人是真的多！尽管是周末非假期晚上，各地的游客都是多如牛毛的，两侧是建筑风格很有历史感的高级奢饰品店，感受氛围系列。</p><figure><img src="nanjinglu01.png" alt="南京路中" /><figcaption aria-hidden="true">南京路中</figcaption></figure><figure><img src="nanjinglu02.png" alt="接近外滩" /><figcaption aria-hidden="true">接近外滩</figcaption></figure><figure><img src="nanjinglu03.png" alt="和平饭店" /><figcaption aria-hidden="true">和平饭店</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="上海博物馆东馆">上海博物馆东馆</h1><p>有很多层，从青铜器，玉器到陶瓷等，每一层都很大要逛很久，挺累的，对历史感兴趣的话这里应该很好玩。</p><figure><img src="shangbo01.png" alt="外面" /><figcaption aria-hidden="true">外面</figcaption></figure><figure><img src="shangbo02.png" alt="一楼青铜馆" /><figcaption aria-hidden="true">一楼青铜馆</figcaption></figure><figure><img src="shangbo03.png" alt="玉如意" /><figcaption aria-hidden="true">玉如意</figcaption></figure><figure><img src="shangbo04.png" alt="青铜剑" /><figcaption aria-hidden="true">青铜剑</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="东方明珠">东方明珠</h1><p>在陆家嘴桥上看的，这里拍照打卡的人很多，视角还不错，上去逛好像要￥199，下次再来！</p><p><img src="dongfang01.png" /></p><p><img src="dongfang02.png" /></p><p><img src="dongfang03.png" /></p><p>——2025/9/22 周一</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>上海</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>上海</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毗卢寺/鸡鸣寺游记</title>
    <link href="/2025/09/12/piluJimingTravel/"/>
    <url>/2025/09/12/piluJimingTravel/</url>
    
    <content type="html"><![CDATA[<p>今天天气不错，想着去逛了毗卢寺和鸡鸣寺，拜一拜也帮朋友求一下，都离学校不算很远，走一走。</p><h1 id="毗卢寺">毗卢寺</h1><p>这里还是比较偏的，人流很少。</p><figure><img src="house.png" alt="河边豪斯" /><figcaption aria-hidden="true">河边豪斯</figcaption></figure><p>路过的河边看到的小豪斯，有小河有花园，住起来应该很舒服。</p><figure><img src="door01.png" alt="毗卢寺侧门" /><figcaption aria-hidden="true">毗卢寺侧门</figcaption></figure><p>旁边是小学，对门是医院，这附近环境非常安静，很适合休闲散心。</p><figure><img src="mainHall01.png" alt="大殿总览" /><figcaption aria-hidden="true">大殿总览</figcaption></figure><p>布局简单，大概是正殿和两个偏殿，左侧还有一个鼓楼，正殿对着的是烧香的地方。</p><figure><img src="mainHall02.png" alt="大殿" /><figcaption aria-hidden="true">大殿</figcaption></figure><figure><img src="statue01.png" alt="弥勒佛" /><figcaption aria-hidden="true">弥勒佛</figcaption></figure><figure><img src="statue02.png" alt="金刚" /><figcaption aria-hidden="true">金刚</figcaption></figure><figure><img src="statue03.png" alt="释迦牟尼佛" /><figcaption aria-hidden="true">释迦牟尼佛</figcaption></figure><p>供奉的是弥勒佛和释加牟尼，背面也有一个不知道是菩萨还是什么的。</p><p>门票￥10，上香免费，出来的时候有几个找你算手相算命的，有钱的可以试试。</p><p>——2025/9/11周四</p><p> </p><h1 id="鸡鸣寺">鸡鸣寺</h1><p>南朝四百八十寺之首，南京旅游地标性建筑。</p><figure><img src="jiming01.png" alt="25年3月" /><figcaption aria-hidden="true">25年3月</figcaption></figure><figure><img src="jiming02.png" alt="9月" /><figcaption aria-hidden="true">9月</figcaption></figure><p>三月晚上去看过一次樱花，物是人非事事休。</p><figure><img src="hall01.png" alt="昆仑宝殿" /><figcaption aria-hidden="true">昆仑宝殿</figcaption></figure><p>进去应该是比较先看到的，结构是环形+向上的感觉，有一点绕，出口在入口右手边，很多殿林立，感觉里面建筑学很高深。</p><figure><img src="tower01.png" alt="药师佛塔" /><figcaption aria-hidden="true">药师佛塔</figcaption></figure><p>供奉的是药师佛/药师如来。</p><p>春山撩乱水纵横，篱落荒畦草自生。 独往独来山下路，笋舆看得绿阴成。</p><p>——王安石《台城寺侧独行》</p><figure><img src="hall02.png" alt="藏经阁/法堂" /><figcaption aria-hidden="true">藏经阁/法堂</figcaption></figure><p>药师佛塔之后，顺时针绕。</p><figure><img src="roof.png" alt="屋顶" /><figcaption aria-hidden="true">屋顶</figcaption></figure><p>进上香广场的楼梯处。</p><figure><img src="tower02.png" alt="寺里最高的塔" /><figcaption aria-hidden="true">寺里最高的塔</figcaption></figure><p>在上香的最高的广场点即可看到。</p><p>门票￥10，上香免费，很大，人也比较多。</p><p>——2025/9/11周四</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>南京</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>南京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2025/09/10/os/"/>
    <url>/2025/09/10/os/</url>
    
    <content type="html"><![CDATA[<h1 id="线程多开的弊端">线程多开的弊端</h1><p>1、系统资源消耗过大</p><ul><li>内存开销：每个线程需要独立的线程栈（几百 KB 到数 MB），线程数多了会占用大量内存。</li><li>句柄/内核对象消耗：OS维护线程管理信息（TCB，线程控制块），也是负担。</li></ul><p>2、频繁上下文切换</p><ul><li>CPU可能一直在进行多线程切换而非执行实际任务，性能反而降低。</li></ul><p>3、线程调度开销增加</p><ul><li>线程调度器要在大量线程中决定调度，调度队列变长，增加调度延迟。</li></ul><p>4、竞争和同步问题</p><ul><li>多线程共享内存时，访问同一资源产生竞争，增加死锁，活锁等风险。</li></ul><p>5、缓存一致性和CPU亲和性问题</p><ul><li>如果线程频繁切换核，可能导致缓存失效，增加内存访问延迟。</li></ul><p>6、程序稳定性风险</p><ul><li>线程数超过系统支持的最大值可能导致线程创建失败或者系统卡顿甚至崩溃。</li></ul><p>改善：</p><ul><li>采用线程池：用固定数量线程复用，避免无限创建。</li><li>异步/事件驱动模型：在 I/O 密集型任务中，比开很多线程更高效。</li><li>限制线程数：一般根据 CPU核心数 和 任务性质（CPU 密集 or I/O 密集）来决定线程数量。</li></ul><p> </p><h1 id="simd">SIMD</h1><p>单指令多数据</p><p>一种并行计算方式，允许处理器用一条指令同时对多个数据元素进行操作。</p><p>最常见的CPU向量化技术，MIMD则是多核CPU的通用并行方式。</p><p>实现方式：</p><ul><li>寄存器向量化：CPU有专门的向量寄存器（如Intel AVX，SSE）：<ul><li>SSE：128b向量寄存器</li><li>AVX：256b向量寄存器</li></ul></li><li>GPU并行：GPU本身就非常擅长SIMD计算，每个线程执行相同指令，处理不同数据。</li></ul><p>优点：</p><ul><li>提升速度</li><li>降低功耗</li><li>适合向量化任务：图像滤波，矩阵运算，信号处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2025/09/08/java/"/>
    <url>/2025/09/08/java/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构">JVM内存结构</h1><p>JVM 执行 Java 程序时会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途、创建和销毁时间。</p><p>1、程序计数器（Program Counter Register）</p><p>当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>特点：</p><ul><li><p>线程私有：每条线程有个独立的PCR，互不影响，独立存储。</p></li><li><p>如果正在执行Java方法，PCR的值为正在执行的JVM的字节码指令地址；如果是Native方法，值为空。</p></li><li><p>唯一一个没有<code>OutOfMemoryError</code>情况的区域</p></li></ul><p>2、Java虚拟机栈（Java Virtual Machine Stacks）</p><p>Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧 (Stack Frame)， 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到完成的过程，对应着一个栈帧在JVM栈中从入栈到出栈的过程。</p><p>特点：</p><ul><li>线程私有</li><li>存储内容：局部变量表，编译期可知的基本数据类型，对象引用类型和返回地址类型。</li><li>异常：<code>StackOverflowError</code>，<code>OutOfMemoryError</code></li></ul><p>3、本地方法栈（Native Method Stack）</p><p>与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>特点和虚拟机栈类似。</p><p>4、Java堆（Java Heap）</p><p>此内存区唯一的目的就是存放对象实例，基本在这里分配内存，通常所说的堆内存就是Java堆。</p><p>特点：</p><ul><li>线程共享：Java 堆是虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。</li><li>GC 堆：Java 堆是垃圾收集器管理的主要区域，也被称为”GC堆“。</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>5、方法区（Method Area）</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>特点：</p><ul><li>线程共享</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>6、运行时常量池（Runtime Constant Pool）</p><p>方法区的一部分，常量池表 (Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的RCP中。</p><p>特点：</p><ul><li>动态性，并非预置入 Class 文件常量池的内容才能进入RCP，运行期间也可能将新的常量放入池中。</li></ul><p>7、直接内存（Direct Memory）</p><p>并不是虚拟机运行时数据区的一部分，但也有可能导致<code>OutOfMemoryError</code>。</p><p> </p><p> </p><h1 id="java内存模型jmm">Java内存模型（JMM）</h1><p>抽象的概念，并不真实存在，核心目标是解决多线程环境下的三个问题：</p><ul><li>原子性：一个操作或多个操作要么全部执行成功，要么全部不执行。</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>规定了：</p><ul><li>所有的变量都在主存（MM）中</li><li>每条线程还有自己的工作内存（WM），WM中保存了被该线程使用到的变量的MM副本拷贝。</li><li>线程对变量的所有操作（读取、赋值等）都必须在WM中进行，而不能直接读写MM中的变量。</li><li>不同的线程之间也无法直接访问对方WM中的变量，线程间变量值的传递均需要通过MM来完成。</li></ul><p>当一个线程操作变量时，流程通常是：</p><ul><li>从MM中拷贝变量副本到WM</li><li>在WM中修改副本的值</li><li>在某个时间点，将WM的值刷新回MM</li></ul><p> </p><h2 id="volatile"><code>volatile</code></h2><p>轻量级同步机制，主要解决了可见性和有序性，不保证原子性，开销低，仅能修饰变量。</p><p>保证可见性：当一个变量<code>A</code>被声明为<code>volatile</code>后。</p><ul><li>写：对<code>A</code>的写操作会立刻强制刷新到MM。</li><li>读：对<code>A</code>的读操作会强制从MM中重新读取最新的值。</li></ul><p>保证有序性：通过插入内存屏障来禁止指令重排序。</p><ul><li>写：写之前的所有普通变量的写操作都完成并且已经刷新到MM。</li><li>读：读之后的所有后续普通变量的读/写操作都不会被重排序到该读操作之前。</li></ul><p>局限：不保证原子性，可以用<code>synchronized</code>保证原子性。</p><p> </p><p> </p><h1 id="java对象引用模式">JAVA对象引用模式</h1><p>Java 的引用模式是其内存管理和对象访问的核心，Java通过引用来间接操作所有对象。</p><p>对象：堆内存中实际存在的数据实体，包含了其所属类的所有成员的变量的值。</p><p>引用：一个变量，其值是对象在堆内存中的地址，引用本身存储在栈内存或另一个对象中。</p><p>关键点：</p><ul><li><code>new</code>在堆上创建对象，并返回该对象的地址。</li><li><code>=</code>是复制地址值并非复制对象，多个引用指向同一个对象。</li><li><code>null</code>不指向任何对象。</li></ul><p>参数传递：</p><p>Java中只有按值传递，传递的是地址的副本，并非引用更不是对象。</p><p> </p><h1 id="equals和的区别"><code>equals()</code>和<code>==</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>equlas</code></th><th><code>==</code></th></tr></thead><tbody><tr class="odd"><td>本质</td><td>操作符</td><td>方法（定义在<code>Object</code>类中）</td></tr><tr class="even"><td>比较对象</td><td>内存地址</td><td>内容（需要重写，比如<code>String</code>,<code>Integer</code>）</td></tr><tr class="odd"><td>比较基本类型</td><td>实际值</td><td>不能用于基本类型</td></tr><tr class="even"><td>是否可自定义</td><td>否</td><td>是</td></tr></tbody></table><p> </p><h1 id="arraylist和linkedlist的区别"><code>ArrayList</code>和<code>LinkedList</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr class="odd"><td>底层数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr class="even"><td>获取元素</td><td>O(1)<br>支持随机访问</td><td>O(n)<br>从表头或者表尾开始遍历</td></tr><tr class="odd"><td>插入/删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr class="even"><td>遍历效率</td><td>高</td><td>低</td></tr><tr class="odd"><td>内存占用</td><td>小</td><td>大</td></tr><tr class="even"><td>应用场景</td><td>读多写少，绝大多数情况</td><td>写多读少，栈，队列等</td></tr></tbody></table><p> </p><h1 id="接口">接口</h1><p>一种抽象类型，定义类必须实现的方法的集合，但接口本身不能有方法的具体实现（Java8之后<code>default</code>和<code>static</code>可以实现），主要提供一种规范，使得不同类可以通过统一接口进行交互，而不关心具体实现。</p><p>实现接口：<code>implements</code></p><p>特点：</p><ul><li>多实现</li><li>解耦：减少类之间的耦合</li><li>多态：实现运行时多态</li></ul><p> </p><h1 id="函数覆写">函数覆写</h1><p>子类重新定义从父类继承而来的同名函数，以实现不同的功能。</p><p>要求：</p><ul><li>方法签名相同：函数名，参数个数、类型都必须相同。</li></ul><p><em># 参数列表必须完全相同，不一致则变成函数重载（overload）</em></p><ul><li>访问权限：子类方法的访问权限不能比父类更严格。</li><li>多态体现：当父类指针/引用调用函数时，会根据实际对象类型执行子类方法（支持虚函数/动态绑定）。</li></ul><p>关键字：<code>virtual</code>，<code>override</code></p><p> </p><h1 id="java泛型">Java泛型</h1><p>写一个类或者方法时，不指定具体的数据类型，而是用一个类型参数来代替，使用时再指定具体类型，减少强制类型转换的需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.<span class="built_in">setContent</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str = stringBox.<span class="built_in">getContent</span>(); <span class="comment">// 不需要强转</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.<span class="built_in">setContent</span>(<span class="number">123</span>);</span><br><span class="line">Integer num = intBox.<span class="built_in">getContent</span>();</span><br></pre></td></tr></table></figure><p>不止是类，还可以用于泛型接口，方法等。</p><p>优点：</p><ul><li>类型安全</li><li>减少强制转换</li><li>可读性强</li></ul><p><em># 不能用于基本类型</em></p><p>常用场景：集成框架，工具类方法，通用对象封装。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2025/09/03/springboot/"/>
    <url>/2025/09/03/springboot/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot">SpringBoot</h1><figure><img src="intro.png" alt="介绍" /><figcaption aria-hidden="true">介绍</figcaption></figure><p>SpringBoot是一个Spring模块，提供了RAD(快速应用程序开发)功能。它用于创建独立的基于Spring的应用程序，需要最少的Spring配置就可以运行。</p><p>即Spring框架和嵌入式服务器的组合。</p><blockquote><p>自动配置了 Web 服务、JSON 转换、Tomcat 服务器等，不用手动配置 XML。</p><p>即自带内嵌Tomcat的Java程序，运行后监听<code>localhost:8080</code></p></blockquote><p> </p><p> </p><h1 id="结构">结构</h1><table><thead><tr class="header"><th style="text-align: center;">层</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>@SpringBootApplication</code></td><td style="text-align: center;">主类，入口</td></tr><tr class="even"><td style="text-align: center;">config</td><td style="text-align: center;">配置类，用于全局配置，在启动时加载，注册拦截器等。</td></tr><tr class="odd"><td style="text-align: center;">interceptor</td><td style="text-align: center;">请求到达controller之前/之后的公共逻辑。</td></tr><tr class="even"><td style="text-align: center;">controller</td><td style="text-align: center;">控制层，接受前端请求，并调用服务层。</td></tr><tr class="odd"><td style="text-align: center;">service</td><td style="text-align: center;">服务层，处理业务逻辑，并调用持久层。</td></tr><tr class="even"><td style="text-align: center;">repository</td><td style="text-align: center;">持久层，操作数据库。</td></tr><tr class="odd"><td style="text-align: center;">model</td><td style="text-align: center;">实体层，映射数据库表。</td></tr></tbody></table><p> </p><p> </p><h1 id="注解">注解</h1><h2 id="component"><code>@Component</code></h2><p>作用：在组件扫描时，带有<code>@Component</code>及其衍生注解的类会被注册为Bean，通用组件，任何需要托管的类都可以用这个组件。</p><p>衍生注解：</p><ul><li><code>@Service</code>：服务层，处理业务逻辑。</li><li><code>@Repository</code>：持久层，处理数据库操作。</li><li><code>@Controller</code>：控制层，处理Web请求。</li><li><code>@Configuration</code>：配置类，注册Bean，有动态代理增强。</li></ul><p>用法：注解在类上。</p><h3 id="configuration"><code>@Configuration</code></h3><p>作用：配置类功能，可以用来定义<code>Bean</code>，相当于XML文件，允许在其下使用<code>@Bean</code>的注解来注册Bean到Spring容器。</p><blockquote><p>本质也是个特殊的<code>@Component</code>，会被组件扫描，会启用动态代理增强机制，保证多个<code>@Bean</code>之间安全相互调用，返回的是同一个Bean实例。</p></blockquote><p>用法：注解在类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxx</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="componentscan"><code>@ComponentScan</code></h2><p>作用：组件扫描功能，注册标注了<code>@Component</code>等注解的类为Bean。</p><blockquote><p>扫描范围默认为当前包及其子包的所有组件。</p></blockquote><p>用法：注解在类上。</p><p> </p><h2 id="autowired"><code>@Autowired</code></h2><p>作用：用于将Spring容器内的某个Bean自动注入到另一个类的字段/构造器/方法。</p><blockquote><p>自动注入是IOC（控制反转）的一部分，减少耦合，由Spring容器管理依赖关系。</p></blockquote><p>用法：</p><ul><li>注解在字段上；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;  <span class="comment">// 自动注入Spring容器内的UserRepository类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注解在构造器上；</li><li>注解在Setter方法上</li></ul><h3 id="qualifier"><code>@Qualifier</code></h3><p>作用：自动注入有多个类型匹配的Bean时，明确指定注入哪个Bean。</p><p>用法：和<code>@Autowired</code>一起注解。</p><p> </p><h2 id="requestmapping"><code>@RequestMapping</code></h2><p>作用：请求映射功能，可以映射URL路径，限定HTTP请求方法，匹配请求的其他属性。</p><p>用法：</p><ul><li>注解在类上，定义公共前缀路径。</li><li>注解在方法上，定义具体路径和行为。</li></ul><p>属性：</p><ul><li><code>value</code>：指定URL路径（可省略）</li><li><code>method</code>：指定HTTP方法（GET，POST等）</li><li><code>params</code>：限制请求必须包含/不包含哪些参数</li></ul><p>衍生注解：</p><ul><li><code>@GetMapping("/path")</code>等价于<code>@RequestMapping(value="/path", method=RequestMethod.GET)</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code>：通常包含请求体，请求更新的资源。</li><li><code>@DeleteMapping</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span>  <span class="comment">// 公共前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-list&quot;</span>; <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user-created&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="pathvariable"><code>@PathVariable</code></h2><p>作用：从请求的URL路径中提取参数值，传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><blockquote><p>如果有多个时，如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;userId&#125;/posts/&#123;postId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPostByUser</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId, <span class="meta">@PathVariable(&quot;postId&quot;)</span> Long postId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User ID: &quot;</span> + userId + <span class="string">&quot;, Post ID: &quot;</span> + postId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> </p><h2 id="requestparam"><code>@RequestParam</code></h2><p>作用：从请求的URL查询字符串中提取参数（<code>?key=value</code>），传递到处理方法的参数中。</p><p>用法：注解在形参上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> String name,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam</span> <span class="type">int</span> age</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// name = &quot;Tom&quot;, age = 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Searched for &quot;</span> + name + <span class="string">&quot;, age &quot;</span> + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li><p><code>value/name</code>：指定查询字符串的参数名。</p></li><li><p><code>required</code>：是否必须提供。</p></li></ul><blockquote><p>true（默认）</p></blockquote><ul><li><code>defaultValue</code>：参数缺失时的默认值。</li></ul><p> </p><h2 id="requestbody"><code>@RequestBody</code></h2><p>作用：接收客户端发送的JSON数据并转化为对象。</p><p>用法：注解在形参上。</p><p> </p><h2 id="responsebody"><code>@ResponseBody</code></h2><p>作用：方法的返回值会直接写入HTTP响应体，不会返回视图名，返回JSON或XML数据。</p><p>用法：</p><ul><li><p>在带有<code>@Controller</code>或组合注解标记的类下，注解在方法上。</p></li><li><p>对带有<code>@RequestMapping</code>及其衍生注解（如<code>@GetMapping</code>、<code>@PostMapping</code>等）的请求处理方法起作用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 直接返回字符串内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="entity"><code>@Entity</code></h2><p>作用：JPA库中，标记当前类是一个实体类，对应数据库中的一张表，类下的字段对应表中的列。</p><p>用法：注解在类上。</p><h3 id="id"><code>@ID</code></h3><p>作用：标识实体类的主键字段。</p><p>用法：注解在字段上。</p><h3 id="generatedvalue"><code>@GeneratedValue</code></h3><p>作用：搭配<code>@ID</code>，指定主键的生成策略。</p><p>属性：</p><ul><li><code>strategy</code></li></ul><blockquote><p>GenerationType.IDENTITY：使用数据库的自增长策略来生成主键值。</p></blockquote><p>用法：注解在字段上。</p><p> </p><h2 id="getter和setter"><code>@Getter</code>和<code>@Setter</code></h2><p>作用：Lombok库中，自动生成getter和setter方法。</p><p>用法：注解在类上。</p><p> </p><h2 id="enableautoconfiguration"><code>@EnableAutoConfiguration</code></h2><p>作用：自动配置功能，会根据所添加的依赖如<code>spring-boot-starter-web</code>，<code>spring-boot-starter-data-jpa</code> 等），自动配置好相应的组件，无需手写配置。</p><p>用法：注解在类上。</p><p> </p><h2 id="组合注解">组合注解</h2><h3 id="springbootapplication"><code>@SpringBootApplication</code></h3><p>描述：组合注解，主类入口，包含了<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p><p>用法：注解在类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(StudentApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>SpringApplication.run</code>会启动内置的Tomcat服务器；扫描整个项目；自动注册<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>等组件，运行时在本地监听<code>8080</code>端口。</p></blockquote><p> </p><h3 id="restcontroller"><code>@RestController</code></h3><p>描述：包含了<code>@Controller</code>，<code>@ResponseBody</code>。</p><p>用法：注解在类上。</p><p> </p><p> </p><h1 id="配置文件">配置文件</h1><p>作用：设置应用的全局属性和行为</p><h2 id="server"><code>server</code></h2><p><code>port</code>：设置服务器端口。</p><blockquote><p><code>8080</code></p></blockquote><p> </p><h2 id="spring"><code>spring</code></h2><h3 id="application"><code>application</code></h3><p><code>name</code>：设置应用名称。</p><h3 id="datasource"><code>datasource</code></h3><ul><li><code>url</code>：指定连接到Mysql数据库的地址和端口。</li></ul><blockquote><p><code>jdbc:mysql://localhost:3306/数据库名</code>：默认。</p></blockquote><ul><li><code>driver-class-name</code>：JDBC驱动程序的类名。</li></ul><blockquote><p><code>com.mysql.cj.jdbc.Driver</code></p></blockquote><ul><li><code>name</code></li><li><code>password</code></li></ul><h3 id="jpa"><code>jpa</code></h3><p><code>hibernate.ddl-auto</code>：控制 Hibernate 在启动时对数据库表结构的自动更新行为。</p><blockquote><p><code>update</code>：如果有新的实体类或字段，Hibernate 会自动尝试更新数据库表结构，使其与实体类匹配。</p><p><code>create</code>：每次启动应用时都会删除现有的数据库表，并根据实体类重新创建表格。</p></blockquote><p><code>show-sql</code>：用于开启在控制台显示执行的 SQL 语句。</p><blockquote><p><code>true</code>：开启。</p></blockquote><p> </p><p> </p><h1 id="依赖">依赖</h1><h2 id="spring-boot-starter-web"><code>spring-boot-starter-web</code></h2><p>作用：集成了Web相关的所有常用依赖的启动器。</p><p>内容：</p><ul><li>Spring Web；</li><li>Jackson：用于处理JSON的转换；</li><li>Tomcat：默认嵌入式容器。</li></ul><p> </p><h2 id="spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></h2><p>作用：集成了 Spring Data JPA 提供的 Repository 模式，能够通过接口操作数据库，无需手动编写实现类。</p><p>内容：</p><ul><li>Spring Data JPA：提供接口减少数据库操作；</li><li>Hibernate：映射数据库中的表和Java对象的关系；</li></ul><p> </p><p> </p><h1 id="拦截器">拦截器</h1><h2 id="addinterceptors"><code>addInterceptors()</code></h2><p><code>void addInterceptors(InterceptorRegistry registry)</code></p><p>作用：用于注册拦截器。</p><p>方法：</p><ul><li><code>registry.addInterceptor(自定义的拦截器)</code>：添加哪些拦截器。</li><li><code>registry.addPathPatterns("/path")</code>：拦截哪些路径。</li></ul><p> </p><h2 id="prehandle"><code>preHandle()</code></h2><p><code>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code></p><p>作用：在请求到达Controller前执行，如果返回 <code>false</code>，请求会被终止，不会进入后续的 Controller 或 <code>postHandle()</code>、<code>afterCompletion()</code> 方法。</p><p>关键方法：</p><ul><li><code>request.getMethod()</code>：返回请求方法（Get/Post）。</li><li><code>getRequestURI()</code>：返回请求路径。</li></ul><p> </p><p> </p><h1 id="持久层">持久层</h1><h2 id="crudrepository"><code>CrudRepository</code></h2><h3 id="findall"><code>findAll()</code></h3><p><code>Iterable&lt;T&gt; findAll()</code></p><p>作用：表示查询结果的集合。</p><blockquote><p>可以直接转化为<code>List&lt;S&gt;</code>返回。</p></blockquote><p> </p><h3 id="save"><code>save()</code></h3><p><code>S save(S entity)</code></p><p>作用：根据实体是否有ID来执行插入或者更新操作，返回保存后的实体对象。</p><p> </p><h3 id="findbyid"><code>findById()</code></h3><p><code>Optional&lt;S&gt; findById(id)</code></p><p>作用：从数据库中查询<code>id</code>的实体，并返回<code>Optional</code>类，可以存储一个实体，也可以表示没有值。</p><blockquote><p>配合<code>orElseThrow()</code>，<code>Optional</code>的方法，如果有值则会返回值，无值则为抛出异常，例如可以配合Lambda表达式<code>() -&gt; new RuntimeException("xxx not found")</code>。</p></blockquote><p> </p><h3 id="delete"><code>delete()</code></h3><p><code>void delete(T entity)</code></p><p>作用：根据实体删除。</p><blockquote><p><code>void deleteById(ID id)</code>可以根据<code>id</code>删除。</p></blockquote><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ssh连接github失败</title>
    <link href="/2025/08/27/sshBug/"/>
    <url>/2025/08/27/sshBug/</url>
    
    <content type="html"><![CDATA[<p>先尝试<code>ssh -T git@github.com</code>。</p><p> </p><p>有可能是22端口被阻隔了，尝试443端口，在config中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com </span><br><span class="line">        Hostname ssh.github.com </span><br><span class="line">        Port 443</span><br><span class="line">        User git</span><br><span class="line">        ProxyCommand connect -S 系统代理地址 %h %p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2025/08/26/machineLearning/"/>
    <url>/2025/08/26/machineLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><figure><img src="machineLearningProcess.png" alt="流程示例" /><figcaption aria-hidden="true">流程示例</figcaption></figure><figure><img src="mlClassfication.png" alt="类型" /><figcaption aria-hidden="true">类型</figcaption></figure><figure><img src="mlWork.png" alt="工作流" /><figcaption aria-hidden="true">工作流</figcaption></figure><p> </p><h1 id="神经网络">神经网络</h1><figure><img src="cnnBasic.png" alt="基础" /><figcaption aria-hidden="true">基础</figcaption></figure><p>神经元接收输入信号，通过加权求和后与偏置相加，然后通过激活函数处理以产生输出。神经元的权重和偏置是网络学习过程中需要调整的参数。</p><p> </p><h2 id="前馈神经网络">前馈神经网络</h2><figure><img src="fnn.png" alt="Feedforward Neural Network，FNN" /><figcaption aria-hidden="true">Feedforward Neural Network，FNN</figcaption></figure><p>基本单元，前馈神经网络特点是数据从输入层开始，经过一个或多个隐藏层，最后到达输出层，全过程没有循环或反馈。</p><p> </p><h2 id="循环神经网络">循环神经网络</h2><figure><img src="rnn.png" alt="Recurrent Neural Network, RNN" /><figcaption aria-hidden="true">Recurrent Neural Network, RNN</figcaption></figure><p>专门处理序列数据的神经网络，能够捕获输入数据中时间或顺序信息的依赖关系,在自然语言处理（NLP）、语音识别、时间序列预测等任务中有着广泛的应用。</p><p>关键特性：其能够保持隐状态（hidden state），使得网络能够记住先前时间步的信息。</p><p>隐状态：通过上一时间步的隐状态和当前输入共同计算得到的。</p><p> 公式：<span class="math inline"><em>h</em><sub><em>t</em></sub> = <em>f</em>(<em>W</em><sub><em>h</em><em>h</em></sub><em>h</em><sub><em>t</em> − 1</sub> + <em>W</em><sub><em>x</em><em>h</em></sub><em>x</em><sub><em>t</em></sub> + <em>b</em><sub><em>h</em></sub>)</span></p><p><em># <span class="math inline"><em>h</em><sub><em>t</em></sub></span>：当前时刻隐状态；<span class="math inline"><em>h</em><sub><em>t</em> − 1</sub></span>：前一时刻隐状态；<span class="math inline"><em>W</em><sub><em>x</em><em>h</em></sub>, <em>W</em><sub><em>h</em><em>h</em></sub></span>：权重矩阵；<span class="math inline"><em>x</em><sub><em>t</em></sub></span>：当前时刻的输入；<span class="math inline"><em>b</em><sub><em>h</em></sub></span>：偏置；<span class="math inline"><em>f</em>()</span>：激活函数。</em></p><p>输出：不仅依赖当前输入，还依赖于隐状态的历史信息。</p><p> 公式：<span class="math inline"><em>y</em><sub><em>t</em></sub> = <em>W</em><sub><em>h</em><em>y</em></sub><em>h</em><sub><em>t</em></sub> + <em>b</em><sub><em>y</em></sub></span></p><p><em># <span class="math inline"><em>y</em><sub><em>t</em></sub></span>：t时刻的输出向量；<span class="math inline"><em>W</em><sub><em>h</em><em>y</em></sub></span>：隐状态到输出状态的矩阵。</em></p><figure><img src="unfoldRnn.png" alt="展开视图" /><figcaption aria-hidden="true">展开视图</figcaption></figure><p> </p><h2 id="卷积神经网络">卷积神经网络</h2><figure><img src="cnn.png" alt="Convolutional Neural Networks, CNN" /><figcaption aria-hidden="true">Convolutional Neural Networks, CNN</figcaption></figure><p>专门用于处理具有网格状拓扑结构数据（如图像）的深度学习模型，是计算机视觉任务（如图像分类、目标检测和分割）的核心技术。</p><p> </p><h2 id="transformer模型">Transformer模型</h2><p>一种基于注意力机制的深度学习模型，仅依赖注意力机制来处理序列数据，从而实现更高的并行性和更快的训练速度。</p><figure><img src="transformer.png" alt="transformer结构" /><figcaption aria-hidden="true">transformer结构</figcaption></figure><p>结构：</p><ul><li>编码器（Encoder）：由NN层相同的模块堆叠而成，每层包含两个子层，每个子层后面都接有 残差连接（Residual Connection） 和 层归一化（Layer Normalization）。</li></ul><p> 多头自注意力机制（Multi-Head Self-Attention）：计算输入序列中每个词与其他词的相关性。</p><p> 前馈神经网络（FNN）：对每个词进行独立的非线性变化。</p><ul><li>解码器（Decoder）：由NN层相同的模块堆叠而成，每层包含三个子层，每个子层后面都接有残差连接和层归一化。</li></ul><p> 掩码多头自注意力机制（Masked Multi-Head Self-Attention）：计算输出序列中每个词和其他词的相关性。</p><p><em># 使用掩码防止未来信息泄露</em></p><p> 交叉注意力机制（Encoder-Decoder Attention）：计算输出序列与输入序列的相关性。</p><p> 前馈神经网络（FNN）</p><p>核心思想：</p><ul><li>自注意力机制（Self-Attention）：允许模型在处理序列时，动态地为每个位置分配不同的权重，从而捕捉序列中任意两个位置之间的依赖关系。</li><li>多头注意力（Multi-Head Attention）：将输入分成多个子空间，每个子空间独立计算注意力，最后将结果拼接起来。</li><li>位置编码（Positional Encoding）：位置编码被用来为输入序列中的每个词添加位置信息，代替序列信息（如RNN中的时间步）。</li></ul><p>优势：并行计算，长距离依赖（解决RNN的梯度消失），可扩展性。</p><p>应用：NLP（机器翻译，GPT），CV（图像分类，目标检测），多模态任务。</p><p> </p><p> </p><h1 id="conda指令">Conda指令</h1><p> 查看环境：<code>conda env list</code></p><p> 进入环境：<code>conda activate 环境名称</code></p><p> 退出环境：<code>conda deactivate</code></p><p> 删除环境：<code>conda remove --name 环境名称 --all</code></p><p> 更换为阿里云镜像源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p><p> 查看当前源：<code>pip config list</code></p><p> 查看当前包：<code>pip list</code></p><p> 下载依赖包requirements.txt：<code>pip install -r requirements.txt</code></p><p> </p><p> </p><h1 id="训练模型">训练模型</h1><p>模型文件=模型结构+预训练权重</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/2025/08/22/web/"/>
    <url>/2025/08/22/web/</url>
    
    <content type="html"><![CDATA[<p>Json对象和数组：</p><p>​ 对象是键值对集合，数组是值的有序列表；</p><p>​ Json对象的值可以包含数组，数组的元素也可以是一个对象，能够支持多层嵌套。</p><p> </p><p>前端渲染和后端渲染：</p><figure><img src="render.png" alt="render.png" /><figcaption aria-hidden="true">render.png</figcaption></figure><p>​ 前端渲染：React,Vue等；后端渲染：传统PHP,Java,Python等。</p><p>​ 现代开发常采用混合方案：同构渲染，首次访问使用SSR快速呈现内容，后续交互转为CSR提供流畅体验，如 Next.js (React), Nuxt.js (Vue)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript</title>
    <link href="/2025/08/22/javascript/"/>
    <url>/2025/08/22/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="文件与拖拽api的底层原理">文件与拖拽API的底层原理</h1><p>文件API：</p><p> 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；</p><p> 无路径访问：JavaScript无法知晓真正的文件路径；</p><p> 同源限制：读取的文件内容只能在当前页面上下文使用。</p><p>拖拽API：</p><p>拖拽本质是操作系统提供的跨应用（跨源）通信机制。</p><p>过程：</p><p> 拖拽开始时，OS创建“拖拽会话”；</p><p> 拖拽过程中，系统跟踪光标位置并查询下方的放置目标；</p><p> 放置时，系统协调数据传递。</p><figure><img src="dragAndDrop.png" alt="拖拽实现的层次" /><figcaption aria-hidden="true">拖拽实现的层次</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascipt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/2025/08/22/dsa/"/>
    <url>/2025/08/22/dsa/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="枚举算法">枚举算法</h2><p>描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。</p><p>核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解，关注枚举的上下界。</p><p>优点：简单基本，便于实现，容易调试，正确性容易证明。</p><p>流程：</p><ul><li><p>确定枚举对象、枚举的上下界、判断条件。</p></li><li><p>枚举可能的情况并验证是否是问题的解。</p></li><li><p>考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。</p><p>题库：百钱买百鸡，LeetCode78，611，1504，1733，2749。</p></li></ul><p> </p><h2 id="贪心算法">贪心算法</h2><p>描述：每一步都做出在当前看来是最好的选择，期望通过局部最优选择来达到全局最优解。</p><p>核心思想：局部最优，不可回溯，期望全局最优。</p><blockquote><p>贪心只做局部最优选择，不保证全局最优。</p></blockquote><p>优点：高效，简单直观。</p><p>流程：</p><ul><li>建立数学模型</li><li>分解问题</li><li>制定贪心策略</li><li>求解子问题</li><li>合并成原问题解</li></ul><p>题库：LeetCode134，1792，2598，3350，3397。</p><p> </p><h2 id="回溯算法">回溯算法</h2><p>描述：通过深度优先(DFS)搜索策略来遍历所有可能的候选解，并在搜索过程中利用剪枝来避免无效搜索，提高效率。</p><p>核心思想：</p><ul><li>路径：从根节点到当前节点所做出的选择序列。</li><li>选择列表：在当前节点可以做出的所有选择。</li><li>结束条件：找到一个解或停止。</li></ul><p>流程：</p><ul><li>在当前节点遍历所有选择</li><li>找到解做出选择并加入当前路径</li><li>递归进入下一个状态</li><li>递归返回后，撤销刚才的选择（<strong>回溯</strong>）</li></ul><p>可以配合lamdba表达式<code>auto dfs&#123;&#125;;</code></p><p>题库：LeetCode 22，39。</p><p> </p><h2 id="动态规划">动态规划</h2><p>描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，能够避免重复计算子问题。</p><p>分成记忆化递归（自顶向下）和DP数组（自底向上）两种动态规划。</p><p>核心思想：拆分子问题、记住过往、减少重复计算。</p><p>流程：</p><ul><li><p>穷举分析</p></li><li><p>确认边界</p><ul><li>找出规律，确定最优子结构<ul><li>动态规划问题即是递推问题，当前的决策结果是<code>f(n)</code>，则最有子结构就是要让<code>f(n-k)</code>最优，并且与后面的决策没有关系，能让后面的决策安心使用局部最优解。</li></ul></li><li>写出状态转移方程</li></ul></li></ul><p>题库：LeetCode62，120，1277，1504，2327，3186，3494。</p><p> </p><h2 id="位运算算法">位运算算法</h2><p>大大提高程序的性能，0/1问题时好用。</p><p>题库：LeetCode78，2749。</p><p> </p><h2 id="模拟">模拟</h2><p>描述：完全按照题目的描述或者问题的真实发生过程，一步步地用代码复现出来从而得到答案。</p><p>核心思想：重视还原，过程再现。</p><p>流程：</p><ul><li>提炼规则</li><li>设计数据结构</li><li>分解步骤，模块化</li><li>注意边界</li></ul><p>特点：思路直观，实现繁琐。</p><p>题库：LeetCode6，54，3446。</p><p> </p><h2 id="堆算法">堆算法</h2><p>描述：特殊的完全二叉树，可以用一维数组存储。</p><p>堆的更新和维护：</p><p> 入堆push()，时间复杂度<code>O(log n)</code></p><p> 出堆pop()，时间复杂度<code>O(log n)</code></p><p> 访问栈顶top()，时间复杂度<code>O(1)</code></p><p> 建堆，时间复杂度<code>O(nlog n)</code></p><p><em># 即堆中插入n个元素</em></p><p>应用：优先队列。</p><p>题库：LeetCode 1792。</p><p> </p><h2 id="分支限界法">分支限界法</h2><p>描述：</p><ul><li>分支：将大问题划分为若干子问题，形成解空间树，每个结点代表一个子问题，每条分支表示对子问题的一种约束或决策。</li><li>限界：对每个子问题，计算一个上下界，即它可能取得的最优解的范围，如果某个子问题的最优解范围不可能优于当前已知的最优解，就剪枝（丢弃该子问题）。</li></ul><p>流程：</p><ul><li>定义问题的解空间</li><li>从根结点开始分支，产生子问题</li><li>对每个子问题计算限界</li><li>子问题放入候选结点表（队列/堆等）</li><li>从候选结点表中选择结点展开（搜索策略）</li><li>结点满足约束并且更优就继续分支，不满足就剪枝</li><li>重复直到候选结点表为空或者找到全局最优</li></ul><p>题库：0-1背包问题。</p><p> </p><h2 id="双指针">双指针</h2><p>描述：使用两个指针（索引）在数据结构中协同工作，一般分为同向指针或者相向指针。</p><p>滑动窗口也是一种双指针，左指针收缩窗口，右指针扩展窗口。</p><p>流程：</p><ul><li>数据结构进行排序</li><li>边界</li><li>指针移动条件</li><li>重复元素处理</li></ul><p>题库：LeetCode75，611， 2348。</p><p> </p><h2 id="前缀和">前缀和</h2><p>描述：一个数组中，从第一个元素到当前元素的累加和。</p><p>将区间求和的操作从O(n)优化为O(1)，例如，求<code>sum[l,r]</code>的暴力解法是遍历<code>[l,r]</code>，时间复杂度O(n)；而预先处理<code>prefix[i]</code>，<code>sum[l,r]</code>即为<code>prefix[r]-prefix[l-1]</code>，时间复杂度O(1)。</p><p>核心思想：预处理前缀和，换取查询效率；适合于频繁查询但不修改。</p><p>题库：LeetCode3147。</p><p> </p><p> </p><h1 id="结构">结构</h1><h2 id="折半查找树">折半查找树</h2><p>即二叉搜索树，Binary Search Tree，BST</p><p>每个结点最多有两个孩子，对于任一结点<code>node</code>：</p><p>左子树上的所有键小于<code>node-&gt;key</code>，右子树上的所有键大于<code>node-&gt;key</code>。</p><p>若树的高度为<code>h</code>，查找/插入/删除复杂度为O(h)，遍历O(n)。</p><p> </p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><p>包括深度优先遍历（DFS）和广度优先遍历（BFS）</p><p>1、深度优先遍历</p><p>按访问顺序不同，可分为前序遍历，中序遍历，后序遍历。</p><p>（1）前序遍历</p><p>顺序：根 -&gt; 左子树 -&gt; 右子树</p><p>可以用于复制树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><p>顺序：左子树 -&gt; 根 -&gt;右子树</p><p>对于二叉搜索树来说，中序遍历的结果就是升序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><p>顺序：左子树 -&gt; 右子树 -&gt; 根</p><p>删除树节点或者释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、广度优先遍历</p><p>又叫层序遍历，从根节点开始逐层从左到右访问。</p><p>输出层次结构，求出树的高度、最短路径等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//队列，FIFO</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="有向图邻接表">有向图邻接表</h2><p>常用的图存储结构，适合存储稀疏图（顶点多，边少）</p><ul><li>有向图：每条边都有方向，比如<code>u-&gt;v</code>表示从顶点<code>u</code>指向顶点<code>v</code>。</li><li>邻接表：为图中的每个顶点建立一个链表/动态数组，存储从该顶点出发的所有边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>; <span class="comment">// 顶点个数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，1-based</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">adj[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">adj[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> </p><p> </p><h1 id="stl">STL</h1><h2 id="ascii">ASCII</h2><p>小写字母的ASCII码=大写字母的ASCII码+32。</p><p> </p><h2 id="正整数向上取整">正整数向上取整</h2><p>方法：<code>int div=(a+b-1)/b</code></p><p>如果<code>a</code>整除<code>b</code>，那么加上的<code>b+1</code>还不足以跨越到下一个整数；如果<code>a</code>不整除<code>b</code>，那么跨越下一个整数。</p><p> </p><h2 id="int最小数和最大数">int最小数和最大数</h2><p><code>INT_MIN</code>和<code>INT_MAX</code>，分别为-2<sup>31</sup>和2<sup>31</sup>-1。</p><p> </p><h2 id="整数取模的最小非负整数">整数取模的最小非负整数</h2><p><code>(x%m+m)%m</code>，<code>x</code>如果为负数，加上<code>m</code>变为正数再取模；<code>x</code>为正数和<code>0</code>无影响。</p><p> </p><h2 id="swap"><code>swap()</code></h2><p>格式：<code>void swap(T&amp; a,T&amp; b)</code></p><p>时间复杂度和空间复杂度都是O(1)。</p><p> </p><h2 id="sort"><code>sort()</code></h2><p>格式：<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p><p>额外的：<code>ranges::sort(xx)</code>等价于<code>std::(sort.begin(),sort.end())</code></p><p>注意：</p><ul><li>迭代器范围：<code>[first, last)</code>是一个左闭右开的区间，例如使用索引和迭代器结合时要用<code>begin()+i</code>和<code>begin()+j+1</code>。</li><li>性能：时间复杂度为O(nlogn)。</li></ul><p> </p><h2 id="min_element"><code>min_element()</code></h2><p>格式：<code>min_element(begin(),end())</code></p><p>作用：返回<code>[begin,end)</code>范围内最小的迭代器，可以在前面加解引用符号<code>*</code>，即为返回值。</p><p>示例：<code>return *min_element(matrix.begin(),matrix.end())</code></p><p> </p><h2 id="lower_bound"><code>lower_bound()</code></h2><p>格式：<code>auto it = lower_bound(xx.begin(),xx.end(),x)</code></p><p>作用：找到这个容器下第一个大于等于<code>x</code>的元素，并返回迭代器（要求容器有序）。</p><p>平均时间复杂度：O(log n)。</p><p> </p><h2 id="clamp"><code>clamp()</code></h2><p>格式：<code>int x=clamp(value,lo,hi)</code></p><p>作用：返回区间[lo,hi]之间最接近value的值。</p><blockquote><p>即为<code>min(max(value, lo), hi)</code></p></blockquote><p> </p><h2 id="static"><code>static</code></h2><p>作用于局部变量时：使得变量的生命周期延长至整个程序运行期间，而不是随着函数调用结束而销毁。</p><p>作用于成员变量时：所有该类的对象共享同一个静态成员变量。</p><p> </p><h2 id="优先队列">优先队列</h2><p>特殊的队列，每个元素都有优先级，最先取出优先级最高的元素，在<code>struct&#123;&#125;;</code>中提前声明。</p><p>核心实现：二叉堆（最大堆<code>priority_queue</code>/最小堆），堆顶是最大/最小元素。</p><p>格式：<code>priority_queue&lt;元素类型,底层容器类型,比较函数类型&gt;</code></p><p><em># 注：声明忽略后面两个参数时自动按照最大堆排列，即按照从前往后比较的最大元素的排列。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，char可以换成自定义的struct</span></span><br><span class="line">priority_queue&lt;<span class="type">char</span>,vector&lt;<span class="type">char</span>&gt;,CompareASCII&gt;pq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重载运算符：</p><p><em># 一般<code>const</code>修饰，重载运算符不必修改对象，引用传递避免不必要的拷贝，提高效率，返回值必须为bool。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆，栈顶是优先级最小的，最大堆反之用&lt;。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareASCII</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; a,<span class="type">const</span> <span class="type">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入：<code>push()</code>（只能接受一个参数，必须是已经构造好的元素）或者<code>emplace()</code></p><p><em># 不支持随机访问修改</em></p><p>时间复杂度：插入和删除都是<code>O(log n)</code>。</p><p> </p><h2 id="vector">Vector</h2><p> 长度：<code>size()</code></p><p> 在末尾添加一个元素：<code>push_back(数组的一个数据)</code></p><p> 直接在末尾构造对象：<code>emplace_back(构造需要的数据)</code>，和<code>push_back()</code>区别不大，省去一次拷贝。</p><p><em># 二维数组添加一维数组同理</em></p><p> 释放原有资源并构造新的容器，属性和传进来的容器一致：<code>新的容器=move(数组)</code></p><p> 清空所有元素：<code>clear()</code></p><p> 是否为空矩阵：<code>empty()</code></p><p> </p><h2 id="string">String</h2><p> 长度：<code>length()</code></p><p> 获取子字符串：<code>substr(size_t pos,size_t len)</code></p><p> 找到子字符或子字符串：<code>find()</code>，返回起始位置</p><p><em># <code>pos</code>：子字符串的起始位置，默认0；<code>len</code>：提取的字符数量，默认一直提取到末尾</em></p><p> 将字符串转换为整数：<code>stoi(const string&amp; s,size_t* idx,int base)</code></p><p><em># <code>s</code>：需转换的字符串；<code>idx</code>：可选指针；<code>base</code>：可选的转换的进制</em></p><p> 删除最后一个字符：<code>pop_back()</code></p><p><em># 字符串不能为空</em></p><p> </p><h2 id="位运算">位运算</h2><p> 计算整数中二进制为1的个数：<code>popcount(T x)</code></p><p><em># <code>T</code>：无符号的整数类型，例如<code>unsigned int</code>，<code>unsigned long</code>，<code>uint64_t</code>等；<code>x</code>：整数</em></p><p> </p><h2 id="模板类">模板类</h2><h3 id="pair"><code>&lt;pair&gt;</code></h3><p>定义好的迷你结构体，将两个数据打包成一个整体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    T1 first;   <span class="comment">// 第一个元素</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>T1</code>和<code>T2</code>可以为其他不同类型，例如<code>pair&lt;int,string&gt;</code>，经常用于键值对，函数返回值，构造容器等。</p><p> </p><h3 id="tuple"><code>&lt;tuple&gt;</code></h3><p>固定大小，异质（可以是不同类型）的容器</p><p>构造：<code>tuple&lt;T1,T2,T3&gt; myTuple(t1,t2,t3)</code></p><p>访问：<code>T1 first=get&lt;0&gt;(myTuple)</code>，也可以修改</p><p>支持比较：比较的是字典序</p><p> </p><h2 id="无序有序关联容器">无序/有序关联容器</h2><h3 id="无序基于哈希表实现">无序：基于哈希表实现</h3><p>1、哈希集合：<code>unordered_set&lt;key&gt;</code></p><ul><li><p>元素是唯一的，检查一个元素是否存在于集合当中</p></li><li><p>用法：</p><ul><li><p>插入：<code>insert(key)</code></p></li><li><p>查找：<code>find(key)</code>，返回的是迭代器，一般配合<code>end()</code>使用进行判断</p></li><li><p>删除：<code>erase(key)</code></p></li></ul></li></ul><p>2、哈希表：<code>unordered_map&lt;key,value&gt;</code></p><ul><li><p>key是唯一的</p></li><li><p>用法：</p><ul><li>插入：<code>insert(&#123;key,value&#125;)</code>，或者<code>map[key]=value</code></li></ul><blockquote><p>注意，<code>it</code>指向<code>pair&lt;const Key, Value&gt;</code>的对象，不能通过<code>it</code>修改键，但可以修改值，<code>it-&gt;first</code>是键，<code>it-&gt;second</code>是值。</p></blockquote><ul><li>访问：<code>map[key]</code></li></ul></li></ul><p>3、性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(1)，但最坏情况可能是O(n)。</li><li>元素顺序：无序</li></ul><h3 id="有序基于红黑树实现">有序：基于红黑树实现</h3><p>红黑树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(log n)，从而确保了所有主要操作的时间复杂度都是稳定的 O(log n)。</p><p>有序集合：<code>set&lt;key&gt;</code>和有序表：<code>map&lt;key,value&gt;</code></p><blockquote><p>用法同哈希集合和哈希表。</p></blockquote><p>性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(log n)</li><li>元素顺序：默认按键排列升序</li></ul><p> </p><h2 id="listsetmap">List，Set，Map</h2><table><thead><tr class="header"><th>特性</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr class="odd"><td>顺序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr class="even"><td>可重复</td><td>可以</td><td>不可以</td><td>键不重复</td></tr><tr class="odd"><td>访问方式</td><td>下标索引</td><td>无索引</td><td>key查找</td></tr><tr class="even"><td>用途</td><td>保存序列</td><td>保存唯一元素</td><td>键值对应关系</td></tr></tbody></table><p> </p><h2 id="链表">链表</h2><p>线性数据结构，链表中的元素在内存中不是连续存放的，通过指针将一系列节点连接起来，形成逻辑上的序列。</p><p>节点：</p><ul><li>数据域：用于存储实际的数据（可以是整数、字符串、对象等）。</li><li>指针域：一个指向下一个节点的指针。</li></ul><p>单向链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据域，这里以整数为例</span></span><br><span class="line">    ListNode* next;     <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，方便创建节点</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构：</p><ul><li>头节点：链表的第一个节点。通过一个指向头节点的指针（<code>head</code>）来访问整个链表。如果链表为空，<code>head</code> 指针为 <code>nullptr</code>。</li><li>尾节点：链表的最后一个节点。它的 <code>next</code> 指针指向 <code>nullptr</code>。</li></ul><p>方法：</p><ul><li>创建链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建几个节点</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>遍历链表：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头部插入节点（时间复杂度O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtHead</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点的next指向原来的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;       <span class="comment">// 新节点成为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾部插入节点（时间复杂度O(n)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertAtTail</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode; <span class="comment">// 如果链表为空，新节点就是头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 将尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除节点（时间复杂度O(n)，已知位置就是O(1)）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == val) &#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找要删除节点的前一个节点</span></span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span> &amp;&amp; current-&gt;next-&gt;data != val) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>内存管理：在 C++ 中使用 <code>new</code> 创建的节点，必须使用 <code>delete</code> 手动释放，否则会导致内存泄漏。</li><li>指针安全：操作指针时要格外小心，避免访问 <code>nullptr</code> 或已删除的内存（野指针）。</li><li>边界条件：处理空链表、单节点链表等情况时要特别注意。</li></ul><p> </p><h2 id="inline"><code>inline</code></h2><p>内联函数，编译器会尝试用函数内的代码替换掉函数调用语句</p><p>传统函数调用过程：</p><ul><li>执行到函数调用语句</li><li>将返回地址，参数等压入栈</li><li>跳转到函数体的内存地址开始执行</li><li>函数执行完毕，将返回值存入指定位置</li><li>跳转回之前保存的地址，继续执行调用处的下一条指令</li></ul><p>这个过程对于功能简单，调用频繁的小函数，这种开销可能比函数本身执行的时间还长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>减少调用开销</li><li>避免宏定义的缺点</li></ul><p> </p><h1 id="lambda表达式">Lambda表达式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// lambda 递归函数例子1</span></span><br><span class="line">   <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有两个点，无法组成三角形</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用，修改 res 相当于修改 memo[i][j]</span></span><br><span class="line">       <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       res = INT_MAX;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123; <span class="comment">// 枚举顶点 k</span></span><br><span class="line">           res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + v[i] * v[j] * v[k]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">// lambda 递归函数例子2</span></span><br><span class="line">   <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs,<span class="type">int</span> i)-&gt;<span class="type">long</span> <span class="type">long</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="type">long</span>&amp; res=memo[i];</span><br><span class="line">       <span class="keyword">if</span>(res!=<span class="number">-1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">auto</span>&amp; [d,count]=damage[i]; <span class="comment">//单纯读取，此处不使用引用也可以</span></span><br><span class="line">       <span class="type">int</span> j=i;</span><br><span class="line">       <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;damage[j<span class="number">-1</span>].first&gt;=d<span class="number">-2</span>)&#123;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       res=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>),<span class="built_in">dfs</span>(j<span class="number">-1</span>)+(<span class="type">long</span> <span class="type">long</span>)d*count);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p><em># <code>[&amp;]</code>表示能够访问外部作用域所有变量，<code>this auto&amp;&amp;</code>允许Lambda实现自递归，<code>-&gt;int</code>表示返回类型为整数，<code>int &amp; res</code>表示修改这个值同时会修改对应的的<code>memo</code>的值，实现记忆化。</em></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2025/08/22/hexo/"/>
    <url>/2025/08/22/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo指令">Hexo指令：</h1><p> 新建博客：<code>hexo new'xxx'</code></p><p> 清除之前所有的公共文件：<code>hexo clean</code></p><p> 重新生成html文件：<code>hexo g</code></p><p> 上传到GitHub：<code>hexo d</code></p><p>==&gt;清除/生成/部署：<code>hexo clean &amp;&amp; hexo g -d</code></p><p> 查看hexo版本：<code>hexo version</code></p><p> </p><h1 id="hexo美化">Hexo美化</h1><p> </p><h1 id="git指令">Git指令：</h1><p> 测试Github到SSH的连接：<code>ssh -T git@github.com</code></p><p> 测试到Github的网络连接是否通畅：<code>ping github</code></p><p><em># ping命令使用 ICMP 协议，git 命令使用 HTTP/HTTPS 协议。</em></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ping</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标记语言</title>
    <link href="/2025/08/22/markdown/"/>
    <url>/2025/08/22/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法">Markdown语法</h1><h2 id="链接">链接</h2><p>效果：<a href="url">链接文本</a></p><p>格式：<code>[链接文本](url)</code></p><p> </p><h2 id="指数">指数</h2><p>效果：2<sup>n</sup></p><p>格式：<code>2&lt;sup&gt;n&lt;/sup&gt;</code></p><p> </p><h2 id="列表">列表</h2><p>效果：</p><ul><li><p>列表一</p></li><li><p>列表二</p><p>格式：<code>- 列表一</code></p></li></ul><p> </p><h2 id="斜体">斜体</h2><p>效果：<em>斜体</em></p><p>格式：<code>*斜体*</code></p><p> </p><h2 id="加粗">加粗</h2><p>效果：<strong>加粗</strong></p><p>格式：<code>**加粗**</code></p><p> </p><h2 id="公式">公式</h2><p>效果：<span class="math inline"><em>h</em><sub><em>t</em></sub></span></p><p>格式：<code>$h_t$</code></p><p> </p><h2 id="表格">表格</h2><p>效果：</p><table><thead><tr class="header"><th>列A</th><th>列B</th></tr></thead><tbody><tr class="odd"><td></td><td></td></tr></tbody></table><p>格式：<code>|列A|列B|</code></p><p> </p><h2 id="引用">引用</h2><p>效果：</p><blockquote><p>引用部分</p></blockquote><p>格式：<code>&gt; 引用部分</code></p><p> </p><p> </p><h1 id="latex语法">LaTex语法</h1><h2 id="数学符号">数学符号</h2><h3 id="中括号">中括号</h3><p><span class="math display">$$\left \{\begin{aligned}&amp; abc\\&amp; def\end{aligned}\right.$$</span> 格式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\left</span> <span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">&amp;</span> abc</span><br><span class="line"><span class="keyword">\\</span><span class="built_in">&amp;</span> def</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\right</span>.</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">∈</span></td><td style="text-align: center;"><code>\in</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">∀</span></td><td style="text-align: center;"><code>\forall</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">∩</span></td><td style="text-align: center;"><code>\cap</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">≤</span></td><td style="text-align: center;"><code>\leq</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">⋯</span></td><td style="text-align: center;"><code>\cdots</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">$\frac{a}{b}$</span></td><td style="text-align: center;"><code>\frac&#123;a&#125;&#123;b&#125;</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline"><em>a</em><sub><em>b</em></sub></span></td><td style="text-align: center;"><code>a_b</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>a</em><sup><em>b</em></sup></span></td><td style="text-align: center;"><code>a^b</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">$\text abc$</span></td><td style="text-align: center;"><code>\text abc</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>a</em>  <em>b</em></span></td><td style="text-align: center;"><code>a \quad b</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">$\sum_{i=1}^n$</span></td><td style="text-align: center;"><code>\sum_&#123;i=1&#125;^n</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>x̄</em></span></td><td style="text-align: center;"><code>\bar x</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">{}</span></td><td style="text-align: center;"><code>\&#123;\&#125;</code></td></tr></tbody></table><p> </p><h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th style="text-align: center;">效果</th><th style="text-align: center;">格式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline"><em>δ</em></span></td><td style="text-align: center;"><code>\delta</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>Δ</em></span></td><td style="text-align: center;"><code>\Delta</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">∇</span></td><td style="text-align: center;"><code>\nabla</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">∂</span></td><td style="text-align: center;"><code>\partial</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline"><em>θ</em></span></td><td style="text-align: center;"><code>\theta</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>λ</em></span></td><td style="text-align: center;"><code>\lambda</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline"><em>ε</em></span></td><td style="text-align: center;"><code>\varepsilon</code></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline"><em>α</em></span></td><td style="text-align: center;"><code>\alpha</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2025/08/22/vue/"/>
    <url>/2025/08/22/vue/</url>
    
    <content type="html"><![CDATA[<p>Vue3</p><p>​ 描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。</p><p>​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。</p><p>​ 命令：</p><p><em># 创建Vue项目</em> <code>npm init vue@latest</code></p><p><em># 启动开发服务器</em></p><p><code>npm install</code></p><p><code>npm run dev</code></p><p><em># 打开图形化界面</em></p><p><code>npm install @vue/cli</code></p><p><code>vue ui</code></p><p>Vite</p><p>​ 描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。</p><p>​ 组成：</p><ul><li><p>开发服务器：基于原生ES模块，提供超快的热更新。</p></li><li><p>构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。</p><p>优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2025/08/22/docker/"/>
    <url>/2025/08/22/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><p>描述：开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>优点：跨平台一致性，资源高效，快速部署，隔离性。</p><p>基本命令：</p><p> 查看运行中的容器：<code>docker  ps</code></p><p> 进入容器内部：<code>docker exec -it &lt;容器ID&gt; /bin/bash</code></p><p> 杀死进程：<code>kill -9 项目ID</code></p><p>命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2025/08/22/computerNetworks/"/>
    <url>/2025/08/22/computerNetworks/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip">TCP/IP</h1><h2 id="五层模型">五层模型</h2><p> 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。</p><p> 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。</p><p> 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。</p><p> 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。</p><p> 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。</p><h2 id="http请求过程">HTTP请求过程</h2><p>从浏览器，操作系统，网络设备到服务器共同参与的协作过程。</p><p> 过程：</p><figure><img src="http.png" alt="八个阶段" /><figcaption aria-hidden="true">八个阶段</figcaption></figure><p>1、URL解析</p><p>用户输入，浏览器解析（协议、域名、路径），浏览器检查</p><p>2、DNS域名解析</p><p>浏览器查找顺序（浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; 网络服务供应商的DNS服务器 -&gt; 递归查询），返回IP</p><p>3、建立TCP连接（三次握手）</p><p>浏览器先和服务器建立一条可靠的传输通道，即TCP连接。</p><p>4、发送HTTP请求</p><p>浏览器发送请求报文</p><ul><li>请求行：请求方法，请求的URL路径，HTTP协议版本。<ul><li><code>GET /index.html HTTP/1.1</code></li></ul></li><li>请求头：包含关于客户端和环境的信息的键值对。<ul><li><code>Host: www.example.com</code>（必需，指定域名）</li><li><code>User-Agent</code>（浏览器身份标识），<code>Accept</code>（客户端接收的内容类型）等</li></ul></li><li>请求体：通常只在POST/PUT方法中存在，包含提交给服务器的数据。</li></ul><p>5、服务器处理请求并返回HTTP响应</p><p>服务器收到请求报文后，会进行处理（例如，由Web服务器软件（如Nginx/Apache）处理静态请求，或由应用服务器（如Tomcat/Node.js）处理动态请求），然后返回一个HTTP响应报文。</p><p>服务器发送响应报文</p><ul><li>状态行：HTTP协议版本、状态码和状态消息。<ul><li><code>HTTP/1.1 200 OK</code>，<code>HTTP/1.1 404 Not Found</code>，<code>HTTP/1.1 500 Internal Server Error</code></li></ul></li><li>响应头：包含关于服务器和响应主体的信息，键值对。<ul><li><code>Content-Type</code>，<code>Content-Length</code>，<code>Set-Cookie</code></li></ul></li><li>响应体：请求的真正资源内容，HTML文档、图片数据等。</li></ul><p>6、浏览器解析渲染页面</p><p>浏览器收到响应后，会根据响应头中的 <code>Content-Type</code>来决定如何处理响应体。</p><p>生成DOM树，CSSOM树，合并构建渲染树，布局，绘制。</p><p>7、连接结束（四次握手）</p><p>HTTP是一种无状态协议，默认完成请求就会关闭连接。</p><p>8、后续交互</p><p>一个完整的页面通常需要加载很多资源（CSS, JS, 图片等）。对于HTTP/1.1，浏览器会对同一个域名建立多个TCP连接（通常是6-8个）来并行下载这些资源，以加快速度。HTTP/2则允许在一个TCP连接上进行多路复用，效率更高。</p><p> </p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><table><thead><tr class="header"><th>特性</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr class="odd"><td>连接性</td><td>面向连接<br>建立连接三次握手，释放连接四次握手。</td><td>无连接的<br>直接发送数据。</td></tr><tr class="even"><td>可靠性</td><td>高<br>通过确认，重传，校验，流量控制，拥塞控制等手段确保数据无差错，不丢失等。</td><td>低<br>不提供任何可靠机制，不确认是否收到，可能丢失，乱序或重复。</td></tr><tr class="odd"><td>数据形式</td><td>面向字节流<br>无结构，无边界，应用程序自己处理粘包/拆包问题。</td><td>面向数据包<br>独立，有边界，一次发送就是一个完整报文。</td></tr><tr class="even"><td>速度和开销</td><td>速度慢，开销大<br>各种机制增加开销，减慢速度。</td><td>速度快，开销小<br>延迟极低，传输效率高。</td></tr><tr class="odd"><td>传输模式</td><td>全双工<br>连接双方可以同时发送和接收数据。</td><td>支持单播，多播，广播。</td></tr><tr class="even"><td>应用场景</td><td>网页浏览（HTTP/HTPPS）<br>文件传输（FTP）<br>电子邮件（SMTP，IMAP）<br>远程登陆（SSH）</td><td>视频流媒体，语音通话<br>在线游戏<br>DNS查询<br>TFTP（简单文件传输）<br>广播/多播</td></tr></tbody></table><p> </p><p> </p><p>LocalStorage和SessionStorage的区别</p><figure><img src="LocalStorage.png" alt="LocalStorage.png" /><figcaption aria-hidden="true">LocalStorage.png</figcaption></figure><p>LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。</p><p> </p><p> </p><p>WebSocket</p><p>在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。</p><p>HTTP：无状态，单向请求-响应模式===&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。</p><p>WebRTC</p><p>虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN/TURN服务器。</p><p>信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
