<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>建模技术</title>
    <link href="/2025/09/24/modelingTechnology/"/>
    <url>/2025/09/24/modelingTechnology/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章">第一章</h1><h2 id="建模">建模</h2><p>定义：模型是对客观事物抽象出来的原型的替代物。</p><p>常见模型：实物模型、物理模型、符号模型（图表）。</p><p>数学建模：实际问题转化为数学问题。</p><p> </p><h2 id="数学建模的基本方法和步骤">数学建模的基本方法和步骤</h2><p>基本方法</p><ul><li>机理分析：对客观事物特性的认识====&gt;内部机理的数量规律（白箱）</li><li>测试分析：对量测数据的统计分析====&gt;与数据拟合最好的模型（黑箱）</li></ul><p>二者结合：机理分析建立模型结构，测试分析确定模型参数。</p><p>（建模主要指机理分析）</p><p> </p><h2 id="数学模型和数学建模">数学模型和数学建模</h2><p>第一性原理：看透事物本质的根本方法。</p><p>数学建模的一般步骤</p><ul><li>模型准备：形成清晰的问题。</li><li>模型假设：合理的，简化的。</li><li>模型构成：采用简单的数学工具。</li><li>模型求解</li><li>模型分析：误差，统计等。</li><li>模型检验：与实际现象，数据比较。</li><li>模型应用</li></ul><figure><img src="1.1.png" alt="数学建模的全过程" /><figcaption aria-hidden="true">数学建模的全过程</figcaption></figure><p>实践到理论再到实践。</p><p>特点：逼真性，条理性，可行性，渐进性，强健性，局限性，可转移性，非预制性。</p><p> </p><h2 id="优化建模">优化建模</h2><p>最小作用量原理：物理系统在从一个状态演化到另一个状态的过程中，会选择使作用量取得极值（通常是局部最小值）的路径。</p><p> 例如，费马原理：光在传播过程中，无论是直线传播、反射还是折射，都遵循时间最短或路径最短的原理。</p><p> </p><h2 id="最优化问题的一般形式及分类">最优化问题的一般形式及分类</h2><p>一般数学形式： <span class="math display">$$\left\{\begin{array}{ll}    \min &amp; f(x) \\    \text{s.t.} &amp; x \in X\end{array}\right.$$</span> 其中，<span class="math inline"><em>f</em>(<em>x</em>)</span>是目标函数，<span class="math inline"><em>x</em></span>是决策变量，<span class="math inline"><em>X</em></span>是约束集合或可行域，构成优化问题的三要素。</p><p>可行域包含的点<span class="math inline"><em>x</em> ∈ <em>X</em></span>是可行解或可行点。</p><p> </p><p>集合<span class="math inline"><em>X</em></span>再由约束函数<span class="math inline"><em>g</em><sub><em>i</em></sub>(<em>x</em>)</span>和<span class="math inline"><em>h</em><sub><em>j</em></sub>(<em>x</em>)</span>表达后的数学形式： <span class="math display">$$\left\{\begin{array}{ll}\min        &amp; f(x) \\\text{s.t.} &amp; g(x) \leq 0 \\            &amp; h(x) = 0\end{array}\right.$$</span>  </p><p>定义：</p><ul><li>对于最优化问题，若有<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且有：</li></ul><p><span class="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>X</em></span></p><p>则称<span class="math inline"><em>x</em><sup>*</sup></span>是最优化问题的整体最优解，<span class="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是整体最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格最优解。</p><p> </p><ul><li>对于最优化问题，若有<span class="math inline"><em>x</em><sup>*</sup> ∈ <em>X</em></span>，并且存在<span class="math inline"><em>x</em><sup>*</sup></span>的邻域<span class="math inline"><em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) = {<em>x</em> ∈ <em>R</em><sup><em>n</em></sup><em>且</em>||<em>x</em> − <em>x</em><sup>*</sup>|| &lt; <em>δ</em>}</span>使得：</li></ul><p><span class="math display"><em>f</em>(<em>x</em><sup>*</sup>) ≤ <em>f</em>(<em>x</em>), ∀<em>x</em> ∈ <em>N</em><sub><em>δ</em></sub>(<em>x</em><sup>*</sup>) ∩ <em>X</em></span></p><p>则称<span class="math inline"><em>x</em><sup>*</sup></span>是最优化问题的局部最优解，<span class="math inline"><em>f</em>(<em>x</em><sup>*</sup>)</span>是局部最优值。</p><p>如果只有<span class="math inline">&lt;</span>则为严格局部最优解。</p><p> </p><p>分类：</p><figure><img src="1.2.png" alt="最优化问题的分类" /><figcaption aria-hidden="true">最优化问题的分类</figcaption></figure><p>一个优化问题可能属于多个类别。</p><p> </p><h2 id="机器学习问题">机器学习问题</h2><p>标准流程</p><ul><li>数据：模拟学习问题的输入和输出</li><li>模型：备选预测函数集合</li><li>算法-表现度量：指导优化的目标函数</li><li>算法-优化算法：计算优化问题最优解</li></ul><p>没有免费的午餐原理：该定理表明，在所有可能的问题中，平均而言，任何算法的性能都是相同的。（有得必有失，守恒，平衡）</p><p>奥卡姆剃刀原理：如无必要，勿增实体。</p><p> </p><h2 id="组合优化问题">组合优化问题</h2><p>定义：这类问题广泛存在于现实生活的各个领域，如物流、 金融、计算机科学、生物信息学等。它关注于在给定 的约束条件下，从一组可能的解中找出最优解。</p><h3 id="旅行商问题tsp">1、旅行商问题(TSP)</h3><p>在物流规划、电路板布线、生物学和交通规划等领域有重要应用。</p><p>随着城市数量的增加，问题的求解难度呈指数增长。</p><p>常用穷举法，动态规划，贪心，遗传等启发式算法。</p><h3 id="背包问题">2、背包问题</h3><p>在商业、组合数学、计算复杂性理论、密码学和应用数学等领域。</p><p>常用动态规划、分支限界法、遗传算法等。</p><h3 id="指派问题">3、指派问题</h3><p>一类特殊的线性规划问题，它要求将n项任务分配给n个人去完 成，每个人只能完成一项任务，且每项任务只能由一个人完成。目标是找 到一种分配方案，使得总成本（或总时间、总资源消耗等）最小。</p><p>在企业管理、资源分配、任务调度等领域有重要应用。</p><p>常用匈牙利算法等有效算法求解。</p><p> </p><p>还有调度问题、切割问题、装箱问题等等…</p><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海游记</title>
    <link href="/2025/09/23/ShangHaiTravel/"/>
    <url>/2025/09/23/ShangHaiTravel/</url>
    
    <content type="html"><![CDATA[<p>22号农历八月初一的生日，刚好朋友来上海面试，和朋友到这里提前过国庆，顺便过个生日游玩一下。</p><h1 id="豫园">豫园</h1><p>来上海第一感觉是外国人真的很多，大街上到处可见，不愧是中国第一大国际化都市。尤其是旅游景点，各国的游客都来拜访这里，豫园挺大的，绕着走也得走很一会，但人流大了显得有点逼仄，景色优美，很多假山假石，环境很清新，算是工业化城市中难得的原始景色了，听说傍晚来这里景色更好。</p><figure><img src="yuyuan01.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan02.png" alt="豫园内" /><figcaption aria-hidden="true">豫园内</figcaption></figure><figure><img src="yuyuan03.png" alt="豫园外" /><figcaption aria-hidden="true">豫园外</figcaption></figure><p>周一不开门，门票可以提前预约。</p><p>——2025/9/21 周日</p><p> </p><h1 id="城隍庙">城隍庙</h1><p>城隍庙离豫园非常近，拜佛的地方，进去就是大殿，旁边也有月老殿、财神殿等，进去可以拿香火上香，来这里知道了上香要用左手在前右手在后。</p><figure><img src="chenghuangmiao01.png" alt="城隍庙大门" /><figcaption aria-hidden="true">城隍庙大门</figcaption></figure><figure><img src="chenghuangmiao02.png" alt="城隍庙出口" /><figcaption aria-hidden="true">城隍庙出口</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="裕兴记">裕兴记</h1><p>苏州风味的蟹黄面，118/碗，感觉有点贵，口味一般般吧，但是面料感觉挺不错的，带有小料、生姜汤和枸杞茶，如果只是作为高档的那种早餐应该还不错。</p><figure><img src="yuxingji.png" alt="蟹黄面" /><figcaption aria-hidden="true">蟹黄面</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="鸟醺烧鸟居酒屋">鸟醺烧鸟居酒屋</h1><p>日料，点了爆黄喉，棒棒鸡，牛肉乌冬和拉面，还有附赠的可尔必思和鸡腿肉，还有餐后的烤菠萝和冰淇淋，感觉还不错，至少口味和酱料这方面跟我之前吃过的日料还是不一样，有点独特的感觉，也很平价，环境专门布置成日风，服务周到，应该算没有踩到坑（笑）。</p><figure><img src="niaoxun01.png" alt="菜品" /><figcaption aria-hidden="true">菜品</figcaption></figure><figure><img src="niaoxun02.png" alt="环境" /><figcaption aria-hidden="true">环境</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="百联zx">百联ZX</h1><p>魔都二次元的必经之地！很多专卖店，各种热门甚至一些比较冷门的IP谷子都有，从小徽章，亚克力牌到玩偶，手办等，很有氛围，六层逛个爽，这里也全是同好，进来感觉浓浓的异次元感啊！顺便帮朋友代购了点火影的谷子（以后我有钱了也要来这里买手办！）</p><figure><img src="bailian01.png" alt="热门IP墙" /><figcaption aria-hidden="true">热门IP墙</figcaption></figure><figure><img src="bailian02.png" alt="玩偶" /><figcaption aria-hidden="true">玩偶</figcaption></figure><figure><img src="bailian03.png" alt="东映动画" /><figcaption aria-hidden="true">东映动画</figcaption></figure><figure><img src="bailian04.png" alt="一乐拉面" /><figcaption aria-hidden="true">一乐拉面</figcaption></figure><figure><img src="bailian05.png" alt="卡卡西" /><figcaption aria-hidden="true">卡卡西</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="静安大悦城">静安大悦城</h1><p>这里主要还是商城，但是北座的6F还是8F有一些谷子店，潮玩星球之类的，有个书店很大，里面各种漫画都有，包括很冷门的IP！这应该是相对于百联的优势了，但是二次元的店家很少，就一层之中的几个店吧，专营店址类的也不多。</p><figure><img src="dayuecheng01.png" alt="各种漫画" /><figcaption aria-hidden="true">各种漫画</figcaption></figure><figure><img src="dayuecheng02.png" alt="JOJO" /><figcaption aria-hidden="true">JOJO</figcaption></figure><figure><img src="dayuecheng03.png" alt="排着特别长的队，好像是hellokitty" /><figcaption aria-hidden="true">排着特别长的队，好像是hellokitty</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="南京路">南京路</h1><p>人是真的多！尽管是周末非假期晚上，各地的游客都是多如牛毛的，两侧是建筑风格很有历史感的高级奢饰品店，感受氛围系列。</p><figure><img src="nanjinglu01.png" alt="南京路中" /><figcaption aria-hidden="true">南京路中</figcaption></figure><figure><img src="nanjinglu02.png" alt="接近外滩" /><figcaption aria-hidden="true">接近外滩</figcaption></figure><figure><img src="nanjinglu03.png" alt="和平饭店" /><figcaption aria-hidden="true">和平饭店</figcaption></figure><p>——2025/9/21 周日</p><p> </p><h1 id="上海博物馆东馆">上海博物馆东馆</h1><p>有很多层，从青铜器，玉器到陶瓷等，每一层都很大要逛很久，挺累的，对历史感兴趣的话这里应该很好玩。</p><figure><img src="shangbo01.png" alt="外面" /><figcaption aria-hidden="true">外面</figcaption></figure><figure><img src="shangbo02.png" alt="一楼青铜馆" /><figcaption aria-hidden="true">一楼青铜馆</figcaption></figure><figure><img src="shangbo03.png" alt="玉如意" /><figcaption aria-hidden="true">玉如意</figcaption></figure><figure><img src="shangbo04.png" alt="青铜剑" /><figcaption aria-hidden="true">青铜剑</figcaption></figure><p>——2025/9/22 周一</p><p> </p><h1 id="东方明珠">东方明珠</h1><p>在陆家嘴桥上看的，这里拍照打卡的人很多，视角还不错，上去逛好像要￥199，下次再来！</p><p><img src="dongfang01.png" /></p><p><img src="dongfang02.png" /></p><p><img src="dongfang03.png" /></p><p>——2025/9/22 周一</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>上海</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>上海</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毗卢寺/鸡鸣寺游记</title>
    <link href="/2025/09/12/piluJimingTravel/"/>
    <url>/2025/09/12/piluJimingTravel/</url>
    
    <content type="html"><![CDATA[<p>今天天气不错，想着去逛了毗卢寺和鸡鸣寺，拜一拜也帮朋友求一下，都离学校不算很远，走一走。</p><h1 id="毗卢寺">毗卢寺</h1><p>这里还是比较偏的，人流很少。</p><figure><img src="house.png" alt="河边豪斯" /><figcaption aria-hidden="true">河边豪斯</figcaption></figure><p>路过的河边看到的小豪斯，有小河有花园，住起来应该很舒服。</p><figure><img src="door01.png" alt="毗卢寺侧门" /><figcaption aria-hidden="true">毗卢寺侧门</figcaption></figure><p>旁边是小学，对门是医院，这附近环境非常安静，很适合休闲散心。</p><figure><img src="mainHall01.png" alt="大殿总览" /><figcaption aria-hidden="true">大殿总览</figcaption></figure><p>布局简单，大概是正殿和两个偏殿，左侧还有一个鼓楼，正殿对着的是烧香的地方。</p><figure><img src="mainHall02.png" alt="大殿" /><figcaption aria-hidden="true">大殿</figcaption></figure><figure><img src="statue01.png" alt="弥勒佛" /><figcaption aria-hidden="true">弥勒佛</figcaption></figure><figure><img src="statue02.png" alt="金刚" /><figcaption aria-hidden="true">金刚</figcaption></figure><figure><img src="statue03.png" alt="释迦牟尼佛" /><figcaption aria-hidden="true">释迦牟尼佛</figcaption></figure><p>供奉的是弥勒佛和释加牟尼，背面也有一个不知道是菩萨还是什么的。</p><p>门票￥10，上香免费，出来的时候有几个找你算手相算命的，有钱的可以试试。</p><p>——2025/9/11周四</p><p> </p><h1 id="鸡鸣寺">鸡鸣寺</h1><p>南朝四百八十寺之首，南京旅游地标性建筑。</p><figure><img src="jiming01.png" alt="25年3月" /><figcaption aria-hidden="true">25年3月</figcaption></figure><figure><img src="jiming02.png" alt="9月" /><figcaption aria-hidden="true">9月</figcaption></figure><p>三月晚上去看过一次樱花，物是人非事事休。</p><figure><img src="hall01.png" alt="昆仑宝殿" /><figcaption aria-hidden="true">昆仑宝殿</figcaption></figure><p>进去应该是比较先看到的，结构是环形+向上的感觉，有一点绕，出口在入口右手边，很多殿林立，感觉里面建筑学很高深。</p><figure><img src="tower01.png" alt="药师佛塔" /><figcaption aria-hidden="true">药师佛塔</figcaption></figure><p>供奉的是药师佛/药师如来。</p><p>春山撩乱水纵横，篱落荒畦草自生。 独往独来山下路，笋舆看得绿阴成。</p><p>——王安石《台城寺侧独行》</p><figure><img src="hall02.png" alt="藏经阁/法堂" /><figcaption aria-hidden="true">藏经阁/法堂</figcaption></figure><p>药师佛塔之后，顺时针绕。</p><figure><img src="roof.png" alt="屋顶" /><figcaption aria-hidden="true">屋顶</figcaption></figure><p>进上香广场的楼梯处。</p><figure><img src="tower02.png" alt="寺里最高的塔" /><figcaption aria-hidden="true">寺里最高的塔</figcaption></figure><p>在上香的最高的广场点即可看到。</p><p>门票￥10，上香免费，很大，人也比较多。</p><p>——2025/9/11周四</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>南京</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>南京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2025/09/10/os/"/>
    <url>/2025/09/10/os/</url>
    
    <content type="html"><![CDATA[<h1 id="线程多开的弊端">线程多开的弊端</h1><p>1、系统资源消耗过大</p><ul><li>内存开销：每个线程需要独立的线程栈（几百 KB 到数 MB），线程数多了会占用大量内存。</li><li>句柄/内核对象消耗：OS维护线程管理信息（TCB，线程控制块），也是负担。</li></ul><p>2、频繁上下文切换</p><ul><li>CPU可能一直在进行多线程切换而非执行实际任务，性能反而降低。</li></ul><p>3、线程调度开销增加</p><ul><li>线程调度器要在大量线程中决定调度，调度队列变长，增加调度延迟。</li></ul><p>4、竞争和同步问题</p><ul><li>多线程共享内存时，访问同一资源产生竞争，增加死锁，活锁等风险。</li></ul><p>5、缓存一致性和CPU亲和性问题</p><ul><li>如果线程频繁切换核，可能导致缓存失效，增加内存访问延迟。</li></ul><p>6、程序稳定性风险</p><ul><li>线程数超过系统支持的最大值可能导致线程创建失败或者系统卡顿甚至崩溃。</li></ul><p>改善：</p><ul><li>采用线程池：用固定数量线程复用，避免无限创建。</li><li>异步/事件驱动模型：在 I/O 密集型任务中，比开很多线程更高效。</li><li>限制线程数：一般根据 CPU核心数 和 任务性质（CPU 密集 or I/O 密集）来决定线程数量。</li></ul><p> </p><h1 id="simd">SIMD</h1><p>单指令多数据</p><p>一种并行计算方式，允许处理器用一条指令同时对多个数据元素进行操作。</p><p>最常见的CPU向量化技术，MIMD则是多核CPU的通用并行方式。</p><p>实现方式：</p><ul><li>寄存器向量化：CPU有专门的向量寄存器（如Intel AVX，SSE）：<ul><li>SSE：128b向量寄存器</li><li>AVX：256b向量寄存器</li></ul></li><li>GPU并行：GPU本身就非常擅长SIMD计算，每个线程执行相同指令，处理不同数据。</li></ul><p>优点：</p><ul><li>提升速度</li><li>降低功耗</li><li>适合向量化任务：图像滤波，矩阵运算，信号处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2025/09/08/java/"/>
    <url>/2025/09/08/java/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构">JVM内存结构</h1><p>JVM 执行 Java 程序时会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途、创建和销毁时间。</p><p>1、程序计数器（Program Counter Register）</p><p>当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>特点：</p><ul><li><p>线程私有：每条线程有个独立的PCR，互不影响，独立存储。</p></li><li><p>如果正在执行Java方法，PCR的值为正在执行的JVM的字节码指令地址；如果是Native方法，值为空。</p></li><li><p>唯一一个没有<code>OutOfMemoryError</code>情况的区域</p></li></ul><p>2、Java虚拟机栈（Java Virtual Machine Stacks）</p><p>Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧 (Stack Frame)， 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从调用到完成的过程，对应着一个栈帧在JVM栈中从入栈到出栈的过程。</p><p>特点：</p><ul><li>线程私有</li><li>存储内容：局部变量表，编译期可知的基本数据类型，对象引用类型和返回地址类型。</li><li>异常：<code>StackOverflowError</code>，<code>OutOfMemoryError</code></li></ul><p>3、本地方法栈（Native Method Stack）</p><p>与虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>特点和虚拟机栈类似。</p><p>4、Java堆（Java Heap）</p><p>此内存区唯一的目的就是存放对象实例，基本在这里分配内存，通常所说的堆内存就是Java堆。</p><p>特点：</p><ul><li>线程共享：Java 堆是虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建。</li><li>GC 堆：Java 堆是垃圾收集器管理的主要区域，也被称为”GC堆“。</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>5、方法区（Method Area）</p><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>特点：</p><ul><li>线程共享</li><li>异常：<code>OutOfMemoryError</code></li></ul><p>6、运行时常量池（Runtime Constant Pool）</p><p>方法区的一部分，常量池表 (Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的RCP中。</p><p>特点：</p><ul><li>动态性，并非预置入 Class 文件常量池的内容才能进入RCP，运行期间也可能将新的常量放入池中。</li></ul><p>7、直接内存（Direct Memory）</p><p>并不是虚拟机运行时数据区的一部分，但也有可能导致<code>OutOfMemoryError</code>。</p><p> </p><p> </p><h1 id="java内存模型jmm">Java内存模型（JMM）</h1><p>抽象的概念，并不真实存在，核心目标是解决多线程环境下的三个问题：</p><ul><li>原子性：一个操作或多个操作要么全部执行成功，要么全部不执行。</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>规定了：</p><ul><li>所有的变量都在主存（MM）中</li><li>每条线程还有自己的工作内存（WM），WM中保存了被该线程使用到的变量的MM副本拷贝。</li><li>线程对变量的所有操作（读取、赋值等）都必须在WM中进行，而不能直接读写MM中的变量。</li><li>不同的线程之间也无法直接访问对方WM中的变量，线程间变量值的传递均需要通过MM来完成。</li></ul><p>当一个线程操作变量时，流程通常是：</p><ul><li>从MM中拷贝变量副本到WM</li><li>在WM中修改副本的值</li><li>在某个时间点，将WM的值刷新回MM</li></ul><p> </p><h2 id="volatile"><code>volatile</code></h2><p>轻量级同步机制，主要解决了可见性和有序性，不保证原子性，开销低，仅能修饰变量。</p><p>保证可见性：当一个变量<code>A</code>被声明为<code>volatile</code>后。</p><ul><li>写：对<code>A</code>的写操作会立刻强制刷新到MM。</li><li>读：对<code>A</code>的读操作会强制从MM中重新读取最新的值。</li></ul><p>保证有序性：通过插入内存屏障来禁止指令重排序。</p><ul><li>写：写之前的所有普通变量的写操作都完成并且已经刷新到MM。</li><li>读：读之后的所有后续普通变量的读/写操作都不会被重排序到该读操作之前。</li></ul><p>局限：不保证原子性，可以用<code>synchronized</code>保证原子性。</p><p> </p><p> </p><h1 id="java对象引用模式">JAVA对象引用模式</h1><p>Java 的引用模式是其内存管理和对象访问的核心，Java通过引用来间接操作所有对象。</p><p>对象：堆内存中实际存在的数据实体，包含了其所属类的所有成员的变量的值。</p><p>引用：一个变量，其值是对象在堆内存中的地址，引用本身存储在栈内存或另一个对象中。</p><p>关键点：</p><ul><li><code>new</code>在堆上创建对象，并返回该对象的地址。</li><li><code>=</code>是复制地址值并非复制对象，多个引用指向同一个对象。</li><li><code>null</code>不指向任何对象。</li></ul><p>参数传递：</p><p>Java中只有按值传递，传递的是地址的副本，并非引用更不是对象。</p><p> </p><h1 id="equals和的区别"><code>equals()</code>和<code>==</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>equlas</code></th><th><code>==</code></th></tr></thead><tbody><tr class="odd"><td>本质</td><td>操作符</td><td>方法（定义在<code>Object</code>类中）</td></tr><tr class="even"><td>比较对象</td><td>内存地址</td><td>内容（需要重写，比如<code>String</code>,<code>Integer</code>）</td></tr><tr class="odd"><td>比较基本类型</td><td>实际值</td><td>不能用于基本类型</td></tr><tr class="even"><td>是否可自定义</td><td>否</td><td>是</td></tr></tbody></table><p> </p><h1 id="arraylist和linkedlist的区别"><code>ArrayList</code>和<code>LinkedList</code>的区别</h1><table><thead><tr class="header"><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr class="odd"><td>底层数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr class="even"><td>获取元素</td><td>O(1)<br>支持随机访问</td><td>O(n)<br>从表头或者表尾开始遍历</td></tr><tr class="odd"><td>插入/删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr class="even"><td>遍历效率</td><td>高</td><td>低</td></tr><tr class="odd"><td>内存占用</td><td>小</td><td>大</td></tr><tr class="even"><td>应用场景</td><td>读多写少，绝大多数情况</td><td>写多读少，栈，队列等</td></tr></tbody></table><p> </p><h1 id="接口">接口</h1><p>一种抽象类型，定义类必须实现的方法的集合，但接口本身不能有方法的具体实现（Java8之后<code>default</code>和<code>static</code>可以实现），主要提供一种规范，使得不同类可以通过统一接口进行交互，而不关心具体实现。</p><p>实现接口：<code>implements</code></p><p>特点：</p><ul><li>多实现</li><li>解耦：减少类之间的耦合</li><li>多态：实现运行时多态</li></ul><p> </p><h1 id="函数覆写">函数覆写</h1><p>子类重新定义从父类继承而来的同名函数，以实现不同的功能。</p><p>要求：</p><ul><li>方法签名相同：函数名，参数个数、类型都必须相同。</li></ul><p><em># 参数列表必须完全相同，不一致则变成函数重载（overload）</em></p><ul><li>访问权限：子类方法的访问权限不能比父类更严格。</li><li>多态体现：当父类指针/引用调用函数时，会根据实际对象类型执行子类方法（支持虚函数/动态绑定）。</li></ul><p>关键字：<code>virtual</code>，<code>override</code></p><p> </p><h1 id="java泛型">Java泛型</h1><p>写一个类或者方法时，不指定具体的数据类型，而是用一个类型参数来代替，使用时再指定具体类型，减少强制类型转换的需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setContent</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.<span class="built_in">setContent</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str = stringBox.<span class="built_in">getContent</span>(); <span class="comment">// 不需要强转</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.<span class="built_in">setContent</span>(<span class="number">123</span>);</span><br><span class="line">Integer num = intBox.<span class="built_in">getContent</span>();</span><br></pre></td></tr></table></figure><p>不止是类，还可以用于泛型接口，方法等。</p><p>优点：</p><ul><li>类型安全</li><li>减少强制转换</li><li>可读性强</li></ul><p><em># 不能用于基本类型</em></p><p>常用场景：集成框架，工具类方法，通用对象封装。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2025/09/03/springboot/"/>
    <url>/2025/09/03/springboot/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot">SpringBoot</h1><figure><img src="intro.png" alt="介绍" /><figcaption aria-hidden="true">介绍</figcaption></figure><p>SpringBoot是一个Spring模块，提供了RAD(快速应用程序开发)功能。它用于创建独立的基于Spring的应用程序，需要最少的Spring配置就可以运行。</p><p>即Spring框架和嵌入式服务器的组合。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ssh连接github失败</title>
    <link href="/2025/08/27/sshBug/"/>
    <url>/2025/08/27/sshBug/</url>
    
    <content type="html"><![CDATA[<p>先尝试<code>ssh -T git@github.com</code>。</p><p> </p><p>有可能是22端口被阻隔了，尝试443端口，在config中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com </span><br><span class="line">        Hostname ssh.github.com </span><br><span class="line">        Port 443</span><br><span class="line">        User git</span><br><span class="line">        ProxyCommand connect -S 系统代理地址 %h %p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2025/08/26/machineLearning/"/>
    <url>/2025/08/26/machineLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><figure><img src="machineLearningProcess.png" alt="流程示例" /><figcaption aria-hidden="true">流程示例</figcaption></figure><figure><img src="mlClassfication.png" alt="类型" /><figcaption aria-hidden="true">类型</figcaption></figure><figure><img src="mlWork.png" alt="工作流" /><figcaption aria-hidden="true">工作流</figcaption></figure><p> </p><h1 id="神经网络">神经网络</h1><figure><img src="cnnBasic.png" alt="基础" /><figcaption aria-hidden="true">基础</figcaption></figure><p>神经元接收输入信号，通过加权求和后与偏置相加，然后通过激活函数处理以产生输出。神经元的权重和偏置是网络学习过程中需要调整的参数。</p><p> </p><h2 id="前馈神经网络">前馈神经网络</h2><figure><img src="fnn.png" alt="Feedforward Neural Network，FNN" /><figcaption aria-hidden="true">Feedforward Neural Network，FNN</figcaption></figure><p>基本单元，前馈神经网络特点是数据从输入层开始，经过一个或多个隐藏层，最后到达输出层，全过程没有循环或反馈。</p><p> </p><h2 id="循环神经网络">循环神经网络</h2><figure><img src="rnn.png" alt="Recurrent Neural Network, RNN" /><figcaption aria-hidden="true">Recurrent Neural Network, RNN</figcaption></figure><p>专门处理序列数据的神经网络，能够捕获输入数据中时间或顺序信息的依赖关系,在自然语言处理（NLP）、语音识别、时间序列预测等任务中有着广泛的应用。</p><p>关键特性：其能够保持隐状态（hidden state），使得网络能够记住先前时间步的信息。</p><p>隐状态：通过上一时间步的隐状态和当前输入共同计算得到的。</p><p> 公式：<span class="math inline"><em>h</em><sub><em>t</em></sub> = <em>f</em>(<em>W</em><sub><em>h</em><em>h</em></sub><em>h</em><sub><em>t</em> − 1</sub> + <em>W</em><sub><em>x</em><em>h</em></sub><em>x</em><sub><em>t</em></sub> + <em>b</em><sub><em>h</em></sub>)</span></p><p><em># <span class="math inline"><em>h</em><sub><em>t</em></sub></span>：当前时刻隐状态；<span class="math inline"><em>h</em><sub><em>t</em> − 1</sub></span>：前一时刻隐状态；<span class="math inline"><em>W</em><sub><em>x</em><em>h</em></sub>, <em>W</em><sub><em>h</em><em>h</em></sub></span>：权重矩阵；<span class="math inline"><em>x</em><sub><em>t</em></sub></span>：当前时刻的输入；<span class="math inline"><em>b</em><sub><em>h</em></sub></span>：偏置；<span class="math inline"><em>f</em>()</span>：激活函数。</em></p><p>输出：不仅依赖当前输入，还依赖于隐状态的历史信息。</p><p> 公式：<span class="math inline"><em>y</em><sub><em>t</em></sub> = <em>W</em><sub><em>h</em><em>y</em></sub><em>h</em><sub><em>t</em></sub> + <em>b</em><sub><em>y</em></sub></span></p><p><em># <span class="math inline"><em>y</em><sub><em>t</em></sub></span>：t时刻的输出向量；<span class="math inline"><em>W</em><sub><em>h</em><em>y</em></sub></span>：隐状态到输出状态的矩阵。</em></p><figure><img src="unfoldRnn.png" alt="展开视图" /><figcaption aria-hidden="true">展开视图</figcaption></figure><p> </p><h2 id="卷积神经网络">卷积神经网络</h2><figure><img src="cnn.png" alt="Convolutional Neural Networks, CNN" /><figcaption aria-hidden="true">Convolutional Neural Networks, CNN</figcaption></figure><p>专门用于处理具有网格状拓扑结构数据（如图像）的深度学习模型，是计算机视觉任务（如图像分类、目标检测和分割）的核心技术。</p><p> </p><h2 id="transformer模型">Transformer模型</h2><p>一种基于注意力机制的深度学习模型，仅依赖注意力机制来处理序列数据，从而实现更高的并行性和更快的训练速度。</p><figure><img src="transformer.png" alt="transformer结构" /><figcaption aria-hidden="true">transformer结构</figcaption></figure><p>结构：</p><ul><li>编码器（Encoder）：由NN层相同的模块堆叠而成，每层包含两个子层，每个子层后面都接有 残差连接（Residual Connection） 和 层归一化（Layer Normalization）。</li></ul><p> 多头自注意力机制（Multi-Head Self-Attention）：计算输入序列中每个词与其他词的相关性。</p><p> 前馈神经网络（FNN）：对每个词进行独立的非线性变化。</p><ul><li>解码器（Decoder）：由NN层相同的模块堆叠而成，每层包含三个子层，每个子层后面都接有残差连接和层归一化。</li></ul><p> 掩码多头自注意力机制（Masked Multi-Head Self-Attention）：计算输出序列中每个词和其他词的相关性。</p><p><em># 使用掩码防止未来信息泄露</em></p><p> 交叉注意力机制（Encoder-Decoder Attention）：计算输出序列与输入序列的相关性。</p><p> 前馈神经网络（FNN）</p><p>核心思想：</p><ul><li>自注意力机制（Self-Attention）：允许模型在处理序列时，动态地为每个位置分配不同的权重，从而捕捉序列中任意两个位置之间的依赖关系。</li><li>多头注意力（Multi-Head Attention）：将输入分成多个子空间，每个子空间独立计算注意力，最后将结果拼接起来。</li><li>位置编码（Positional Encoding）：位置编码被用来为输入序列中的每个词添加位置信息，代替序列信息（如RNN中的时间步）。</li></ul><p>优势：并行计算，长距离依赖（解决RNN的梯度消失），可扩展性。</p><p>应用：NLP（机器翻译，GPT），CV（图像分类，目标检测），多模态任务。</p><p> </p><p> </p><h1 id="conda指令">Conda指令</h1><p> 查看环境：<code>conda env list</code></p><p> 进入环境：<code>conda activate 环境名称</code></p><p> 退出环境：<code>conda deactivate</code></p><p> 删除环境：<code>conda remove --name 环境名称 --all</code></p><p> 更换为阿里云镜像源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p><p> 查看当前源：<code>pip config list</code></p><p> 查看当前包：<code>pip list</code></p><p> 下载依赖包requirements.txt：<code>pip install -r requirements.txt</code></p><p> </p><p> </p><h1 id="训练模型">训练模型</h1><p>模型文件=模型结构+预训练权重</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/2025/08/22/web/"/>
    <url>/2025/08/22/web/</url>
    
    <content type="html"><![CDATA[<p>Json对象和数组：</p><p>​ 对象是键值对集合，数组是值的有序列表；</p><p>​ Json对象的值可以包含数组，数组的元素也可以是一个对象，能够支持多层嵌套。</p><p> </p><p>前端渲染和后端渲染：</p><figure><img src="render.png" alt="render.png" /><figcaption aria-hidden="true">render.png</figcaption></figure><p>​ 前端渲染：React,Vue等；后端渲染：传统PHP,Java,Python等。</p><p>​ 现代开发常采用混合方案：同构渲染，首次访问使用SSR快速呈现内容，后续交互转为CSR提供流畅体验，如 Next.js (React), Nuxt.js (Vue)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript</title>
    <link href="/2025/08/22/javascript/"/>
    <url>/2025/08/22/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="文件与拖拽api的底层原理">文件与拖拽API的底层原理</h1><p>文件API：</p><p> 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；</p><p> 无路径访问：JavaScript无法知晓真正的文件路径；</p><p> 同源限制：读取的文件内容只能在当前页面上下文使用。</p><p>拖拽API：</p><p>拖拽本质是操作系统提供的跨应用（跨源）通信机制。</p><p>过程：</p><p> 拖拽开始时，OS创建“拖拽会话”；</p><p> 拖拽过程中，系统跟踪光标位置并查询下方的放置目标；</p><p> 放置时，系统协调数据传递。</p><figure><img src="dragAndDrop.png" alt="拖拽实现的层次" /><figcaption aria-hidden="true">拖拽实现的层次</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascipt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/2025/08/22/dsa/"/>
    <url>/2025/08/22/dsa/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="枚举算法">枚举算法</h2><p>描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。</p><p>核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解，关注枚举的上下界。</p><p>优点：简单基本，便于实现，容易调试，正确性容易证明。</p><p>流程：</p><ul><li><p>确定枚举对象、枚举的上下界、判断条件。</p></li><li><p>枚举可能的情况并验证是否是问题的解。</p></li><li><p>考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。</p><p>题库：百钱买百鸡，LeetCode78，611，1504，1733，2749。</p></li></ul><p> </p><h2 id="贪心算法greedy-algorithm">贪心算法Greedy Algorithm</h2><p>描述：每一步都做出在当前看来是最好的选择，期望通过局部最优选择来达到全局最优解。</p><p>核心思想：局部最优，不可回溯，期望全局最优。</p><p><em># 贪心只做局部最优选择，不保证全局最优。</em></p><p>优点：高效，简单直观。</p><p>流程：</p><ul><li>建立数学模型</li><li>分解问题</li><li>制定贪心策略</li><li>求解子问题</li><li>合并成原问题解</li></ul><p>题库：LeetCode134，1792。</p><p> </p><h2 id="回溯算法">回溯算法</h2><p>描述：通过深度优先(DFS)搜索策略来遍历所有可能的候选解，并在搜索过程中利用剪枝来避免无效搜索，提高效率。</p><p>核心思想：</p><ul><li>路径：从根节点到当前节点所做出的选择序列。</li><li>选择列表：在当前节点可以做出的所有选择。</li><li>结束条件：找到一个解或停止。</li></ul><p>流程：</p><ul><li>在当前节点遍历所有选择</li><li>找到解做出选择并加入当前路径</li><li>递归进入下一个状态</li><li>递归返回后，撤销刚才的选择（<strong>回溯</strong>）</li></ul><p>可以配合lamdba表达式<code>auto dfs&#123;&#125;;</code></p><p>题库：LeetCode 22，39。</p><p> </p><h2 id="动态规划">动态规划</h2><p>描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。</p><p>一般的递归时间复杂度太高，<code>递归时间复杂度 = 解决一个子问题时间*子问题个数</code>，需要把子问题的结果进行存储，利用空间来降低时间复杂度，把二叉树变成了树干，子问题个数从O(2<sup>n</sup>)变成了O(n)。同理，转换递归时存储结果时是自顶向下的解法，而动态规划就是自底向上的解法。</p><p>核心思想：拆分子问题、记住过往、减少重复计算。</p><p>流程：</p><ul><li><p>穷举分析</p></li><li><p>确认边界</p><ul><li>找出规律，确定最优子结构<ul><li>动态规划问题即是递推问题，当前的决策结果是<code>f(n)</code>，则最有子结构就是要让<code>f(n-k)</code>最优，并且与后面的决策没有关系，能让后面的决策安心使用局部最优解。</li></ul></li><li>写出状态转移方程</li></ul></li></ul><p>题库：LeetCode62，120，1277，1504，2327，3494。</p><p> </p><h2 id="位运算算法">位运算算法</h2><p>大大提高程序的性能，0/1问题时好用。</p><p>题库：LeetCode78，2749。</p><p> </p><h2 id="模拟">模拟</h2><p>描述：完全按照题目的描述或者问题的真实发生过程，一步步地用代码复现出来从而得到答案。</p><p>核心思想：重视还原，过程再现。</p><p>流程：</p><ul><li>提炼规则</li><li>设计数据结构</li><li>分解步骤，模块化</li><li>注意边界</li></ul><p>特点：思路直观，实现繁琐。</p><p>题库：LeetCode6，54，3446。</p><p> </p><h2 id="堆算法">堆算法</h2><p>描述：特殊的完全二叉树，可以用一维数组存储。</p><p>堆的更新和维护：</p><p> 入堆push()，时间复杂度<code>O(log n)</code></p><p> 出堆pop()，时间复杂度<code>O(log n)</code></p><p> 访问栈顶top()，时间复杂度<code>O(1)</code></p><p> 建堆，时间复杂度<code>O(nlog n)</code></p><p><em># 即堆中插入n个元素</em></p><p>应用：优先队列。</p><p>题库：LeetCode 1792。</p><p> </p><h2 id="分支限界法">分支限界法</h2><p>描述：</p><ul><li>分支：将大问题划分为若干子问题，形成解空间树，每个结点代表一个子问题，每条分支表示对子问题的一种约束或决策。</li><li>限界：对每个子问题，计算一个上下界，即它可能取得的最优解的范围，如果某个子问题的最优解范围不可能优于当前已知的最优解，就剪枝（丢弃该子问题）。</li></ul><p>流程：</p><ul><li>定义问题的解空间</li><li>从根结点开始分支，产生子问题</li><li>对每个子问题计算限界</li><li>子问题放入候选结点表（队列/堆等）</li><li>从候选结点表中选择结点展开（搜索策略）</li><li>结点满足约束并且更优就继续分支，不满足就剪枝</li><li>重复直到候选结点表为空或者找到全局最优</li></ul><p>题库：0-1背包问题。</p><p> </p><h2 id="双指针">双指针</h2><p>描述：使用两个指针（索引）在数据结构中协同工作，一般分为同向指针或者相向指针。</p><p>滑动窗口也是一种双指针，左指针收缩窗口，右指针扩展窗口。</p><p>流程：</p><ul><li>数据结构进行排序</li><li>边界</li><li>指针移动条件</li><li>重复元素处理</li></ul><p>题库：LeetCode75，611， 2348。</p><p> </p><h2 id="前缀和">前缀和</h2><p>描述：一个数组中，从第一个元素到当前元素的累加和。</p><p>将区间求和的操作从O(n)优化为O(1)，例如，求<code>sum[l,r]</code>的暴力解法是遍历<code>[l,r]</code>，时间复杂度O(n)；而预先处理<code>prefix[i]</code>，<code>sum[l,r]</code>即为<code>prefix[r]-prefix[l-1]</code>，时间复杂度O(1)。</p><p>核心思想：预处理前缀和，换取查询效率；适合于频繁查询但不修改。</p><p>题库：LeetCode3147。</p><p> </p><p> </p><h1 id="结构">结构</h1><h2 id="折半查找树">折半查找树</h2><p>即二叉搜索树，Binary Search Tree，BST</p><p>每个结点最多有两个孩子，对于任一结点<code>node</code>：</p><p>左子树上的所有键小于<code>node-&gt;key</code>，右子树上的所有键大于<code>node-&gt;key</code>。</p><p>若树的高度为<code>h</code>，查找/插入/删除复杂度为O(h)，遍历O(n)。</p><p> </p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><p>包括深度优先遍历（DFS）和广度优先遍历（BFS）</p><p>1、深度优先遍历</p><p>按访问顺序不同，可分为前序遍历，中序遍历，后序遍历。</p><p>（1）前序遍历</p><p>顺序：根 -&gt; 左子树 -&gt; 右子树</p><p>可以用于复制树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）中序遍历</p><p>顺序：左子树 -&gt; 根 -&gt;右子树</p><p>对于二叉搜索树来说，中序遍历的结果就是升序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）后序遍历</p><p>顺序：左子树 -&gt; 右子树 -&gt; 根</p><p>删除树节点或者释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、广度优先遍历</p><p>又叫层序遍历，从根节点开始逐层从左到右访问。</p><p>输出层次结构，求出树的高度、最短路径等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//队列，FIFO</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h2 id="有向图邻接表">有向图邻接表</h2><p>常用的图存储结构，适合存储稀疏图（顶点多，边少）</p><ul><li>有向图：每条边都有方向，比如<code>u-&gt;v</code>表示从顶点<code>u</code>指向顶点<code>v</code>。</li><li>邻接表：为图中的每个顶点建立一个链表/动态数组，存储从该顶点出发的所有边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>; <span class="comment">// 顶点个数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，1-based</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">adj[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">adj[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> </p><p> </p><h1 id="stl">STL</h1><h2 id="ascii">ASCII</h2><p>小写字母的ASCII码=大写字母的ASCII码+32。</p><p> </p><h2 id="正整数向上取整">正整数向上取整</h2><p>方法：<code>int div=(a+b-1)/b</code></p><p>如果<code>a</code>整除<code>b</code>，那么加上的<code>b+1</code>还不足以跨越到下一个整数；如果<code>a</code>不整除<code>b</code>，那么跨越下一个整数。</p><p> </p><h2 id="int最小数和最大数">int最小数和最大数</h2><p><code>INT_MIN</code>和<code>INT_MAX</code>，分别为-2<sup>31</sup>和2<sup>31</sup>-1。</p><p> </p><h2 id="swap"><code>swap()</code></h2><p>格式：<code>void swap(T&amp; a,T&amp; b)</code></p><p>时间复杂度和空间复杂度都是O(1)。</p><p> </p><h2 id="sort"><code>sort()</code></h2><p>格式：<code>void sort (RandomAccessIterator first, RandomAccessIterator last);</code></p><p>注意：</p><ul><li>迭代器范围：<code>[first, last)</code>是一个左闭右开的区间，例如使用索引和迭代器结合时要用<code>begin()+i</code>和<code>begin()+j+1</code>。</li><li>性能：时间复杂度为O(nlogn)。</li></ul><p> </p><h2 id="min_element"><code>min_element()</code></h2><p>格式：<code>min_element(begin(),end())</code></p><p>作用：返回<code>[begin,end)</code>范围内最小的迭代器，可以在前面加解引用符号<code>*</code>，即为返回值。</p><p>示例：<code>return *min_element(matrix.begin(),matrix.end())</code></p><p> </p><h2 id="lower_bound"><code>lower_bound()</code></h2><p>格式：<code>auto it = lower_bound(xx.begin(),xx.end(),x)</code></p><p>作用：找到这个容器下第一个大于等于<code>x</code>的元素，并返回迭代器（要求容器有序）。</p><p>平均时间复杂度：O(log n)。</p><p> </p><p><code>static</code></p><p>作用于局部变量时：使得变量的生命周期延长至整个程序运行期间，而不是随着函数调用结束而销毁。</p><p>作用于成员变量时：所有该类的对象共享同一个静态成员变量。</p><p> </p><h2 id="优先队列">优先队列</h2><p>特殊的队列，每个元素都有优先级，最先取出优先级最高的元素，在<code>struct&#123;&#125;;</code>中提前声明。</p><p>核心实现：二叉堆（最大堆<code>priority_queue</code>/最小堆），堆顶是最大/最小元素。</p><p>格式：<code>priority_queue&lt;元素类型,底层容器类型,比较函数类型&gt;</code></p><p><em># 注：声明忽略后面两个参数时自动按照最大堆排列，即按照从前往后比较的最大元素的排列。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，char可以换成自定义的struct</span></span><br><span class="line">priority_queue&lt;<span class="type">char</span>,vector&lt;<span class="type">char</span>&gt;,CompareASCII&gt;pq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重载运算符：</p><p><em># 一般<code>const</code>修饰，重载运算符不必修改对象，引用传递避免不必要的拷贝，提高效率，返回值必须为bool。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆，栈顶是优先级最小的，最大堆反之用&lt;。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareASCII</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; a,<span class="type">const</span> <span class="type">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入：<code>push()</code>（只能接受一个参数，必须是已经构造好的元素）或者<code>emplace()</code></p><p><em># 不支持随机访问修改</em></p><p>时间复杂度：插入和删除都是<code>O(log n)</code>。</p><p> </p><h2 id="vector">Vector</h2><p> 长度：<code>size()</code></p><p> 在末尾添加一个元素：<code>push_back(数组的一个数据)</code></p><p> 直接在末尾构造对象：<code>emplace_back(构造需要的数据)</code>，和<code>push_back()</code>区别不大，省去一次拷贝。</p><p><em># 二维数组添加一维数组同理</em></p><p> 释放原有资源并构造新的容器，属性和传进来的容器一致：<code>新的容器=move(数组)</code></p><p> 清空所有元素：<code>clear()</code></p><p> 是否为空矩阵：<code>empty()</code></p><p> </p><h2 id="string">String</h2><p> 长度：<code>length()</code></p><p> 获取子字符串：<code>substr(size_t pos,size_t len)</code></p><p> 找到子字符或子字符串：<code>find()</code>，返回起始位置</p><p><em># <code>pos</code>：子字符串的起始位置，默认0；<code>len</code>：提取的字符数量，默认一直提取到末尾</em></p><p> 将字符串转换为整数：<code>stoi(const string&amp; s,size_t* idx,int base)</code></p><p><em># <code>s</code>：需转换的字符串；<code>idx</code>：可选指针；<code>base</code>：可选的转换的进制</em></p><p> 删除最后一个字符：<code>pop_back()</code></p><p><em># 字符串不能为空</em></p><p> </p><h2 id="位运算">位运算</h2><p> 计算整数中二进制为1的个数：<code>popcount(T x)</code></p><p><em># <code>T</code>：无符号的整数类型，例如<code>unsigned int</code>，<code>unsigned long</code>，<code>uint64_t</code>等；<code>x</code>：整数</em></p><p> </p><h2 id="模板类">模板类</h2><h3 id="pair"><code>&lt;pair&gt;</code></h3><p>定义好的迷你结构体，将两个数据打包成一个整体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">    T1 first;   <span class="comment">// 第一个元素</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>T1</code>和<code>T2</code>可以为其他不同类型，例如<code>pair&lt;int,string&gt;</code>，经常用于键值对，函数返回值，构造容器等。</p><p> </p><h3 id="tuple"><code>&lt;tuple&gt;</code></h3><p>固定大小，异质（可以是不同类型）的容器</p><p>构造：<code>tuple&lt;T1,T2,T3&gt; myTuple(t1,t2,t3)</code></p><p>访问：<code>T1 first=get&lt;0&gt;(myTuple)</code>，也可以修改</p><p>支持比较：比较的是字典序</p><p> </p><h2 id="无序有序关联容器">无序/有序关联容器</h2><h3 id="无序基于哈希表实现">无序：基于哈希表实现</h3><p>1、哈希集合：<code>unordered_set&lt;key&gt;</code></p><ul><li><p>元素是唯一的，检查一个元素是否存在于集合当中</p></li><li><p>用法：</p><ul><li>插入：<code>insert(key)</code></li><li>查找：<code>find(key)</code>，返回的是迭代器，一般配合<code>end()</code>使用进行判断</li></ul><p><em># 注意，<code>it</code>指向<code>pair&lt;const Key, Value&gt;</code>的对象，不能通过<code>it</code>修改键，但可以修改值，<code>it-&gt;first</code>是键，<code>it-&gt;second</code>是值。</em></p><ul><li>删除：<code>erase(key)</code></li><li>遍历：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : set) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、哈希表：<code>unordered_map&lt;key,value&gt;</code></p><ul><li>key是唯一的，插入相同的key会覆盖原有的值</li><li>用法：<ul><li>插入：<code>insert(&#123;key,value&#125;)</code></li><li>访问：<code>map[key]</code></li><li>遍历：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;</span><br><span class="line">cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(1)，但最坏情况可能是O(n)。</li><li>元素顺序：无序</li></ul><h3 id="有序基于红黑树实现">有序：基于红黑树实现</h3><p>红黑树是一种自平衡的二叉搜索树，保证了树的高度始终保持在 O(log n)，从而确保了所有主要操作的时间复杂度都是稳定的 O(log n)。</p><p>1、有序集合：<code>set&lt;key&gt;</code></p><ul><li>用法：<ul><li>插入：<code>set.insert(key)</code></li><li>查找：<code>set.find(key)</code></li><li>删除：<code>set.erase(key)</code></li></ul></li></ul><p>2、有序表：<code>map&lt;key,value&gt;</code></p><ul><li>用法：<ul><li>插入：<code>map.insert(&#123;key,value&#125;)</code>或者下标运算法<code>map[key]=value</code></li><li>访问：<code>map[key]</code></li></ul></li></ul><p>3、性能：</p><ul><li>平均时间复杂度：插入、删除、查找都是O(log n)</li><li>元素顺序：默认按键排列升序</li></ul><p> </p><h2 id="listsetmap">List，Set，Map</h2><table><thead><tr class="header"><th>特性</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr class="odd"><td>顺序</td><td>有序</td><td>无序</td><td>无序</td></tr><tr class="even"><td>可重复</td><td>可以</td><td>不可以</td><td>键不重复</td></tr><tr class="odd"><td>访问方式</td><td>下标索引</td><td>无索引</td><td>key查找</td></tr><tr class="even"><td>用途</td><td>保存序列</td><td>保存唯一元素</td><td>键值对应关系</td></tr></tbody></table><p> </p><h2 id="inline"><code>inline</code></h2><p>内联函数，编译器会尝试用函数内的代码替换掉函数调用语句</p><p>传统函数调用过程：</p><ul><li>执行到函数调用语句</li><li>将返回地址，参数等压入栈</li><li>跳转到函数体的内存地址开始执行</li><li>函数执行完毕，将返回值存入指定位置</li><li>跳转回之前保存的地址，继续执行调用处的下一条指令</li></ul><p>这个过程对于功能简单，调用频繁的小函数，这种开销可能比函数本身执行的时间还长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>减少调用开销</li><li>避免宏定义的缺点</li></ul><p> </p><h1 id="lambda表达式">Lambda表达式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 递归函数</span></span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有两个点，无法组成三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用，修改 res 相当于修改 memo[i][j]</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123; <span class="comment">// 枚举顶点 k</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(i, k) + <span class="built_in">dfs</span>(k, j) + v[i] * v[j] * v[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em># <code>[&amp;]</code>表示能够访问外部作用域所有变量，<code>this auto&amp;&amp;</code>允许Lambda实现自递归，<code>-&gt;int</code></em>表示返回类型为整数</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2025/08/22/hexo/"/>
    <url>/2025/08/22/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo指令">Hexo指令：</h1><p> 新建博客：<code>hexo new'xxx'</code></p><p> 清除之前所有的公共文件：<code>hexo clean</code></p><p> 重新生成html文件：<code>hexo g</code></p><p> 上传到GitHub：<code>hexo d</code></p><p>==&gt;清除/生成/部署：<code>hexo clean &amp;&amp; hexo g -d</code></p><p> 查看hexo版本：<code>hexo version</code></p><p> </p><h1 id="hexo美化">Hexo美化</h1><p> </p><h1 id="git指令">Git指令：</h1><p> 测试Github到SSH的连接：<code>ssh -T git@github.com</code></p><p> 测试到Github的网络连接是否通畅：<code>ping github</code></p><p><em># ping命令使用 ICMP 协议，git 命令使用 HTTP/HTTPS 协议。</em></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ping</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2025/08/22/markdown/"/>
    <url>/2025/08/22/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法">Markdown语法</h1><h2 id="链接">链接</h2><p>效果：<a href="url">链接文本</a></p><p>格式：<code>[链接文本](url)</code></p><p> </p><h2 id="指数">指数</h2><p>效果：2<sup>n</sup></p><p>格式：<code>2&lt;sup&gt;n&lt;/sup&gt;</code></p><p> </p><h2 id="列表">列表</h2><p>效果：</p><ul><li><p>列表一</p></li><li><p>列表二</p><p>格式：<code>- 列表一</code></p></li></ul><p> </p><h2 id="斜体">斜体</h2><p>效果：<em>斜体</em></p><p>格式：<code>*斜体*</code></p><p> </p><h2 id="加粗">加粗</h2><p>效果：<strong>加粗</strong></p><p>格式：<code>**加粗**</code></p><p> </p><h2 id="公式">公式</h2><p>效果：<span class="math inline"><em>h</em><sub><em>t</em></sub></span></p><p>格式：<code>$h_t$</code></p><p> </p><h2 id="表格">表格</h2><p>效果：</p><table><thead><tr class="header"><th>列A</th><th>列B</th></tr></thead><tbody><tr class="odd"><td></td><td></td></tr></tbody></table><p>格式：<code>|列A|列B|</code></p><p> </p><p> </p><h1 id="latex语法">LaTex语法</h1><h2 id="下标">下标</h2><p>效果：<span class="math inline"><em>h</em><sub><em>t</em></sub></span>，<span class="math inline"><em>h</em><sub><em>t</em><em>t</em></sub></span></p><p>格式：<code>h_t,h_&#123;tt&#125;</code></p><p> </p><h2 id="数学符号">数学符号</h2><h3 id="in"><span class="math inline">∈</span></h3><p>格式：<code>\in</code></p><p> </p><h3 id="forall"><span class="math inline">∀</span></h3><p>格式：<code>\forall</code></p><p> </p><h3 id="cap"><span class="math inline">∩</span></h3><p>格式：<code>\cap</code></p><p> </p><h3 id="leq"><span class="math inline">≤</span></h3><p>格式：<code>\leq</code></p><p> </p><h2 id="希腊字母">希腊字母</h2><h3 id="delta"><span class="math inline"><em>δ</em></span></h3><p>格式：<code>\delta</code></p><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2025/08/22/vue/"/>
    <url>/2025/08/22/vue/</url>
    
    <content type="html"><![CDATA[<p>Vue3</p><p>​ 描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。</p><p>​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。</p><p>​ 命令：</p><p><em># 创建Vue项目</em> <code>npm init vue@latest</code></p><p><em># 启动开发服务器</em></p><p><code>npm install</code></p><p><code>npm run dev</code></p><p><em># 打开图形化界面</em></p><p><code>npm install @vue/cli</code></p><p><code>vue ui</code></p><p>Vite</p><p>​ 描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。</p><p>​ 组成：</p><ul><li><p>开发服务器：基于原生ES模块，提供超快的热更新。</p></li><li><p>构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。</p><p>优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2025/08/22/docker/"/>
    <url>/2025/08/22/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><p>描述：开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>优点：跨平台一致性，资源高效，快速部署，隔离性。</p><p>基本命令：</p><p> 查看运行中的容器：<code>docker  ps</code></p><p> 进入容器内部：<code>docker exec -it &lt;容器ID&gt; /bin/bash</code></p><p> 杀死进程：<code>kill -9 项目ID</code></p><p>命令大全：<a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>软件开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2025/08/22/computerNetworks/"/>
    <url>/2025/08/22/computerNetworks/</url>
    
    <content type="html"><![CDATA[<h1 id="tcpip">TCP/IP</h1><h2 id="五层模型">五层模型</h2><p> 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。</p><p> 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。</p><p> 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。</p><p> 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。</p><p> 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。</p><h2 id="http请求过程">HTTP请求过程</h2><p>从浏览器，操作系统，网络设备到服务器共同参与的协作过程。</p><p> 过程：</p><figure><img src="http.png" alt="八个阶段" /><figcaption aria-hidden="true">八个阶段</figcaption></figure><p>1、URL解析</p><p>用户输入，浏览器解析（协议、域名、路径），浏览器检查</p><p>2、DNS域名解析</p><p>浏览器查找顺序（浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; 网络服务供应商的DNS服务器 -&gt; 递归查询），返回IP</p><p>3、建立TCP连接（三次握手）</p><p>浏览器先和服务器建立一条可靠的传输通道，即TCP连接。</p><p>4、发送HTTP请求</p><p>浏览器发送请求报文</p><ul><li>请求行：请求方法，请求的URL路径，HTTP协议版本。<ul><li><code>GET /index.html HTTP/1.1</code></li></ul></li><li>请求头：包含关于客户端和环境的信息的键值对。<ul><li><code>Host: www.example.com</code>（必需，指定域名）</li><li><code>User-Agent</code>（浏览器身份标识），<code>Accept</code>（客户端接收的内容类型）等</li></ul></li><li>请求体：通常只在POST/PUT方法中存在，包含提交给服务器的数据。</li></ul><p>5、服务器处理请求并返回HTTP响应</p><p>服务器收到请求报文后，会进行处理（例如，由Web服务器软件（如Nginx/Apache）处理静态请求，或由应用服务器（如Tomcat/Node.js）处理动态请求），然后返回一个HTTP响应报文。</p><p>服务器发送响应报文</p><ul><li>状态行：HTTP协议版本、状态码和状态消息。<ul><li><code>HTTP/1.1 200 OK</code>，<code>HTTP/1.1 404 Not Found</code>，<code>HTTP/1.1 500 Internal Server Error</code></li></ul></li><li>响应头：包含关于服务器和响应主体的信息，键值对。<ul><li><code>Content-Type</code>，<code>Content-Length</code>，<code>Set-Cookie</code></li></ul></li><li>响应体：请求的真正资源内容，HTML文档、图片数据等。</li></ul><p>6、浏览器解析渲染页面</p><p>浏览器收到响应后，会根据响应头中的 <code>Content-Type</code>来决定如何处理响应体。</p><p>生成DOM树，CSSOM树，合并构建渲染树，布局，绘制。</p><p>7、连接结束（四次握手）</p><p>HTTP是一种无状态协议，默认完成请求就会关闭连接。</p><p>8、后续交互</p><p>一个完整的页面通常需要加载很多资源（CSS, JS, 图片等）。对于HTTP/1.1，浏览器会对同一个域名建立多个TCP连接（通常是6-8个）来并行下载这些资源，以加快速度。HTTP/2则允许在一个TCP连接上进行多路复用，效率更高。</p><p> </p><h2 id="tcp和udp的区别">TCP和UDP的区别</h2><table><thead><tr class="header"><th>特性</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr class="odd"><td>连接性</td><td>面向连接<br>建立连接三次握手，释放连接四次握手。</td><td>无连接的<br>直接发送数据。</td></tr><tr class="even"><td>可靠性</td><td>高<br>通过确认，重传，校验，流量控制，拥塞控制等手段确保数据无差错，不丢失等。</td><td>低<br>不提供任何可靠机制，不确认是否收到，可能丢失，乱序或重复。</td></tr><tr class="odd"><td>数据形式</td><td>面向字节流<br>无结构，无边界，应用程序自己处理粘包/拆包问题。</td><td>面向数据包<br>独立，有边界，一次发送就是一个完整报文。</td></tr><tr class="even"><td>速度和开销</td><td>速度慢，开销大<br>各种机制增加开销，减慢速度。</td><td>速度快，开销小<br>延迟极低，传输效率高。</td></tr><tr class="odd"><td>传输模式</td><td>全双工<br>连接双方可以同时发送和接收数据。</td><td>支持单播，多播，广播。</td></tr><tr class="even"><td>应用场景</td><td>网页浏览（HTTP/HTPPS）<br>文件传输（FTP）<br>电子邮件（SMTP，IMAP）<br>远程登陆（SSH）</td><td>视频流媒体，语音通话<br>在线游戏<br>DNS查询<br>TFTP（简单文件传输）<br>广播/多播</td></tr></tbody></table><p> </p><p> </p><p>LocalStorage和SessionStorage的区别</p><figure><img src="LocalStorage.png" alt="LocalStorage.png" /><figcaption aria-hidden="true">LocalStorage.png</figcaption></figure><p>LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。</p><p> </p><p> </p><p>WebSocket</p><p>在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。</p><p>HTTP：无状态，单向请求-响应模式===&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。</p><p>WebRTC</p><p>虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN/TURN服务器。</p><p>信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
