[{"title":"机器学习","date":"2025-08-26T03:02:02.000Z","url":"/2025/08/26/machineLearning/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["人工智能","/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"],["python","/tags/python/"]],"categories":[["undefined",""]],"content":"conda指令：&emsp;查看环境：conda env list &emsp;更换为阿里云镜像源：pip config set global.index-url  &emsp;查看当前源：pip config list &emsp;下载依赖包requirements.txt：pip install -r requirements.txt"},{"title":"HTML","date":"2025-08-22T02:46:52.000Z","url":"/2025/08/22/html/","categories":[["undefined",""]],"content":"HTML DOM ​ DOM (Document Object Model)提供了对文档的全面编程接口。 ​ 主要功能：文档结构表示；元素选择和操作；事件处理（事件监听和触发、事件冒泡和捕获）；动态内容更新；样式操作；数据绑定。 DOM事件传播机制 ​ DOM事件传播分为三个阶段：捕获阶段；目标阶段；冒泡阶段。（win对象-&gt;目标-&gt;win对象） HTML标签&lt;canvas&gt; ​ 可以绘制图形，文本，描绘颜色，变换图形，还能实现动画。"},{"title":"Web","date":"2025-08-22T02:38:22.000Z","url":"/2025/08/22/web/","categories":[["undefined",""]],"content":"Json对象和数组： ​ 对象是键值对集合，数组是值的有序列表； ​ Json对象的值可以包含数组，数组的元素也可以是一个对象，能够支持多层嵌套。 前端渲染和后端渲染： ​ 前端渲染：React,Vue等；后端渲染：传统PHP,Java,Python等。 ​ 现代开发常采用混合方案：同构渲染，首次访问使用SSR快速呈现内容，后续交互转为CSR提供流畅体验，如 Next.js (React), Nuxt.js (Vue)。"},{"title":"Javascript","date":"2025-08-22T02:31:49.000Z","url":"/2025/08/22/javascript/","categories":[["undefined",""]],"content":"文件与拖拽API的底层原理 ​ 1）文件API： ​ 显示选择机制：只有通过input和拖拽等主动行为才能访问文件；无路径访问：JavaScript无法知晓真正的文件路径；同源限制：读取的文件内容只能在当前页面上下文使用。 ​ 2）拖拽API： ​ 拖拽本质是操作系统提供的跨应用（跨源）通信机制。 ​ 拖拽开始时，OS创建“拖拽会话”；拖拽过程中，系统跟踪光标位置并查询下方的放置目标；放置时，系统协调数据传递。 ​ 拖拽实现的层次 "},{"title":"数据结构和算法","date":"2025-08-22T01:17:33.000Z","url":"/2025/08/22/dsa/","categories":[["undefined",""]],"content":"枚举算法 ​ 描述：也称为穷举算法，按照问题本身性质，列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法。 ​ 核心思想：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解。 ​ 优点：简单基本，便于实现，容易调试，正确性容易证明。 ​ 思路： 确定枚举对象、枚举范围、判断条件。 枚举可能的情况并验证是否是问题的解。 考虑提高效率（缩小状态空间，限制枚举条件，找特殊性质避免重复求解）。 题库：百钱买百鸡，LeetCode1504。 vector二维数组的构造 vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n, 0)); ​ 其中vector&lt;int&gt;(n, 0)运用了vector的构造函数，创造了一个一维长度为n的vector并全部初始化为0。 动态规划Dynamic programming ​ 描述：把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常常适用于有重叠子问题和最优子结构性质的问题。 ​ 一般的递归时间复杂度太高，递归时间复杂度 = 解决一个子问题时间*子问题个数，需要把子问题的结果进行存储，利用空间来降低时间复杂度，把二叉树变成了树干，子问题个数从O(2n)变成了O(n)。同理，转换递归时存储结果时是自顶向下的解法，而动态规划就是自底向上的解法。 ​ 典型特征：最优子结构、状态转移方程、边界、重叠子问题。 ​ 核心思想：拆分子问题、记住过往、减少重复计算。 ​ 思路： 穷举分析 确认边界 找出规律，确定最优子结构 动态规划问题即是递推问题，当前的决策结果是f(n)，则最有子结构就是要让f(n-k)最优，并且与后面的决策没有关系，能让后面的决策安心使用局部最优解。 写出状态转移方程 ​ 题库：LeetCode1277，LeetCode1504 滑动窗口算法 ​ 基本思想：滑动窗口算法（Sliding Window Algorithm）是一种用于处理数组或列表子区间问题的高效技巧。维护一个大小可变或固定的”窗口”在数据结构上滑动，将许多嵌套循环的问题（O(n²)或O(n³)）转化为单循环问题（O(n)），显著降低时间复杂度。 ​ 关键点：窗口表示：左，右指针表示窗口的边界；窗口扩张：右指针移动，扩大窗口，寻找可行解；窗口收缩：左指针移动，缩小窗口，优化可行解；结果更新：在窗口滑动的过程中不断更新最优解。 ​ 例子：全0子数组的数目（LeetCode2348）"},{"title":"Hexo","date":"2025-08-22T01:16:55.000Z","url":"/2025/08/22/hexo/","categories":[["undefined",""]],"content":"​ 命令： # 新建博客 hexo new&#39;xxx&#39; # 清除之前所有的公共文件 hexo clean # 重新生成html文件 hexo g # 上传到GitHub hexo d"},{"title":"Markdown","date":"2025-08-22T01:16:09.000Z","url":"/2025/08/22/markdown/","categories":[["undefined",""]],"content":"Markdown链接语法 ​ 效果：链接文本 ​ 格式：[链接文本](url) ​ 可以使用反引号&#96;&#96;包围创建成代码片段来解决显示。 HTML指数标签 ​ 效果：2n ​ 格式：2&lt;sup&gt;n&lt;/sup&gt; Markdown列表语法 ​ 效果： 列表一 列表二 格式：- 列表一 Markdown斜体语法 ​ 效果：斜体 ​ 格式：*斜体*"},{"title":"Node","date":"2025-08-22T01:15:34.000Z","url":"/2025/08/22/node/","categories":[["undefined",""]],"content":"npm安装路径 ​ 全局安装一般在c盘的node_modules下，输入npm config get prefix命令直接查看全局安装路径。 ​ 本地安装始终位于当前项目的node_modules下。"},{"title":"CSS","date":"2025-08-22T01:14:18.000Z","url":"/2025/08/22/css/","categories":[["undefined",""]],"content":"TailwindCSS样式表 ​ 描述：实用优先的CSS框架，没有预定义的组件，而是提供了原子化的预定义类。 ​ 核心特点：实用类优先、响应式设计、快速开发、自定义框架等。 TailwindCSS布局类Layout ​ 描述：设置元素的显示类型和布局方式。 ​ 关键类：宽高比、容器 、列布局 、分页、文本断行、盒子大小、显示属性、浮动。 TailwindCSS间距类Spacing ​ 描述：控制元素的内外边距。 ​ 关键类：外边距、内边距、行间距leading-xx、字间距tracking-xx、空间。 TailwindCSS尺寸类Sizing ​ 描述：设置元素的宽度和高度。 ​ 关键类：宽度 w-xx、高度 h-xx、size工具size-xx、最小&#x2F;大宽&#x2F;高度min&#x2F;max-w&#x2F;h-xx、自动尺寸 auto。 TailwindCSS排版类Typography ​ 描述：控制文本的对齐、字体大小、粗细等。 ​ 关键类：字体&#x2F;字体粗细font-xx、字体大小&#x2F;文本颜色&#x2F;文本对齐text-xx、行间距leading-xx、字间距tracking-xx、响应式字体。 TailwindCSS背景类Backgroud ​ 描述：设置元素的背景颜色、背景图和透明度。 ​ 关键类：背景颜色bg-xx。 TailwindCSS边框类Borders ​ 描述：设置元素的边框、边框宽度和圆角。 ​ 关键类：边框宽度&#x2F;颜色&#x2F;样式Border-xx、边框半径rounded-xx。 TailwindCSS交互状态与动画 ​ 描述：处理元素的交互状态（如悬停、聚焦等）和创建流畅的动画效果。 ​ 关键类：悬停、聚焦、激活、禁用、过渡、变换。 内联元素和块级元素区别 ​ display属性可以改变，display-block，元素表现为块级元素；display-inline，元素表现为内联元素；display-inline-block，混合特性，不换行但可以设置宽高。 Media Queries ​ 是CSS3的核心功能之一，它使网页能够根据不同的设备特性（如屏幕尺寸、分辨率、方向等）应用不同的样式规则。"},{"title":"Vue3","date":"2025-08-22T01:13:25.000Z","url":"/2025/08/22/vue/","categories":[["undefined",""]],"content":"Vue3 ​ 描述：Vue.js是一套构建用户界面的渐进式框架，只关注视图层，采用自底向上增量开发的设计，尽可能通过简单的API实现响应的数据绑定和组合的视图组件。 ​ 优点：响应式数据绑定，虚拟DOM，灵活性与渐进性，易于集成等。 ​ 命令： # 创建Vue项目npm init vue@latest # 启动开发服务器 npm install npm run dev # 打开图形化界面 npm install @vue/cli vue ui Vite ​ 描述：是一个现代化的前端构建工具，通过利用现代浏览器的原生ES模块支持，提供快速的开发体验。 ​ 组成： 开发服务器：基于原生ES模块，提供超快的热更新。 构建命令：使用Rollup打包代码，生成适用于生产环境的优化静态资源。 优点：急速启动，快速热更新，支持TS，JSX等，高度可扩展。 "},{"title":"Docker","date":"2025-08-22T01:08:08.000Z","url":"/2025/08/22/docker/","categories":[["undefined",""]],"content":"​ 描述：Docker是一个开源的应用容器引擎，基于Go语言，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 ​ 优点：跨平台一致性，资源高效，快速部署，隔离性。 ​ 基本命令： # 拉取镜像（如官方Nginx镜像) docker pull nginx # 查看运行中的容器docker ps # 运行容器（-d 后台运行，-p 映射端口）docker run -d -p 80:80 nginx # 构建镜像（基于当前目录的Dockerfile）docker build -t my-app . # 进入容器内部docker exec -it &lt;容器ID&gt; /bin/bash # 查看进程占用的端口号 ps aux"},{"title":"C++","date":"2025-08-22T01:07:22.000Z","url":"/2025/08/22/cpp/","categories":[["undefined",""]],"content":"C++右值自增是在表达式后一步再自增。"},{"title":"计算机网络","date":"2025-08-22T00:54:11.000Z","url":"/2025/08/22/computerNetworks/","categories":[["undefined",""]],"content":"LocalStorage和SessionStorage的区别 ​ LocalStorage适合存储需要长期保留的数据，而SessionStorage适合存储临时会话数据。 WebSocket ​ 在单个TCP连接上进行全双工通信的应用层协议，解决HTTP协议在实时通信方面的局限性。 ​ HTTP：无状态，单向请求-响应模式&#x3D;&#x3D;&#x3D;&gt;WebSocket：持久连接，双向实时通信。还免去了重复的HTTP头开销。 WebRTC ​ 虽然设计为P2P通信技术，媒体流是双向传输，但需要借助信令服务器和STUN&#x2F;TURN服务器。 ​ 信令服务器：交换SDP会话、房间管理；STUN：获取公网地址；TURN：数据中继。 TCP&#x2F;IP五层模型（下到上） ​ 1）物理层：通过物质介质（光纤、电缆等）传输原始比特流，数据单位是比特。 ​ 2）链路层：在直接相连的节点间传输数据，处理物理寻址（MAC）和错误检测，数据单位是帧。 ​ 3）网络层：负责逻辑寻址、路由选择和分组转发，数据单位是包。 ​ 4）传输层：提供端到端的数据传输，流量控制和错误恢复，数据单位是段。 ​ 5）应用层：为用户提供网络服务接口，处理应用程序逻辑，数据单位是数据。"}]